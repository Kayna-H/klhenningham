"CSC 517, section 001, Fall 2011",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Gehringer, Ed",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Wednesday, April 25, 2018 10:40 AM EDT",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Assignment Name,CSC/ECE 517 Final Examination,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Due,"Dec 14, 2011 11:59 PM EST",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Questions,,,Total,1949218,,,,,,,1949220,,,,,,,,1949008,,1949009,,,,1949881,,1949885,,,1948917,,,,1948918,1948930,,,1949882,1948896,,1948904,
Points,,,,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,4,2,4,2,2,5,4,3,3,3,3,4,3,3,7,3,3,3,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,Strategy,Template,Composite pattern,Adapter,Singleton,Visitor,Prototype,command,This is not an adapter because the adapter just provides a ?wrapper? with the desired interface and does not determine with respect to different class of the argument.,Factory Method,Prototype pattern just clones and existing object and provides so that we need not re write the code again and here thats not what is required. It requires to have different implementation for different type of requirements. not the same requirement.,Decorator Patern,This is not an adapter because the adapter just provides a ?wrapper? with the desired interface and not wrapper over a wrapper and wrapper inside.,Observer,Abstract factory pattern is the one which allows client to create families of objects without specifying concrete classes.Here we require something which knows which key has been pressed.,The above method is not well formed. The values are not internally consistent. IT might be changed by the setter method to some other time.,"the hour and minute values should be non negative, the hour should have values between 0 to 24 not including 24 and minutes should have values between 0 to 60 not including 60. This invariant has to be checked to ensure that the Time class gives the time in 24 hour format. assertInvariants() function can check all these for the class before it proceeds to what it it supposed to do..",length of array B should be same as length of array A.Check if old values of the array B are required and copy in another variable.,it is not mentioned that the array would contain integers. It was assumed that the array is integer array and the method is formulated. If the array is not integer array this method wont work.,check if values in array A are same as in array B.,change the length of array B to the same as the length of array A.,"Its the shopping carts responsibility to check if the two items are the same. The principle of low coupling and high cohesion is used here. Here if the function is in the Item class it decreases the cohesion of the class because it does more that what it is supposed to do, i.e maintain the details of the item.",This example is wrong because in Prototype pattern cloning creates the reference to the same object for reading the information from the object. It says that only if we write anything or change anything does the clone create a new object and provide it. So in this example it is still pointing to the o1 object as o1 is null o2 becomes null.,Here the relationship is Person Has A Location (Birth Location).Advantages: All the information about the Person is in the Person class and we need not go to other class object to find the information.Disadvantages:if we want to know the details of all the persons who are born in a particular location it is not possible since we have to look into each and every persons record to find if he is born in the location intended.,"Here the relationship is Location Has Many PersonsAdvantages: if we want to know the details of all the persons who are born in a particular location it is possible, since we can directly look into Location object and find all the persons who are born in the location.Disadvantages:All the information about the Person is not in the Person class and we need not go to Location object and search for this person to find the information of this person.",Here in the new approach the new class has a Has A relationship with both the Location and Person.Advantages: We can find the details of the birth location of the person in this class and also the details of all the People who are born in the location. Disadvantages: A new class has to be created and i may leads to complexity. It is not worth the new class creation unless the user needs both types of information.,"we can make the object singleton object for a particular value. So that who ever tries to get the object they will get the same object if they try to get the instance of the class for same value. It can be done this way: We can make the constructor private and provide a function gatInstance() which take in the money in form of dollars and cents. Maintain a variable in class which has the object instances for every particular value created. So when we call the getInstance() we would see if an instance for the value has already been created, if yes give the same instance else create and new instance save the instance in the variable and return the instance.",Yes there should be other ways u should be able to get money. We might want to know the exact denominations of our money to know if we have enough change. ex: we want to know that we have 1$ and 50 cents money instead of knowing 150 cents. Advantage: It will help us identify the money in terms of various denominations which might be useful as some of them dont accept dollar notes but only coins. Disadvantage: We might have to complicate the system in order to provide the required functionality. Every new way the user wants we have to create a new condition i.e change the existing implementation and code.,Yes we need the get amount method to know the amount we haveWe can use it to convert to other currencies. We can know the current status of the money.,Multiplication and division of USMoney objects does not make sense because it does not mean anything to ask to multiply 1$ 30 cents with 2$ 50cents. The money is a collection of longs and we multiply collection of longs with only one long or double.,We can add our own class or interface and use all the existing functions of the currency class by wrapping it over by the methods of our new class and the methods which we want to override can be overridden. This interface or class is used instead of the Currency class. This way we can solve the problem.,It can save memory as the initialization is done when needed. No need for the repetition or copy of data. We can initialize it to the object which is passed during the constructor of the class so that it references the existing object and its variables so that copy of the data is avoided.,Debugging is difficult if lazy evaluation is used.We may use the non initialized object before it has been initialized causing the program to crash,Because they may be used accidentally by some object of this class resulting in errors since the instance may not have been initialized.,"the problem with this method is that you have to create you own iterator variable i which helps us iterate through the array.Also, we have to store the current value in a variable and maintain the state. U would have to know which type of object it is i.e the details of the array. The idea here is to eliminate storing data at multiple locations and at a single place. If iterator pattern is implemented all this data is maintained in the separate class and is data nedd not be duplicated here again.","Observer: You, who is trying to reach the executive.Publisher: The executive in the company.",Leave a message asking the executive to call you back when she is free.,ActionListener uses push model. The JButton is the Subject here and all the listeners who registered for the JButton are the observers. Since the JButton(Subject) is notifying the Listeners (Observers) whether they needed it or not.,Push method:When there is a Cart class and items in the cart class. The Cart class cannot use pull method to know if there is any addition of item to the cart. It should automatically be push notified if any item is added to the cart so that it can update the details appropriately. Pull Method:CheckoutItems class checks if the cart is empty or not and when the checkout button is clicked it will check of the cart is empty. Here it will want a pull request since it need not be bothered everytime the cart becomes empty or the cart is filled with items. The Checkout method will pull the status from the cart class and show the status to the user.
,,,90,2,1,2,2,1,0,1,0,0,1,2,0,0,0,2,3,4,2,4,2,2,0,4,3,3,3,3,4,2,2,7,3,2,3,6,2,4,4,4
,,,,Strategy,"Template Method. Printing tickets is a common algorithm for different sorts of tickets. Only the printing of headers and footers can be made abstract in the base class and have the CanadaTicket, AustrailiaTicket subclasses provide their own implementation.",Composite pattern. Every container looks like a same Composite.,Adapter. We can write an adapter method that will have the interface that we want and translate it to the existing method's interface.,Singleton. The String class is made immutable and singleton so that nobody can make another instance of it or dup() it. But there could be lot of references pointing to the same String object and each of them may look like a different copy.,Bridge.,Command.,Template Method.,An Adapter involves interfacing one class to another through an intermediate adapter. Here no such interfacing is involved. Hence this can't be adapter.,Abstract Factory.,"Because in prototype, we create an object by cloning an existing object, which is not the case here.",Mediator/Object Pool,An Adapter involves interfacing one class to another through an intermediate adapter. Here no such interfacing is involved. Hence this can't be adapter.,"Observer/Singleton. The application is the Observer that listens to user's key presses. Singleton is used to implement the dialog boxes, so that only one instance is created at any time.","In case of abstract factory, we have an abstract base class/interface that provides some creation methods. ConcreteClasses implement that interface. Client unaware of which object is being used can simply call those create() methods to obtain the appropriate Objects. This pattern is not found in this example.","Yes it is a well formed class, since the values returned by the getter methods are consistent with what has been set. That is each object indicates a time of the day. The values of hour and minutes are set using the setter methods. The getters simply return the values. Hence the state of the objects is well formed between public method calls.",values of hours and minutes represent a valid time on a 24 hour clock.,Array B must have the same length as Array A.,"Special cases or exceptions are not mentioned. For instance what is the behavior if A is empty and B has some elements, will B be initialized to empty array?. It is not very clear from the signature which direction the copy is happening (A to B or B to A).",Contents of array A will be copied to B in the same order. Old values of B are lost.,"We have two options:1) Check if both A and B have same lengths,if not throw exception2) Just copy the elements of A till the max_length allowed by B. In this case post conditions must be specified clearly.","Add a new Comparator class for comparing Items objects. This would mean that Items are responsible for only the item related data and nothing else. Hence provides good ""separation of responsibilities"" and also adheres to the guideline ""a class should do only one thing and do it well"". This also has the advantage that in future any new subclasses of Items are added, for instance, ConsumerItems, then the same comparator code can be subclassed and utilized.","One problem with this example is that, the clone() method returns an object of type Object. Hence the object returned by clone should be typecast to MyClass before calling any method on that. Also, it overlooks the implications of deep cloning and shallow cloning.A deep clone clones the instance variables in the cloning object while a shallow clone shares the instance variables between the clone and the original.Also, here the client is aware of the actual concrete class that needs to be cloned. if this is the case, the client can instead create a new MyClass object and pass the params from o1 to it, without having to rely on clone(). Typically, prototype is used to avoid conditional tests before creating an instance.","This is typical of Composition-Delegation. Advantage is that, every Person object is aware of its location, hence access to the location information is available with each Person's information.  Disadvantage is duplication of Location objects since each Person has different Location object even though they represent the same location (and hence have the same data).","If our application has to obtain some location based statistics, this method would be good, since we can query each Location object about its information (census,etc). This approach has the disadvantage that, if you want to access information about a Person, you will have to query each location object for that Person object, which is very inefficient.","Here there is a problem of maintaining consistency. For instance if a person object is swapped with another object, the corresponding location objects should also be swapped. Also we will end up creating multiple Location objects even if all of them represent the same data(location).","The USMoney class could be made a Singleton, by making its constructor private and declaring it as final. Then we could provide a static factory method - instance(int dollar), to this class that creates a single instance of the USMoney for each of the params. That is only one instance is created for $1, one instance for $2,etc. Each time instance($1) is called, it maintains a Hash of $ vs Objects, and returns the appropriate instance.","One problem with returning everything as cents is that, huge amounts could be difficult to interpret for the client of getAmount(). One alternative could be to return float values as dollars. But this has issues related to floating point round offs.","We need getAmount() to fetch the value of the current amount in the USMoney objects. This is useful if we want to convert USMoney to something else, or if we want to get the total amount in our Wallet. It can also be used while creating new USMoney objects out of the existing ones, since USMoney is immutable.",There's a single abstraction to represent the Money - USMoney. Hence any integer cannot be used as money. Hence it doesn't make sense to add an integer to USMoney.,"Here we have the Money class that stores only the amount and has a reference to the Currency object that tells what currency it is. Currency gives us the exact fractional representation and the Symbol to be used. It is not concerned with displaying the actual amount. We could add a DisplayCurrency class, that can be used by Money::toString() method to display the amount in a particular format. In fact the DisplayCurrency can be made Abstract and have different countries implement different ConcreteDisplayCurrency classes.The client then passes the appropriate DisplayCurrency object to the Money class. Since the Money class knows the amount and currency, Money class is the one that should pass these params to the DisplayCurrency methods.","The advantages from an application perspective of lazy initialization are that users don't have to pay the initialization time for features they will not use. If you defer initializing those components until use time, your application will start up much quicker.Also sometimes initializations of certain resources may take up resources, which may be needed for other tasks. Hence it makes sense to defer initialization until it is actually needed and immediately free the resources after their use.","The main disadvantage of lazy initialization is the time penalty associated with each access of the variable, assuming we initialize each time we access a certain variable. Also, initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.",Because the user of the class thinks that when the object is instantiated all the instance variables are properly initialized. He has no clue about the lazy initialization and hence might result in run time crashes.,"The intent of Iterator is  ""Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation. "". This design enables random access. Collection class is maintaining the size as well, along with the actual data. Hence increases the number of class invariants. Another problem is if the internal collection is sequential access based (e.g linked list), then this random access method would make it very inefficient.","I'm the Observer,Executive is Publisher.","3rd choice. Since the Observer does not have to wait for the Publisher to perform some action. Whenever publisher is done with his task, Observer will be informed. The other two choices require that Observer be engaged with Publisher, even though publisher is not responding, which is not what Observer pattern is about.","This is Push model, since the Observers will never poll the JButton, but instead whenever an event occurs, JButton calls actionPerformed() and notifies them with that information.","In push model, the subject sends observers detailed information about the change, whether they want it or not. But, in pull model the subject sends nothing but the most minimal notification, and observers ask for details explicitly thereafter. So if the Observers just care about a notification rather than all the data associated, then pull model is better. Also, push model assumes publishers know something about their observers' needs. Hence it provides all the necessary details. This might make observers less reusable, because Subject classes make assumptions about Observer classes that might not always be true.On the other hand, the pull model may be inefficient, because Observer classes have to keep querying the Publishers for the event info."
,,,100,2,1,2,2,1,2,0,2,2,2,2,1,2,2,2,1,4,2,4,2,2,3,4,3,3,2,3,4,2,1,7,3,3,2,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Template. We can have the integrate method to be abstract that can be implemented differently based on the need.,Factory,Composite,Adapter,Singleton,Bridge,Prototype,This could be a builder pattern since the representation and actual implementation are separated.,this is not an adapter pattern because we are not designing interfaces that different classes can use.,This is a factory pattern. Different versions can be created in the subclasses based on the type of document that is needed,"This is not a prototype since no clone is created to represent the object, which could have helped create another object based on the prototype.","This is a ""Chain of Responsibility"" Pattern. Since the responsibilities are being sent in a chain from database to model to element.",This is not an adapter because we are not designing to any pre-existing interface. We just pass responsibility in a chain to classes that can handle this.,This is an example of a state pattern. A state is defined for each dialog box and when the particular state is found the corresponding action takes place.,This is not an Abstract factory because we are not creating different families of classes. We are just concerned about the dialog box that has to be brought up as every command is issued,The class is not well formed since the hour can be given a value that is more than 24 and also the minutes can have a value more than 60. Plus the class does not restrict negative numbers from being given.,hour >=0 and hour<=24 minutes >=0 and minutes<60,"if(a.length<0)System.out.println(""No data to copy"");",There is no check as to whether the data to be copied is available or not. That is the array A must have at least 1 value to be copied to B,"We can have a method in the copyArray classboolean isConsistent() { return Arrays.equals(A, B);}We can check as assert copyArray.isConsistent();",The post condition must evaluate to true always.  assert ((B[] = new A[]) != null);,"The responsibility should be with the item class. Since the item class holds the data (_productID) that is used to determine if the products are same the method that compares _productID's should also be in the same class. This is the expert pattern that says, ""The object that contains the necessary data to perform a task should be the object that manipulates the data"".","clone() method should be called as super.clone() with MyClass type casted. This invokes the Objects's clone() method. Since MyClass does not provide any clone method, we cannot directly invoke clone method on MyClass object o1.",AdvantagesEasy to implement and also the person object can keep track his place of birth. Disadvantages.This requires tight coupling between Person and Location.,AdvantagesEasy to implement and also the location object can keep track of  place of birth of a person. Disadvantages.This requires tight coupling between Person and Location. Also for every person born we have to call the person class.,Advantages:There is no tight coupling between person and location and hence changes in one class does not affect the other class.Disadvantage:We must write the code required for delegation to the third class,"We can use a singleton pattern such that whenever an object that represents $1 is required, the singleton pattern returns the instance of the object.","Since the object stores $1 in dollars, we need to convert it into 100 cents and then return the amount. Here we would need to have conditional which identifies if it is in dollars and then convert it into cents. This seems a little more tedious to implement.We could use the object to represent $1 in terms of cents as 100 cents. This way we would not need to do additional modifications to the getAmount method.","We would need the getAmount method to return the amount to an object that calls it. For example, if we need to display the amount, we would need the amount to be returned to the display method, which then can convert the cents and represent it in USD format.","In case of addition and subtraction we are adding money. We would need to find out the amount that results from adding and subtraction a quantity representing money with another quantity representing money. However, in case of multiplying and dividing, in real life we only use a factor.Say, we divide $6 among four people. Thus we would only need to divide the USMoney object by 4. In reality, we will not  face the scenario of ""dividing money among moneys"".","We can have a currencyFormat class that gets and sets the format needed. The currency class can use this format to determine the way it is going to display the currency. Here, we are using a third class to code those that differs among currencies.","1. We need know about the instance creation. The method takes care of the instance creation and if there is already one the method just returns the instance.2. Memory is saved as objects are created on the fly as when they are needed.3. When an object never needs to be created, we can save on performance since we are not concerned about finalizing and destroying the object","1. Every time an object has to be created, there is a check that has to be performed. Even when the object is being created for the first time.2. Instances that are not frequently used are referenced and updated and could waste storage or give the garbage collector more work.",This gives access of the instance variable to outside of the class and therefore it can be subjected to change.,"In some cases we would need to use multiple iterators. For example, we may want to calculate the cross product from a stack. In this case we would need two iterators for sequencing.  The above design does not allow multiple iterator objects being created.",The observer is the person who is making the call. He calls and observes if there is a response from the executive. The executive is the publisher. He responds to the observer when he is free.,The third choice. Here the publisher publishes an event that he is free and then the observer can subscribe to the publisher,"It is push model. Because every time an action is done, all the listeners are notified that the action has been done. The listener does not inquire whether an action was done.","Push model can be used when the data that is being pushed in not huge. If it is, it gives the subscriber a large amount of data that they do not need.Pull model requires two method calls. One from the subject that something has happened and the other by the subscriber to inquire if for an event. But when the data is large it is better to use the pull model as they are easier to write. Pull model can be used in a situation when there is a firewall. Since all data are only outbound, a pull model can be used here."
,,,89.5,0,0,2,2,1,2,1,0,2,1,2,0,2,0,2,3,4,1,4,1,1,5,2,2,2,3,3,4,2,2,7,3,2,1.5,6,2,4,4,4
,,,,Strategy,Template method,Composite,Adapter,Flyweight,Abstract factory,Prototype,Template Method,"Adapter is a design pattern that translates one interface for a class into a compatible interface. An adapter allows classes to work together that normally could not because of incompatible interfaces, by providing its interface to clients while using the original interface.Here there are no incompatibilities. Here, nowhere it has been mentioned that we need a wrapper class to make the interfaces compatible. Also, this problem does not have any interfaces that are not compatible which need an adapter. Hence we dont need a wrapper here!!",Abstract Factory,"Both Abstract Factory and Prototype are Creational patterns.But the above is an Abstract Factory and not Prototype because of the following reasons:1. In prototype,  type of objects to create is determined by a prototypical instance, which is cloned to produce new objects. But here, we dont do this. We dont have to clone the existing objects to create new ones. 2. Here we use abstract factory because Abstract Factory offers the interface for creating a family of related objects, without explicitly specifying their classes. We dont use prototype here because in Prototype, you specify the kind of objects to create!! and here we are not specifying the kind of objects to create!!","Chain of responsibility.At each step, the request is passed along from one (handler) to another.database - &gt; Model -&gt; Element = gives result","Adapter is a design pattern that translates one interface for a class into a compatible interface. An adapter allows classes to work together that normally could not because of incompatible interfaces, by providing its interface to clients while using the original interface.Here there are no incompatibilities. Here, nowhere it has been mentioned that we need a wrapper class to make the interfaces compatible. Also, this problem does not have any interfaces that are not compatible which need an adapter. Infact, the problem says that the responsibility is transferred from one step to another to achieve a goal.","Singleton.When  ctrl-F is pressed, it is checked if the instance is already there, if it already open, then existing one is used, if not a new one is created. Same for other presses. This can be thought of the lazy initialization of Singleton pattern.","Abstract factory is used to create a family of objects in a particular hierarchy without having to specify their type in advance.  1. there is no heirarchy here. hence no abstract factory2. We are specifying the type in advance (control+F, control+R etc), hence not abstract factory","The class is not very well formed. This is because of the following reasons.1. This class does not have any class invariants that keep the object in a well-formed state. the public set and get methods do not inform anything about the current state. What if the hour is &gt; 23 and minutes is &gt; 59. This means the state is invalid. Therefore the design of this class is not very well formed.Skrien 4.4 says1. Public methods should always keep objects in a well-formed state.2. Be aware that, although it can increase the efficiency of your code, caching values instead of computing them when they are needed can also increase the complexity and number of invariants of your class.","The invariant here has to check whetherHour is in the range 0 .. 23 Minutes is in the range 0 .. 59 Other facts:1. A class invariant is a condition that defines all valid states for an object.  2. It is a logical condition to ensure the correct working of a class.  3. Class invariants must hold when an object is created, and they must be preserved under all operations of the class.  4. In particular all class invariants are both preconditions and post-conditions for all operations or member functions of the class.",The preconditions are :1. Length of Array B should be equal to length of Array A.,"Yes. The return type is void.This is pass by Value. We are passing the copy of two arrays to this function. We have to return the array B . Otherwise they dont modify the actual A and B. When we pass by value, a copy of the array is passed. The original arrays are not modified.Therefore, we have to return B. The return type is void here. This is ambiguous, Infact its of no use. If we dont return B, once the function exits, scope of B is gone and we cannot retrieve the copied array B.","The postconditions are:1. Elements in Array B must be in the same must be the same order as elements in Array A.2. Basically, Array B must be equal to Array A in contents.","1. Have Dynamic arrays which can grow and shrink. May use Arraylists for Integers. Arraylists grow and shrink in size and they can have Integer objects (in java).By using this, the length need not be equal, and precondition need not be checked.",The ShoppingCart should have the responsibility of deciding whether two Items are the same.Expert pattern Principle says that the object that contains the necessary data to perform a function  should be the object that manipulates the data.here the object of the Shopping Cart contains the necessary data to perform a function . and Hence it should manipulate the data.,"This is because Clone() function is as follows:public Object clone() {	try {		return super.clone();	} catch (CloneNotSupportedException e) {		// This should never happen		e.printStackTrace();		return null;	}}Super.clone is called here and therefore the o1.clone() returns an object of type OBJECT. And, we cannot assign an object of type Object (generalized class) to an object of the type specialized class.o2 = o1.clone(); // This is wrongo1 is of type Object here (parent class - Generalized class)and o2 is of type Myclass (subclass - Specialized class)We cannot assign from generalized class to specialized class.Instead we should typecast likeo2 = (MyClass) o1.clone();This works.","This is Composition.Every person ""has-a"" location.Advantages: Here inheritance cannot be used because, location and person do not have an ""is-a"" relationship. Composition is the best way to deal with this situation.1. The implementation details of location is abstracted from the person. If we change something in the location, the person will be immune to this. We need not change anything in the person. This is nothing but, ?Black-box? reuse, since internal details of contained objects are not visible. 2. Fewer implementation dependencies3. Good encapsulation4. The composition can be defined dynamically at run-time through objects acquiring references to other objects of the same type Disadvantages:1. Resulting system tends to have more objects.2. When the systems get complex,Interfaces must be carefully defined in order to use many different objects as composition blocks.","This is also Composition. But here Location ""has-a"" person. This is no doubt a bad design. Advantages: Advantages of composition  could have been applied here as well... but No such advantages with this design because there is no ""has-a"" relationship at all.. Disadvantages:1. bad type of design.2. Location has a collection of person objects. If something is modified somewhere , we need to deal with the collections and not instances directly.3. The design itself it not good and makes the system complex.","Here, a third object links the person objects to their location objects.Advantages.1. Person and Location are simple and they is no coupling between them directly.2. Changes to the person will not affect location and changes to location will not affect person. However, the third object should be updated3. There is a separate object that is meant for record-keeping.Disadvantages1. Overhead of a third object.2. Changes made in person or location should be updated in the third object everytime.1. Extra object is unnecessary.",We have have the singleton pattern here.If the object ever represents $1 then have a singleton pattern that creates only a single instance of the object.,Yes there can be additional variations of getamount() that can return the amount in some other form.,Yes . we need the get amount method. It would be used to return the amount to who ever calls the function.Acts as a getter.public long getAmount() {return amount;},"Here we,?	Add or subtract itself to or from another USMoney object.?	Multiply or divide itself by a given positive or negative number.We cannot multiply and divide by USMoney objects because multiplication is done by a factor and division is done by a divisor. It makes no sense to multiple or divide two USMoney objects. If we did so, we would be doing it to get some result which is not useful.","1. Have a single money class as shown below: Here?s our new implementation of Money:public class Money implements Comparable<Money> {private long amount;private Currency currency;public Money(long amount, Currency currency) {this.amount = amount;this.currency = currency;}public long getAmount() { return amount; }public Currency getCurrency() { 	return currency; }public int compareTo(Money o) { ... }public boolean equals(Object o) { ... }public int hashCode() { ... }public Money plus(Money) { ... }public Money minus(Money) { ... }public Money times(double factor) { ... }public Money dividedBy(double divisor) { ... }public Money negate() { ... }public String toString() { ...below... } // this method provides the         formatting for currency.}The toString method here gives the money in the format specified.The java Currency class provides a to_string as shown:public String toString() {String sign = (amount < 0 ? ""-"" : """");Long absAmount = (amount < 0 ? -amount : amount);String code = currency.getCurrencyCode();int fractDigits = currency.getDefaultFractionalDigits();int unit = tenToPower(fractDigits);if (fractDigits > 0)return sign + absAmount/unit + "".""+ fill(fractDigits, absAmount % unit) + code;elsereturn sign + absAmount + code;}where tenToPower and fill are auxiliary methods.Whenever we want to change the way we have to represent the money, then we can change this function .We can have overloaded functions for toString that return the required format depending on the parameter list.2. . Have an abstract class that has all the methods as shown below:","There are many advantages:1. If you never use the value, you don't pay for it.2. Initialization costs can be more spread out by not initializing everything at once.3. In some cases, startup appears to be faster.4. Ability to delay until needed information is available.",There are many disadvantages:1. Code needed to check to see if it is time to initialize the value each time it is used.2. Time spent in the above code each time the value is used.3. Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.4. More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.,"It is a good practice to make instance variables private and have getters and setters.If we have public instance variables, they can be changed from anywhere in the program. They can be changed or given a value even before initialization from anywhere in the program, It can result in inconsistencies, And difficult to track. Therefore, it is not a good practice to have public instance variables lazily initialized.","Here, get(i) will return the ith object.This is however not a good design because,If we use iterators, we can have multiple iterators. Here we need to have two for loops which increases the complexity.Iterators can keep track of where their position is . For example hasnext() will check if there s a next element from where it is currently that is on which index. But here, we cannot keep track of where the index if. For example, if we retrieve the first 5 objects, and exit the loop and want to continue from the 6th object again., the state of where it is , is not tracked.Also, this can be used only for collections which already have the size() method defined. What about other data structures if size or length is dynamic and keeps changing and we want to keep checking for hasnext(). This situation wont work well with the above code.",(The person who is calling the executive) I am the Observer.The executive is the Publisher.,"The second choice is  close because here the observer (I) is ""polling"" the Publisher for an event to happen. Its the pull model of the observer pattern.The observer (I)polls the Publisher for the interested information and once the event happens, that is executive becomes free, the information is given to the observer,The third choice not so close to the Observer pattern.This is because the caller (I) who is the observer subscribes by leaving the message to the executive. After subscribing they keep doing their work. The observer/caller may also be waiting for an event to happen (the event may be the executive becoming free and receiving the call). As soon as the event happens (the executive becomes free), he notifies/publishes calling the observer. Not so closeThe first choice also looks like an observer pattern but not so close because the observer calls (subscribes) and waits there waiting the event to happen and the executive to get back. How he subscribes is just by calling and holding. But in the third choice, a message is left indicating the subscription and then notified when the executive is free. Not so close.",Push model,"PUSH MODEL: Program requirements1. Send small amount of data.  Should not be used when large amount of data need to be sent from Subject to observer.2. Send data that is useful. Should not be used when the data sent is large and rarely used.These twp points summarized below:The subjects send detailed information about the change to the observer whether it uses it or not. Because the subject needs to send the detailed information to the observer this might be inefficient when a large amount of data needs to be sent and it is not used.Another aproach would be to send only the information required by the observer. In this case the subject should be able to distinguish between different types of observers and to know the required data of each of them, meaning that the subject layer is more coupled to observer layer.PULL MODEL:  Program requirements1. Efficient when single threading is used.2. Used when communication overhead is not an issue Time is not that big a concern. Summarized below:The subject just notifies the observers when a change in his state appears and it's the responsibility of each observer to pull the required data from the subject. This can be inefficient because the communication is done in 2 steps and problems might appear in multithreading environments."
,,,94,2,1,2,2,2,0,1,2,2,2,2,0,2,2,2,3,4,2,4,2,2,2,4,2,1,3,3,2,2,2,6,3,3,2,6,2,2,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Decorator.,Template Method,Composite pattern.,Adapter,Singleton,Bridge,Memento,Iterator pattern.,"This is not adapter because, because there is no incompatible class.",Abstract factory,"Because, here we are not creating the instances by copying or cloning.",Chain of responsibilities.,"This is not adapter because, the client is dealing directly with all the classes and they are compatible. There is no wrapping of any classes and no interface to translate between any two classes.",Singleton.,"This is not abstract factory because, when we create objects using Abstract factory pattern,  it gives us a different instance of each type. Which is not the case in our question.",Here we are caching the values of of hour and minutes instead of computing them when they are needed and this can also increase the complexity and number of class invariants.,The statement of equality of the value of hour and the instant variable hour in an object of the Time class is a class invariant.The statement of equality of the value of minutes and the instant variable minutes in an object of the Time class is also a class invariant.,Arrays A and B have to be of same length.,"All the elements in B have to be lost. If the lengths are not equal, then there will still be elements left in B.",Post conditions are:Array B has to have the elements in the same order as that of array A.,Both the arrays can be of different length.Not all values of B have to be lost.,"ShoppingCart class. This is because using the concept of iterator pattern. Whenever we are getting a product_id from get_productID() method,  we need to traverse through the private arraylist_items and check if the value has already been added to the list of not.","Because, the MyClass here does not implement the Cloneable interface.","Advantage: Good Object oriented design. The person keeps tract of its location.Disadvantage: Consider what happens when the program needs to delete the currently selected person. In that case, the only way to find the selected ones is for some object to traverse the collection of all the persons and ask them individually.whether they are selected, and, if so, delete them",Disadvantage: The person will not know where their location is. Expert pattern is not followed.,Advantage: We can have concurrent access.Disadvantage: should the person themselves alsoknow whether they are selected?,"We can implement the USMoney class using the Singleton pattern.We we have make the constructor of the USMoney class private.    private USMoney(){ }We have to declare the instance of USMoney class as private and static(class instance) follows:      private static USMoney uniqueinstance= new USMoney();All the other classes who wants to access this instance have to call a public method, also a class method called getAmount() present in this USMoney class, which returns the instance 'uniqueinstance'.      public static USMoney getAmount()  { return  uniqueinstance; }",Representing the dollars and cents as floating point numbers is an alternative.The advantage with this representation is that you can represent larger numbers and you can represent fractional parts of dollars conveniently.The disadvantage is the round off error while approximating the floating points.,"Yes, we will be needing getAmount() method. The getAmount() can be used to get the amount of money in cents. It can be positiveor negative.","We perform multiply and divide methods by plain doubles because these methods use floating point calculations and as a result, have round-off issues to deal with.","To maintain such currency, where we have to represent a currency using value comma and its symbol, we can use HashMaps to store the values.",We can get the behavior of having an instance created on only the first call to the Instance() method.,"The disadvantage is the time penalty associated with each access of the variable caused by nil.Another disadvantage is that initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.","We would not want to make publicly available instance variables that are initialized lazily because, direct access to the lazy variable would bypass the initialize on first access code.","Here although all the collections seem to have a method get() which looks same, the return type for each of the collections will be different. So, because of this, we will have to implement a different loop for each kind of collections to step through the implementations of the various collections. As a result, as we add collections, the number of loops also increase. This is a major disadvantage with this design.",Subject- Executive.Observer- you,"The third choice ""Leave a message asking the executive to call you back when she is free"" is the one that corresponds mostly to the observer pattern. This is because, in the third case we are leaving a message asking the executive to notify whenever she is free that is, the executive(subject) notifies you(the dependent or the observer) whenever she is free(change of state from busy to free) and updates automatically.This is exactly what an observer pattern does(whenever an object changes state, all its dependents are notified and updated automatically).","The ActionListener will use the push model. Because, here we are using observer pattern and hence we subscribe observer to the JButton class and whenever a JButton(subject) is clicked ActionListener is invoked. Also the observer here implements the ActionListener. So, when JButton is clicked or when this action is performed, the ActionListener is invoked and since the observer implements this ActionListener interface, the observer performs the actionPerformed() method and the JButton object which is clicked will be passed as a parameter to this method and the observer thus comes to know about which button is clicked.","Whenever a Subject has to know the needs of its observers, making observers harder to modify without affecting Subject, pull model is preferred. Because, in such program requirements, the push model is less flexible.Also when more method calls are on the subject, we prefer the push method because, the pull model is less efficient when such a requirement is present."
,,,79.5,0,1,2,2,1,2,2,0,2,2,2,0,2,2,2,2,0,2,4,2,2,0,1,3,2,3,3,4,2,1,2,1,2,1.5,6,2,4,4,4
,,,,"The Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Therefore at runtime, the program can call on the corresponding strategy based on the type of curve.","Factory Pattern. Since we know in advance which type of ticket will need to be created (based on the location), a factory object can be used to create the specific type of ticket relevant to the location.",Composite Pattern.,You could use the Adaptor Pattern to contain the existing class in an adaptor class.  Have the adaptor class match the required interface and call the its methods instead of the existing class.,The Flyweight Pattern can be used to provide only one representation in memory.,"The Template Method Pattern, a base abstract class for both the time-sliced and pre-emptive threads that contains basic structure of the algorithm, any system specific functionality will be part of abstract methods. This abstract class will be extended for the Java VM and native operating system will implement the abstract methods according to their specific implementation.","The Memento Pattern could be used to take a ""memento"" of the brake before disassembly to provide a reference to its state when the time comes for reassembly.",This is the Template Method Pattern.,"The Adaptor Pattern is used when an object has the right data and behavior but the wrong interface. An adaptor object then wraps the object to provide the correct interface.In this scenario, the BubbleSorter class just requires different implementations for the outOfOrder and swap methods depending on the type of objects stored in the array. The BubbleSorter interface just requires concrete implementation details for these two methods and not any sort of interface adaptor.",The Abstract Factory Pattern.,"In this scenario, the concrete version of the DocumentCreator are FancyDocumentCreator and ModernDocumentCreator. Both of them then create corresponding objects like fancyLetter and modernResume. If this were the Prototype Pattern, the fancyLetter and modernResume objects would need be cloned from FancyDocumentCreator and modernDocumentCreator and would contain all of the same methods and instance variables as the Creator objects.",Chain of Responsibility Pattern.,"The Adaptor Pattern is used when an object has the right data and behavior but the wrong interface. An adaptor object then wraps the object to provide the correct interface.Once again, this scenario does not require any wrapping of an interface. The Client delegates the Models and Elements responsibility to the Database. The Database delegates the Elements responsibility to the Model class.",Observer Pattern.,"The Abstract Factory Pattern is used to create families or sets of objects for clients. In this scenario, the word processor just needs ActionListener objects to subscribe to the keyboard input. When a command is pressed, the corresponding actionListener is pushed with the information and performs the action.","No, both the hours and minutes variables of this class can be set to integers outside the valid range for time. For example:Time t = new Time()t.setHour(132)t.setMinutes(85)Would result in a time of 132:85In addition, if the minutes is set between 0 - 9 it will appear malformed as x:5 instead of x:05 (x being the hour)","The class invariant (assuming 0-23 hours):The hour variable must be between 0 - 23.The minutes variable must be between 0 - 59.The minutes variable must contain two digits, e.g. 00,01, 02.",Array A and Array B must have the same length.,The header does not explain what will happen if either array A or array B is null.,Array B will contain the same integer values as Array A in the same order.,"The method would need to check if both arrays are the same length and throw and illegalArgumentException if there is a mismatch.Also, the method should check if either array A or array B is null and throw a NullPointerException.",The ShoppingCart should be responsible for deciding if two Items are the same.The expert pattern states that the object that contains the necessary data to perform a task should be the object that performs the task. Since the shopping cart contains all the items already in the cart it should be the one to compare existing items to any new items.,The clone() method has a return type of Object.o2 = o1.clone(); would result in o2 being only of type Object instead of MyClass. Any methods not found in the Object class will result in an exception.The correct way would be:o2 = (MyClass) o1.clone();,"Advantage: This is delegation, where Person ""has_a"" Location. Anytime the Location object is updated, all places containing a reference to that location will have the same data.Disadvantage: Trying to find all persons born at a specific location would require traversal of the entire collection of Person objects.","Advantage: Also delegation, where Location ""has_a"" Person. Will be able to quickly locate all people having a place of birth for a specific Location object.Disadvantage: Would require traversal of the entire collection of  Location objects to find the place of birth for a specific person.","Advantage: Allow for quick lookup of both People and their corresponding Location object. This also can be considered the Expert Pattern, since this object knows both People and Locations, it is the most suited for keeping track of the correlation between the two.Disadvantage: Adds additional complexity to the design by requiring a third object.","The Flyweight Pattern could be used to instantiate each money object. Each time a money object is created its reference would be hashed based on its value. Therefore, anytime a duplicate value is requested, the factory would be able to return the existing reference from the hash table instead of creating a new object.","The USMoney object has a constructor that has dollars and cents as the parameters. Therefore, another variation of the getAmount method:int getDollars() - return the number of dollarsint getCents() - return the number of centsAdvantage: This would allow for a client to just obtain the dollar amount or cent amount separately without requiring any computation.Disadvantage: A client try to get the full value may accidentally just call the getDollars() method and would receive the wrong total value.","Yes, it is needed.The getAmount() method would allow a client to receive the ""raw"" value of the object in the most elemental form (pennies). It would allow the client to perform computations on the exact value.Only allowing the getDollars() and getCents() methods would require the client to correctly add the two values together (total = m.getDollars() * 100 + getCents() ) and adds complexity.","The add and subtract methods simply take the two values and add and subtract them respectively.The multiply and divide take the value and either multiple or divide it by the given parameter. It wouldn't make much sense to multiply or divide one USMoney object by another. For example, what is use of performing $4 * $2 or $7 / $2.30?","One way to handle this problem would be to extend the Currency class by adding a getThirdForm() method. Each currency then can use this method to construct a new type of way to represent it.This new subclass does not violate LSP or the Open-Closed Principle, since it only adds additional functionality to the Currency class","When an object is first created, not all of the instance variables will be used right away. Therefore, by lazy initializing them will save memory and computation time spent setting up the variable. In some cases, the variable may not be used at all and does not need to be initialized.Lazy initialization is particularly useful for objects that are computationally expensive to initialize and are not frequently used by the object.","One of the major disadvantages of lazy initialization is that when a method calls the variable, it will have to stop and initialize the variable before being able the continue. If the object requires a lot of resources to initialize then the method will require much more time to complete then under normal conditions.",Any external methods using the public class variable will not be able to tell if has been initialized or not. If the variable is still null or invalid when the external method uses it will result in an unexpected null pointer exception or nondeterministic results.,"By requiring every implementation of the Collection interface to implement the get(int i) method is forcing them to have both a numbered order to all the elements as well as allow access in any arbitrary order.This violates the ""code to abstractions"" design principle, since get(int i) requires specific implementation details to ensure the method works.An implementing class such as a Stack is designed to be first in last out, if another class used its get method to obtain an arbitrary element, it would break the class invariant.",Observer: YouSubject: Executive,"Leave a message asking the executive to call you back when she is free.This closely mimics the observer pattern where the observer (you) subscribes to the subject (executive) for any changes the occur to the subjects state. In this case, the subject will inform the observer when her state has changed to being free.","The ActionListener interface uses the push model of communication. In this case, the ActionListener instance is registered to a JButton. Anytime the button is clicked, it passes that information to the ActionListener so it can perform an action.","In the case of syncing a clock on a client computer with a master clock on the server, the pull model would be better suited. The client clock does not require syncing information from the server until after a certain amount of time has passed (based on clock drift). It would then pull the syncing information as needed.SMS messaging on cell phones is a good example of needing the push model. The cell phone only requires updates once the server receives any messages sent specifically to that phone. Therefore, the server would push any newly received messages to the corresponding cell phone."
,,,95,2,0,2,2,2,0,2,2,2,2,1,0,2,0,2,3,4,2,4,2,2,2,3,3,3,3,3,4,2,2,4,3,2,3,6,2,4,4,4
,,,,Strategy pattern,template pattern,composite pattern,adapter,singleton,bridge pattern,memento,Iterator pattern,This is not adapter pattern because here sort method does not care about the objects stored in the array so it need not convert objects from one type to other(target or required type). There is no interface or a class that does the adapting job like making an interface look like what it wanted to look like.,Abstract Factory,"Prototype is used when we want the type of objects to create is determined by a prototypical instance and we do not have a way or an efficient way of creating such objects,so we clone then. But here we know that we are creating a family of related products like Resume, Letter etc.",Chain of Responsibility,"Here our task is to get information from the Element. But we don't know the target interface to design, we should build one. In Adapter we usually have a design to adapt to.Here to perform the task a set handlers or classes like Database, Model, Element do some work and delegate the rest of the responsibility to the other class. But in adapter we try to adapt one interface or class to look like another or make it compatible with other which is not the case here.",State pattern,Abstract Factory is a creational pattern but here we are not creating any objects. Here in the word procerssoor based on the current state on performing some operation we get some result like only when already a find dialog box is not already open it would be opened on pressing cntl+F. So by current state the next operation is decided which is behavioral and not creational in nature. In abstract factory we create objects of similar family which is not the case here.,The class is not well formed because the objects of the class cannot display valid 24 hour clock time. There is not method which displays the entire time like hours:minutes format all we currently has individual methods which display minutes and hours separately.So we either need to add a method like toString ot getTime.,hour should be in between 0 and 23i.e hour >=0 && hour <= 23minutes should be in between 00 and 59minutes >=00 && minutes <=59,array size of A and B are equalA.length()==B.length(),"if the pre conditions are not program might get crashed because we try to copy a big size A to small B or incompatible types of elements in the arrays.Another ambiguity is how many values to copy, because as array are declared at compiled time it not have used all of the elements so we try to access the non existant element in array application crashes.",Both arrays should have same elements in same orderold elements in array B are lost,we should check the size and type of arrays A and B. If B size is smaller or larger than that of A then the size of B should be made equal to A.We need to keep tack of count of elements in the array.,"Here Item class has entire data about the item and ShoppingCart class manages that data like adding an item, deleting etc so by the principle of Encapsulation and Expert pattern its the resposibility of ShoppingCart to check whether two Items are the same.",This example is wrong because the intent for cloning an object is wrong. In prototype pattern we clone an object if the cost of creating a new object is large and creation is resource intensive and when the type of objects to create is determined by a prototypical instance.But the intent of cloning an object here in the example is to allocate different memories to each object rather than pointing to same memory location and use the cloned object later which is not the intention of actual prototype pattern.,Advantages: Memory allocation and the declarations are simple.It is better because people objects are more often created than location objects so when a person is born we can create a location object as well and maintain its reference here.Here the event caused would be birth of person i.e when a person is born people object is created and if location object is not already present it is created. It is push based model. Light weight objects.Disadvantages: Cannot get things like all people born at that location for that we need to traverse over all the objects to find it.,Advantages: It is a good way to represent because we perform functions like getPersonsByLocation so in one step we can retrieve all the people.  Disadvantages:Now as each location need to store lot of people objects it needs to be stored in a collection.Each location object is now heavy(occupies more memory).Cannot find objects by person.,"Advantage:In one operation we can find place of a person, all persons belonging to a location etc.Disadvantages:We have to create another class just for the sake of one functionality.Objects of this types are heavy weight and very difficult to maintain as no of people and locations increases.","Declare and private class reference dollarOne(like USMoney dollarOne) and create a public static method getInstance(long cents) which check whether an object already exists for that currency if yes return that object, if no then create an object and return it. So client needs to invoke USMoney.getIstance(cents) to create a money object. Constructor should be made private. By this only of object of each amount exists and can be re used. This is singleton pattern.",There can be additional variations on the getAmount method like returning the amount in decimal format( like with an implied decimal point between dollars and cents) rather than just cents because it would be more readable and easy to understand and also we can represent a large no of dollar which is not possible if only cents are displayed. Disadvantage would be the precision after the decimal it should be only 2 digits after the decimal or else clients might get confused.Another way is to return an array of 2 integers with 1 st element as number of dollar and second one as cents.Advantage is easy representation and easy to understand to the user.Disadvantage user might get confused which one is dollar and which one is a cent.,yes getAmount is useful.It is the only way to access(read) the amount. Suppose if we add to USMoney objects using a.plus(USMoney b)now in the implementation to get amount of b's object b.getAmount is the only way.,As we will have round-off issues when we multiply or divide double values.And it also does not make sense like multiplying one money object with other as we normally multiply by a factor.,"In that case we could adapter pattern which coverts the standard form of the currency class to the desired way the user needs.A class is created which takes input as the value returned by the Currency class and converts it to target form i.e appending the symbol at the end instead of the starting of the number or replace the period with the ',' as required by the user and return it.This is more elegant way because we are maintaining open-closed principle.","Lazy initialization in the control block means that the Singleton instance is initialized, or created, only on the first call to the Instance() method.the initialization of the instance variable would take a long time, or consume a significant amount of resources One good example is to not create a database connection up front, but only just before you need to get data from the database.The key reason for doing this is that (often) you can avoid creating the object completely if you never need it.","But, for multithreaded applications, this approach proves to have a potentially hazardous side effect. If two threads manage to enter the control block at the same time, two instances of the member variable could be created. Code needed to check to see if it is time to initialize the value each time it is used.Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.","publicly available instance variables can be accessed by anyone as there is no restriction like private variables which can to accessed only from methods, so when any one access they might get null exception if not already created and lazily initialized.","This works for only collections which are directly accessible such as ArrayList etc but it would not work some complex collections like HashTable, Tree, LinkedList etc because there is not direct means to access them. When some structures like trees and hash tables which does not define what is i'th element cannot retrieve the data for them. Instead an iterator traverses sequetionly to achive the traversing over complex structures.",Observer is me(person trying to meet executive)Publisher is the executive.,Leave a message asking the executive to call you back when she is free.because leaving a message is like registering an observer to an event and call you back when she is free is like notifying the event when it occurs to the observer( in this case executive call back me).,It uses push model because when an event occurs i.e a click on JButton it notifies its subcribers by actionPerformed.,In push based model the Subject should notify all its Observers when an desired event occurs.Ex: When a post is posted it is notified to all its subscribers.In pull based model the Observer should constantly request for the data change in the Subject.Ex: Users constantly seeing if new post is being posted.
,,,100,2,1,2,2,1,2,2,0,2,2,1,0,2,0,2,3,4,2,4,2,2,5,4,3,3,3,3,4,2,2,4,3,3,3,6,2,4,4,4
,,,,Strategy pattern,Decorator,Composite,Adapter,Singelton,Bridge,Builder,This is template pattern as it defines the skeleton of the BubbleSorter and defers some steps to the subclass. It lets the subclasses redefine certain steps of the algorithm,It is not an adapter as no existing interface is used. No incompatible interfaces have been brought to work together. Just that Principle of Encapsulation followed with the use of Template method. The methods outOfOrder and sort are in the base class and subclass gives it defination.,"Factory Pattern as it gives a simple abstracts for letters and resumes but lets the subclass decide which class to instantiate. Thus, it lets a class defer instantiation to a letter or resume of a document type to be created to sub class.","Prototype is used when class for the object is not known untill runtime. This is when cloning of the instance of a class is done to have a prototype. But, in the above example , this is not the case as the client is aware of the casses Letter and Resume which are being used.",This is Chain of Responsibility where the request is examined and handled by that class or passed on to the other class.,It is not an adapter as no existing interface is used to remove incompatible interfaces. Just that Principle of Encapsulation followed with the use of Template method. The methods outOfOrder and sort are in the base class and subclass gives it defination.,"It could be observer pattern that observes the state of the kep press and performs the task of display of dialog box accordingly. or This is the command pattern as different objects are responded to by different requests. hence, commands are followed as the key is pressed and the display is performed.","Abstract factory provides and interface for creating families of related objects without their concrete classes. In this, a initiation is furnished with response which is typical of observer i.e. publish-subscriber relationship.","No. The above class is not well formed. For a class to be well formed, there should be internal consistency that needs to be maintained. Here, the hour and minutes are instance variables which are used in the getter and setter methods. Then for an object of class Time, there will be discrepancy in having correct 24 hour values if the values assigned to hour and minutes variables is randomly given. Thus, between calls to the set methods, the internal representation of the instances will not match with the constraint of having a valid 24 hour clock.","The statement of comparison of,0&lt;the sum of [(value of hour) and (value of minutes)/60]&lt;=24 is an example of a class invariant.This checks that the calls to mutate the object instances between calls to methods, do not change the values of hours and minutes such that their sum in hours should be in the range of 1 and 24.","Array A and Array B both should be same length arrays.Array A should not be null as there will be no elements to be copied. Thus, we have,1)arrayA.length=arrayB.length2)arrayA.lenght&gt;03)Both should be arrays of type integer.4)","Yes. The method signature does not specify which array is to be copied into which array. Thus what are the source and destination arrays is not clear. Also are references copied or values is also not clear. Also, after the copy is done, there is no way the user can be notified as there is no notification taking place.",The elements in array A are copied into array B.The order of copying remain same.,"In current case,to improve,The source and destination arrays should be of any type and type checking should be done in the method and then folllowed up.The length could be different and thus, we havepublic void copyArray(int[] A) { ... }where, the array to be copied into should be defined inside the method. Thus, no concern of length and type of array of B.","A third class should be given the responsibility to check whether the items are already in the cart or not. This is because the class item as well as shoppingCart should follow the principle of 'Singular Responsibility' and ' Do one thing and do it well'. Also, the new function of comparision to the already present elements in the Array List should be encapsulated else where.","Firstly, we would have MyClass implement the Cloneable interface and then have the following:public Object clone(){try {return super.clone();} catch (CloneNotSupportedException e) {assert false; //this code block should never executereturn null;}}Then we can follow it by having in a method in MyClass: MyClass o1;o1=new MyClass();//.. Some processingMyClass o2 = (MyClass) o1.clone();o1=null;o2.anymethod();","The advantage is that it would be easy to access the information with the Person object. This is because, it would only have to use accessor method to actually get or update the value of the location where he was born. Disadvantage would be violation of 'singular responsibility' principle i.e. person will have to keep track of its birth location which is dual work for it. But, this would mean duplication of data as all the people born in the same location will each keep the location variable i.e. same information is maintained by multitude of people which is unnecessary.","Advantage is that the location data will not be repeated and hence only one copy of location for one place of birth will be required to be kept. But, disadvantage would be violation of 'singular responsibility' principle i.e. location will have to keep track of the people which is dual work for it. Also, for querying the birth place of a person with the person's name , all the collections will have to be traversed to find the location which is not recommended.","This would be of advantage to map the location to the person easily. Thus access to information is made easy.This would also mean singular responsibility i.e. doing one thing and doing it well.But, will have an overhead of maintaing a third object in a tabular structure.",Singelton pattern could be used for the constant 1$ or static private could be used for defining constantor a constant could be defined in the interface with a static final in the interface with which all the objects could access the same constant 1$ of type currency.,"Yes,Floating-point number: with advantage of penny not lost in the process i.e. precision but disadvantage of not complying to all kinds of currency.  Two integers, one for dollars and one for cents , again not complying to all kinds of currency.Currency can be returned as but will not give a value that could be compared directly.","yes. It will be used to get the value of money in a uniform cents manner rather than dollar and cents so that when comparing with other currencies later,everything can be compared in cents.If currency class is used this is not required.","This is because, addition and substraction require Us money objects as they give money object in return i=of incrementation or decrement. But * or / give a denomination change in terms of franction which cannot be handled","!)Overriding the method in the subclass could be an option but may become inelegant if some other class sub classes it and hence will violate the Principle of Least Astonishment and also it is not a good practice to override the superclass functionality already present. 2)So an elegant way would be to delegate the task of displaying to a third party where the conversion in the form required,such as using a comma instead of a period or putting the symbol at the end , could be accomplished. Thus, the existing display functions would transfer the task to the third party for this modification.3)Also, decorator pattern is an elegant way to implement this with a decorator used to attach the new functionality of responding to the new display of the object at run time.","The lazy initialization avoids the scenario where Singleton object takes a long time to create and hence does not give a long delay during the start up of an application.Lazy initialization also avoids use of a lot of memory for objects, by not creating it at all unless it is needed.Thus, the summary of advantages is as below:1)If you never use the value, you don't pay for it.2)Initialization costs can be more spread out by not initializing everything at once.3)In some cases, startup appears to be faster.4)Ability to delay until needed information is available.",The disadvantages of Lazy Initialization are as below:1)Code needed to check to see if it is time to initialize the value each time it is used.2)Time spent in the above code each time the value is used.3)Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.4)More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.,"It would be a waste of resources as every time a new instance is to be created, there will be need for checking if the instance is null or not. Thus , there will be waste of time. Also,checking unnecessarily will have an overhead on keeping track of the inputs to initialization that is not required.  There is rarely a justifiable reason for using lazy initialization. Not deciding where to initialize a variable correctly is more often a result of lazy design or lazy coding. The result can be many tests for null executing when you access your variables, and these null tests never go away: they are always performed, even after the variable has been initialized. In the worst case, this can impact performance badly with overhead of checking.","The problem here is that when different collections are required, every collection will be required to iterate over this loop to give elements of type Object. Also, we have to depend upon concrete interface of a method. The collections of various types will have to convert their type explicitly to an Object type for this to work which is an overhead. Iterators on the other hand, provide a uniform way to access sequentially the elements in a collection regardless of the structure of the collection. That is, it allowsaccess to the collection?s elements without exposing the representation of thecollection. A client who is using a collection class need only know that the classimplements the Collection interface. It allows several traversals at the same time and 'Seperation of concerns ' is followed with traversing being different functionality.",Observer: YouSubject: Executive,"Leave a message i.e. subscribe asking the executive to call you i.e. publish back when she is free.This is observer pattern where you(Observer) subscribes to the executive(Subject) which publishes to the observer when it's state changes to free. Thus, when executive changes state to free, the observer is notified by the subscriber.","Yes,the ActionListener interface uses the pus model because all useful information is passed as a parameter to update, whether the Observer needs that information or not. and is used extensively in the Java libraries in the form of various kinds of Listeners.","Instead of the Subject pushing what has changed to all Observers, each Observer is responsible for pulling its particular window of interest? from the Subject in push model. The push model compromises reuse, while the pull model is less efficient.If you want to give arguments, push is used. If not then the observer has to pull the data passed to it. Programs where there are a lot of objects of another class to be handled with similar requirements from functions, the push is better as it will as it is be pulled from the class otherwise when distinct functionality in programs is implemented, pull model is better."
,,,93,2,2,2,2,1,2,0,2,2,1,2,0,2,0,2,3,0,2,4,2,2,0,3,3,3,3,3,4,2,2,6,3,3,3,6,2,4,4,4
,,,,strategy,decorator,composite,proxy,singleton,bridge,prototype.,factory method,For adapter wrapper and one more class should be ther which have common interface. which is not mentioned here.,factory method. As it creates and returns different objects depending on the subclasses.,Its not prototype because in prototype pattern we have to clone the object and return them where we dont know the class of the object we want to create. There is no clone method required in this situation.,Mediator,Adapter requires wrapper class which has same interface as the given class. But here no such interface and wrapper class is mentioned.,This is state pattern as it checks current state of the window. Also it can be command pattern as i accepts commands and perform different operations,For abstract factory family of related or dependent objects is created without specifying their concrete classes. Here there are no family or related objects are created.,"Yes, this class is well formed class. As method names are clearly written and reveal what their functionality is. Also each method is doing only one thing.","public class Time {  	int hour;  	int minutes;  	  	public Time() {  	}         public Time( int hour, int minute){          this.hour=hour; this.minute=minute;         }   	public int getHour() { return hour; }  	public void setHour(int hour) { this.hour = hour; }   	public int getMinutes() { return minutes; }  	public void setMinutes(int minutes) { this.minutes = minutes; }}",length of array A and array B should be same and greater than 0.len(a)==len(b)>0,No there is no ambiguity in the behavior of this method.,all values in A are equal to all values in BA[i]==B[i],we can create and assign new array to B i.e. B will point to new memory location with memory equal to A. And then copy values in B from A. and then return the B value. So it does not matter on length of B. At the end B will have same length and values as that of A.,"It will be Item class's responsibility. As we have to compare two items, it should be Item class method which will return true or false by comparing two items. Shopping cart class functionality is to just update items in it. It should not bother about comparing Items. If we add some new  items or anythig else, then againg we have to rewrite function for comparing in shopping cart which is not good design.","1. When you set o1 as null, o2 is still pointing to the same memory location. Hence it can access the method.2. clone() function uses shallow copy. 3. In prototype pattern we don't know the class of object we are cloning. Hence we cannot typecast it. Function from a class only can do clone and return proper object to user.",Advantages: This make sense as each person has its birth location. So we can include its object in person class. If we want location for any particular person we could easily get that form that person object.Also we can use same object of location for different persons if their birth location is same.It will not require extra space also.Disadvantages:,"Disadvantages: For a given task of keeping track of place of birth of each person, this design is not suitable. As to find a location of person we have to go through all locations till we find specific person.Hence this method is not suitable.",Advantages: This type of design is suitable for database like of operations. It will be much faster to retrieve which person belongs to which location.Disadvantage: It will take unnecessary lot amount of memory as extra object per person is created. Hence it will take extra space.,"It can be done using similar to singleton pattern implementation. In this case USMoney will have USMoney objects for each denomination and will return particular instance upon request. So if user asks for $1 then it will check that $1 instance is already created or not. If its not created then it will create a new instance set its amount and return that instance. If instance is already there it will return the same.class USMoney {long amount;USMoney one,five,ten,hundred;private USMoney(long value){ amount = value}public USMoney getDollar(long value){if(value==1)if(one==NULL)return one=new USMoney(value);return one;}//similar code for two five, ten and hundred.}",No. this function is hardly used anywhere as other functions are available to perform operations including display value. So variation is not required.,"We dont need getAmount method. As class contains method to print the amount also to add subtract multiply divide negate all functions that can performed on amount, we don't require getAmount method as we cannot do anything extra with that information. And for other, functions are provided in class",Add and subtract operations are done on two money values. Hence they require second USMoney object. While multiple and divide require only one money object and one number as user can send any double value he required not necessarily USMoney. He can multiply and divide money by number but not the money. Hence these functions accepts number that is double and not object of USMoney.,"we can use strategy pattern and delegate this display behavior to other class. We will have interface displaybehavior and subclasses depending on the format you require. Later we can include this display behavior in our extended currency class and set to specific format and can display currency in that format. If we want to change the format, we just have to set the object of displaybehavior to other subclass and display it. It can be done at runtime.","Lazy initialization allows user to initialize the object whenever it is needed. So it is helpful when the initialization of the instance variable require long time or consume a lot amount of memory or other resources and chances that variable will be used are less.Initialization cost can be more spread out if all initialization is not done at the same time.Process may start faster as initialization time is less.It delays until particular information is needed.Also in case of object initialization, it helps to initialize that particular class object only once as in case of singleton pattern.",The main disadvantage of lazy initialization is its needs to check every time whether this is the time to initialize the code or not. Hence the time penalty associated with each access is high.It has to store all information required for initialization till it is done. Hence its an overhead.Also initialization code is spread around the class which occurs at any time that can lead to confusion.,"If you make lazily initialized variables publicly available, it may lead to runtime errors and exceptions. User may try to access that variable before its initialization and get nullpointerexception  or any other initialization errors. Hence they need to private and initialized and accessed by class functions which know if that variable is initialized or not.",We are not using available code directly. We are violating DRY principle. We are doing the same thing as iterator do but we are writing extra code unnecessarily.,subject is executive as when it becomes free it notifies observer that it is free and now can pick up the phone.Observer is user who wants to contact.,"First one is most close to observer pattern.As executive is free, event occurs and observer is notified Hence user is notified and can talk to executive.In other two cases, when executive becomes free, it may not talk to user as it is not notified.",It uses push model. As it sends message to the object passed to addactionlistener method which is observer here and then observer have to execute actionperformed method. Hence when event occurs actionperformed method is called.,"If there are few subject and too many observers for those subjects, push model will be suitable. Then you just have to call update method on observers once event occurs.When there are lot of subjects and few observers, then pull model is well suitable as each observer can ask each subject for event occurred and get the updated value."
,,,84,2,2,2,0,1,2,1,0,2,1,2,1,2,0,2,1,0,2,2,2,2,2,4,2,2,2,3,4,2,2,7,3,3,3,6,2,1,4,3
,,,,"StrategyThe Strategy pattern is really about having a different implementation that accomplishes (basically) the same thing, so that one implementation can replace the other as the strategy requires. thus, different strategies may be followed to finally determine the area of the curve.","decoratorby adding extra headers and footers as desired, we are adding extra functionality.This is what the decorator does: Attach additional responsibilities to an object dynamically. This provides a flexiblealternative to subclassing for extending functionality.",compositethe composite pattern is used here as it treats the composite and single objects as the same. thus with the help of the composite we treat the containers and components in the same way.,adapteradapter pattern will be used to incorporate the routine into our program to make it compatible with your code.,flyweight,bridge,MementoA standard feature of an editor is the ability to undo the most recent changes that the user has made.by using undo and redo on the other brake we can figure out how to put the break back to how it was.,template pattern,"The adapter is a pattern in which the adapter converts the interface of a class into another interface clients expect. the bubble sorter has a fixed algorithm which it follows with a slight variations. although the last line of the description may seem to be hinting towards the adapter pattern, there is not transformation of interfaces here as such. hence it is not an adapter pattern.",Factory pattern,"The Prototype pattern is used when your system needs to createa new object. In the Prototype pattern, a prototypical instance of the class needs to be maintained, and when a new object of that class is needed, the prototypical instance is cloned. The instance to be cloned is known at runtime. In the above example, there no cloning that is required, instead a new letter or resume is created everytime it is requested.",Chain of responsibility,"an adapter is used to convert the existing interface of a class to the one that the client expects. here, there is no mention of the client desiring a particular format in which he wants to view the elements that he has retrieved.",State pattern,"in the above description, the result varies as per the given input. ?	The State pattern is about doing different things based on the input and the current state. the reason why this is not abstract factory because abstract factory is used when we need to provide an interface for creating families of related or dependent objects without specifying their concrete classes. here even though the result of a particular input needs one to output a particular thing that is required, there is no creation of a 'family"" of objects.","There should be maintainance of the internal consistency for well-formedness.The class should be in a well formed state when it is not in an executing state. thus to know wheteher the above class is well formed or not, we can implement class invariants after every modifier method. If the class satisfies the invariants, then it may said to be in a  well formed state.",public void setHour(int hour) { this.hour = hour; assert assert if (hour>=0 && hour <24) ;}public void setMinutes(int minutes) { this.minutes = minutes;assert assert if (minutes>=0 && minutes <60) ; },length of array B should be the same as length of array A,"error condition could occur when the length of B is greater than A, hence after copying there could be extra elements in array B apart from those of A. also if array B is smaller, then it may not be able to hold all the elements of A.Thus if and only iff the precondition is satisfied, there can be a guarantee to the post condition to be satisfied.in case of post condition, if the elements are not copied in the same order, then the arrays A and B may not  be the same",order of elements of B is the same as order of elements of Aprevious elements of B are lost,the change to be made is: the precondition that the length of A needs to be the same as length of B should be removed and checked after the copying is complete.,"1)The ShoppingCart class should have the responsibility of checking if the item is being claimed twice. The item class is responsible for maintaining information regarding the items and should not be levied by another responsibilty of checking for items.This is in accordance with the separation of responsibilty principle.2)Also if we make use of the observer pattern, we can have an observer check if the item is being claimed the second time.3)If we follow the Expert Pattern, we could have the Item class itselfmaintain this information as all the information related to the Items being claimed is in the Item class.","Prototype doesn?t require subclassing. It does its work by the help of delegation. it is not a creational patternThe Prototype pattern is useful in situations where your system needs to create a new object, but it does not know until runtime the class of the object it needs to create. In the Prototype pattern, a prototypical instance of the class is maintained, and, when a new object of that class is needed, the prototypical instanceis cloned. That is the main benefit of using the protype pattern i.e. you dont have to create a set of factory methods to create something. thus the reason why we wont get a nullpointerexception is because o2 will now be a clone of o1.","This approach suits the object oriented way of handling things. the person himself is responsible for things related to it.However,consider what happens when the program needs to make changes to the location of some particular persons.This can be inefficient as the whole list of person objects need to be traversed to check if they satisfy the given condition and then make changes to their locations",The location may keep a collection of references to persons. This may work fine if we want to change the location. But shouldn't person be knowing his own location? what if there are situations where we need to know the location of the person. one would expect it to be in the person object itself.,"This may be good in way where we want each class to be responsible for just one thing as per the separation of responsibility principle. But again, this may be disadvantageous because we will then be violating the expert pattern where if one class has all the necessary information to do a particular thing, then it should do the thing and not allow some third object to do it.",public class USMoney implements Comparable<USMoney>{public static final Dollar1 instance = new Dollar1();private Dollar1() { }public static Dollar1 instance() { return instance; }...other methods...},"the getAmount() returns the amount value in cents. This has been done for the sake of uniformity in calculations regarding the money amount. This method is basically used to get amount value which can then be used to perform various calculations on it. hence it is necessary that the amount be in a uniform format i.e. cents. Had this method been made for displaying purposes then it would make sense to make variations as suggested above. But even then, we already have a method  toString() to do that. then that would violate the separation of responsibilty principle.","the getAmount method is a getter method and hence necessary when other methods require to know the amount of money in a particular object so that further calculations could be performed.e.g. the plus(), mius(), compareTo() etc methods of other objects may make use of this getter method.","since the money is already represented in the form of <dollar>.<cents>, the addition and subtraction methods maintain the consistency of the value in the given format. Had it been in double, which has more than 2 nos. after the decimal point this would cause huge variations in the calculations as even a difference of value in decimal points makes huge difference while dealing with money. Hence, rounding off is also a bad idea. As for multiplication and division, the values need to be rounded off as they are in doubles. this is not good for the reason discussed above. hence we return the results of these two operations in arrays to make up for all the lost cents as the array records all the cents after the decimal.","there should be an object responsible for knowing this kind of information of placement of the symbols(front/back) or use of (./,)we can use the same Currency class, each instance of which represents a different currency that knows the necessary information for that currency.The Currency class could have info regarding with exactly the desired behavior. By using this Currency class, we could write the the toString() method and also, more importantly, we should try to avoid the conditional methods that will be there in such a case for the display of the currency i.e. whether to put the symbol at the end or front. these change could abstracted by making the Money class an abstract class. the toString() could be an abstract method in this. while others can be implemented in the abstract class itself as they do not vary due the their representation.public abstract class USMoney implements Comparable<USMoney>{public USMoney(int dollars, int cents) {..}public USMoney(long cents){..}public long getAmount(){ .. }public abstract String toString()public int compareTo(USMoney o){..}public boolean equals(Object o){..}public int hashCode()public USMoney plus(USMoney m)public USMoney minus(USMoney m)public USMoney times(double factor)public USMoney dividedBy(double divisor)public USMoney negate()}","Advantage: it ensure that only one instance is created at a time.if the Singleton object takes a long time to create andyou don?t want a long delay during the start up of your application. Or suppose theobject uses a lot of memory, and so you don?t want to create it at all unless it is needed.In these cases, we could take a third approach called lazy instantiation.",it may take long to check whether an instance of the singleton is already present or not. and this needs to be done everytime a new instance is required.,instance variables that are initialized lazily should not be made public because at a time we want only one instance to be used. Also if it is made publicly available then more than one thread may execute it  at the same time.  there is the possibility that each thread would think that the instance is null and so create two instances.,"In case the user decides to use a different collection, there would be a lot of hassle to modify every iteration over the collection to use a new loop construct. also,by using this alternative the client knows the details about the implementation when he only needs to traverse the collection.The user need not know what kind of Collection is returned.",executive: subjectme: observer,"the third choice most closely relates to the Observer patternThe Observer pattern can be defined as a pattern in which we allow an object to notify other dependent objects when it changes its state, so that the dependent objects can appropriately update theirstate.Here the subject is the executive. by leaving a message we are subscribing to her and by asking her to call back we are asking us to notify when she changes her state( i.e. when she is not busy)","A listener subsrcibes to the mouse or other click eventsthat occur in a button subcribes to the button. when the userclicks in the button, the notification is sent to the actionlistener. Hence here, the subject i.e. the button notifies the the subscriber. Hence this is a push model","PUSH model: Some auctions demonstrate this pattern. Each bidder possesses a numbered paddle that is used to indicate a bid. The auctioneer starts the bidding, and ?observes? when a paddle is raised to accept the bid. The acceptance of the bid changes the bid price which is broadcast to all of the bidders in the form of a new bid.here the bidders are the subjectsthe person who conducts the bidding is the observer. the polls need to be pushed to that person in such a case."
,,,95.5,2,2,2,2,2,2,2,2,2,1,2,0,2,0,2,0,4,2,4,2,2,2,3,3,3,3,3,4,2,2,7,2,1.5,3,6,2,4,4,2
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy pattern,Decorator pattern,Composite pattern,Adapter pattern,Flyweight pattern,Bridge pattern,Prototype pattern,Template Method pattern,"Adapter pattern is used to match an existing interface to a required interface.It provides a wrapper round the existing interface so as to present it as the required interface.In the question the problem we are trying to solve is ""how to provide the generic sorting algorithm and to make it independent of the input type and array(or link list).""To do this we are implementing sort in abstract base class BubbleSorter which uses abstract functions "" outOfOrder and swap"" . These can then be implemented in the subclasses based on requirements.Hence I know we are not using adapter pattern because1) we are using inheritance instead of delegation(used in adapter)2)The sort() function will be calling abstract functions implemented in subclass whereas adapter uses concrete functions which call functions on object it wraps3)The functionality in the question cannot be provided by using adapter",Abstract factory pattern,"Prototype pattern uses an object to create another object of the same type(using clone).In the question DocumentCreator is abstract base class which will create objects of type Letter or Resume.(based on the concrete implementation of DocumentCreator , call to createLetter() or createResume() returns concrete representation of Letter or Resume.",Chain of Responsibility pattern,"Adapter pattern is used to match an existing interface to a required interface.It provides a wrapper round the existing interface so as to present it as the required interface.In the question there is no need for an interface change, rather it requires that each level does its job of retreiving cetain info and passes the info to the next level.",Observer pattern,Abstract Factory pattern is a creator pattern that deals with how to create objects based on certain requirements.The question requires just that the subscriber (word processor) listen for certain special keystrokes on the editor(publisher),No this class is not well formed.Ideally the values of hour and minutes should have been checked for conditions (hours<24 and hours>=0) and (minutes>1 and minutes <=60) by the public methods setHour() and setMinutes() respectvely,private void satisfiesInvariants(){ if(hours>=24 || hours<0)   return false; if(minutes<0 || minutes>60)   return false;return true;},A!= null;B!=null;A.length == B.length,1)The method appears to be a instance method of an unknown class. It should be a static functions so that it can be used as an utility function rather than creating object of the class2) There is no need for the lengths of the array to be same. It should be OK if A is larger than B,for(int i=0;i<a.length;i++) a[i] == b[i],The precondition should be evaluated in the caller (client) so that the data is guarenteed to be correct in the funcion.,A flyweight pattern can be used.public void AddItem(Item item) will check in _items if the given item is present or not by comparing the product id if present it update quantity else adds Item to arraylist,"Even in case 1 , it does not give an exception.Because in case 1 , o1 and o2 are references pointing to 1 memory locn. changing o1 to null delinks that memory reference , but o2 reference persists. Hence o2.anymethod() does not give NullPointerException",adv:each person has only 1 place of birth hence it can be stored by instance variable(not collection).This allows easy access to info.disadv:Ths person class is now responsible for storing the Location which is not its primary objective .Hence low cohesionThe person holds data for which it is not responsible(ie the location object,disdv:To access a persons location of birth we need to traverse the entire list of locations.This leads to high coupling,adv:A seperate class has the responsibility of maintaining the mapping between the 2 classes.This decouples the classes Person and LocationDisadv:Extra code will need to be done to maintain the mapping and its interfaces.,"(assuming we need the same functionality for every $ ie 2,3,4,5...)We could use a flyweight pattern.The USMoney class will have an internal HashMap which stores the USMoney objects hashed by the amount(key)The USMoney constructors will need to be private.A public method public USMoney getUSMoney(long cents ) will then replace the constructors for returning the USMoney obejct. It will  hash the amount to check if object is present .If not it will be created by calling constructor and new object will be hashed.",getAmount returns a float:adv :- there is no confusion regarding decimal point(for cents)disadv:- floating point num are approximations and hence may have more digits after decimalstruct type of a class with integer for dollar and cent advantage:This is a better representation then floats as cents is stored separately.disadvantage:There is a problem of carry when performing arithmetic.  operations on theses numbers.Hence additonal logic is required whenever they have to be used.,"Yes the getAmount method is required because there may be a need for converting USMoney object to base representation of a primitive type.Maybe required for some financial computations.MAybe required to change the representation to some other formatThis follows the guideline for minimum coupling ""Give complete interface"" .This helps in reuability.",Add and subtract always deals with money ie we will always add and subtract money in a financial transaction.For multiply and divide it never occurs that money is divided by money(ex we always do 8$/2 not $8/$2)However a divide and multiply for USMoney could be overloaded as functionality.,Use decorator pattern.Each wrapper would have function String toString(Money m)The wrappers would in following layers1) determine the letters in the currency code2)placement of the currency symbol3)Type of currency symbol.Every currency format would then have its own type of wrappers.,1)Space will be saved if the instance variables are huge objects.2)Time will be saved (better performace)if there is the chance that the instance variables may never be needed to initialize.3)It may be better if the objects point to resources.So the resources are bound to object only for the time it is in use rather than from time the object is created.,1)null checks. Whenever the object is being used a null check needs to be done. This is very hard to document as the variable may be used within the class itself without calling getter method.2)If the class is extended it becomes a problem for the subclass since it needs to know the internals of the parent class(if the variable is not private).3)A person may forget to add a null check(as in pt 1) which may pass in most circumstances(test cases) and fail at runtime during actual usage.,1)If lazily initialized instance variable is made public there is no means to check and insure that the variable has been initialized,Here the implementation of traversal moves from the Iterator to the client. Hence it cannot be optimized as collection internals are not known to client.Consider a link list. Whenever we do a get(i). The link list needs to be traversed from the beginning till the ith node. Hence lots of traversals are needed An iterator can internally store the node to which it currently is pointing. Henc it just returs the next node.The iterator has knowledge of the internal implementation of the particular collection and can use it to optimize the traversal.,Observer -> meSubject -> executive,Leave a message asking the executive to call you back when she is free.In observer pattern the Observer  registers with the Subject (Publisher). Whenever an event occurs the subject then sends message to the subject.,Push model: Here Jbutton is the Subjects and it gives info to its Observers when click occurs,Push model : It can be used when there are many observers waiting for the event to occur.It is not feasible for multiple subjects to be continuously polling an object for its state.Also it is used if the observer needs to be imediately updated by the subject on event.Pull model:It is used when the observer does not require that it may be immediately updated on the status of the subject.Also the observer may be single threade and does not want its computation to be stopped due to an incoming event. When the observer requires it will poll for the status of the subject.
,,,92.5,2,2,2,2,2,2,1,2,2,2,2,0,2,0,1,3,3,2,4,2,2,0,3,3,2,3,3,4,2,2,4,3,3,1.5,6,2,4,4,3
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy,Builder,Composite,Adapter,Flyweight,Abstract Factory,Prototype,Iterator,"It is not an Adapter because we are not adapting to an already existing interface. Here we are using some methods for different collections without bothering about the implementations, we are not adapting to any new class and hence it is not an adapter.",Abstract Factory,"It is not a prototype because we are deriving from a simple abstract class such as the Letter or Resume and we are not just creating copies of them. the FancyDocumentCreator or  ModernDocumentCreator do not just copy, they have their own implementations for the Letter or the Resume.",Template,"It is not an adapter because it is not adapting to any interface. It is just using and object got from one step in the next step, to call another method in the object. It does not adapt to any class.",Observer,We know that it is not abstract factory because we are not creating any family of products that are related to or are dependent on each other. We are just giving input and getting the related action for that input.,The class is not well formed. This is because it provides separate setter methods for the hour and minutes and there is no guarantee that both of them are maintained in sync as we could call each method individually and this could make the total time displayed wrong.if it is designed like this there might be a case where we might just set the hour and forget to set the minutes. Thus it is not a well formed class.,hour >= 0 && hour <= 24 &&  minutes >= 0 && minutes <= 59,The preconditions are that the length of the array B is equal to the length of the array A.,"The ambiguity in this method is that, when we copy the values of the array A into B, then the old values of B are lost. This method is not saving the values of B before it copies the new values.Another thing to be noticed is that we should make sure that the length of both the arrays are the same. When it would be fine if the size of B is greater than or equal to the size of A in order to copy the values of A into B.","The post conditions are that, the values in B should be similar to the values in A and they have to be present in the same order as they are in A.","The changes to be made are that,now we are assigning the responsibility of determining the length of the array B to the copyArray method. The method should first check the length of the array B and test if it is greater than or equal to the  length of the Array A. If it is not, then it should return an error.We should also change the postconditions:the post conditions would be, if length of B is greater than or equal to A, then the values in B should be the same as the ones in A and they should be in the same order.elseSome error.","The responsibility of the determining if two items have the same id can be given to the shopping cart class. Here, in the AddItem method, it could just use a method such as contains, and determine if the item is already in the cart and if it is it should just increment the number else add the item.But by doing this, we are adding giving additional responsibility to the Shopping cart class. Its main responsibility is to maintain the list of shopping items and it should do it well,thus we could have a third class which could be responsible for checking if the item is already in the cart and act accordingly. This design is pertaining to the principle of separation of Responsibility.","In the first example, o2 which is a reference variable of object is referring to an object of its subclass. And so when that object is made null, the reference o1 becomes null but o2 still points to that object as it is copied and thus it does not give a null pointer exception.Here when we use the o1.clone(), an object of type Object is returned. and o1 is of type MyClass. So we would have two different objects and it would not have an exception. Also the Myclass should implement the Cloneable interface in order to use the clone() method else it will throw an exception.","Each person object would have an instance of Location, this means that there is an increase in coupling between the two which is not desired. Also the person object is now given a new responsibility of keeping a location in addition to the information it already is responsible of maintaining.",If each Location keeps track of all the persons that were born in that place then it is a disadvantage as there might be a large number of people who were born in a particular place and thus the amount of data associated with each object is huge. Also we need to decide a perfect collection that would be suitable to store these values. The Location object is given an additional responsibility of keeping track of all the people  born in that place in addition to keeping the location information.,The use of a third object to keep track of the person and his associated location object is better because it follows the principle of separation of responsibility. And thus now both these methods can use this object whenever they need the related information.,"We could maintain a collection of references to USMoney objects created so far and check in that collection and use the getAmount method. If a reference already exists we will use it, else we create a new object.",We could have separate functions that return the amount in dollars and the amount in cents. We can later on combine them as required for our computations. This would be beneficial as we do not need to perform any computation to split up the dollars and the cents.We could have a function that would return the whole amount as a floating point digit that represents the value. The advantage is we could use this value directly and we can represent a very large range of values. Disadvantage is that we do not know how any digits after the decimal should we represent. And also when we subtract two big values then the accuracy is reduced,Yes we need a get amount method in the Class. This method would be used whenever we need to perform some computations on the objects of the class.,"In the real world, we always add some money or subtract some money. We never divide/multiply some money with some other money. If at all we do, we divide/multiply it with some positive or negative number. Thus representing this way is a good OO style.To avoid truncation errors.Also, When we do computations on the USMoney objects, we designed it such that the results could be saved in a long variable. While adding, the result would use the same amount of bits as the operands. But when we are multiplying or diving, the number of bits would vary and using double is the best option.",We can handle these currency specific differences by using a decorator for our money class. The money class could provide the basic form of the value that has to be represented and depending on the need we could have several concrete classes that would implement the decorator interface and each could deal with a specific way of displaying the money. Thus we would be using the decorator pattern here.,"The advantages of lazy initialization is that we would save memory and time for the creation of the object. It is not always sure that we would be using the object that is created. So it is better to create the object when it is first used.Initialization costs can be more spread out by not initializing everything at once.In some cases, startup appears to be faster.Ability to delay until needed information is available.","The main disadvantage of lazy initialization is the time penalty associated with each access of the variable caused by the #isNil test. Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.","We do not want instance variables that are available publicly to be instantiated lazily because, they can be accessed directly so they can bypass the code that will be used to initialize them, thus causing errors.","This design is wrong in the sense that, though we have a method get(i) that is implemented in each collection, while getting the information for any collection we have to know the size of the collection. In order to get the size of the collection, in this example, we are using C.size(). If it is an array we have to use C.length and if it is a linkedlist we should use some pointer while(n!=null). So even if we have a general get method for all the collections, we need to iterate using the collection specific way and thus this design loses the complete essence of the Iterator Pattern and so it is wrong.",Here the person who is calling is the observer and the executive is the subject,"The third choice most closely corresponds to the Observer pattern. Here by leaving a message to the executive to call us back when she is free, we are registering with the Executive and thus are now in the list of Subscribers for the Executive. They executive will call us when she is free. So she will notify its subscribers when ever she is free.",The Actionlistener uses the push model for the communication. Here the listeners register with the button by using the addactionListener and they implement the actionListener interface. so whenever the button is clicked it call the action performed. So the button is informing the listeners and so it is the pull model,"In a scenario where the listener is making continuous changes to the subject, it would be appropriate to use the push model becuse, it would be more efficient for the observer to poll the subject after all the changes are made rather than polling it after every change. In other cases, the observer might forget to poll the subject and thus it is better for the subject to notify the observer whenever it changes state. Thus the pull model is better."
,,,90,2,0,2,2,2,0,1,0,2,2,2,0,2,0,2,3,3,2,4,2,2,0,4,2,2,2,3,4,2,2,7,3,3,2,6,2,4,4,3
,,,,Strategy Pattern - area() being the common interface and different functions being the classes required for the area().,Template Method Pattern,Composite Pattern,Adapter Pattern,Flyweight Pattern,Bridge Pattern,Memento Pattern,This is the Template Method pattern.,"This above pattern is not an Adapter pattern because Adapter basically deals with converting an interface of a class to another interface which the clients using the class normally expect. It lets classes work together because of the incompatible interfaces. In this example, we are not providing any separate interface to the client - also client does not expect any particular interface! He can just call sort!",This pattern is the Abstract Factory Pattern.,"It is not a Prototype because the definition mentions that the client is aware of the fact that each of the documents are derived from simple abstract classes - Letter or Resume! In the prototype pattern, client is not aware of the type or which specific class is being instantiated.",This is the Composite Pattern.,"The definition suggests that the client uses the standard interface of the connection to get the database. Further, the reference of database gives the client the model and so on till the Element. Thus, no where has the Client asked for a interface much different that the one provided.",This is the State Pattern.,Abstract Factory provides an abstract interface to instantiate objects of specific type. Here we have different actions to be provided on different actions on only one class i.e. keyboard.,No.The class definition makes no effort to check whether the values provided for setting hours and minutes are within the boundaries of what is allowed. Hours should be 0 <= Hour <= 23 and Minutes should be 0<= Minutes <=59. This is assuming Hour and Minute never hit 24 and 60 respectively but reset to 0.The constructor should accept values in the above ranges to set the initial time. The constructor is incomplete if we need controlled or well-formed class.,0 <= hour <= 230 <= minutes <= 59,Pre-conditions for this method are:a. the length of both the arrays should be sameb. both the arrays should be integer arrays,It does not specify what might happen if the arrays are different in length.  It also does not specify what happens to the array A after the copy.,Post-conditions are:a. B will contain the values of Ab. B's old state or values are lost.,length of the array positions to be copied should be specified. OR length of the smallest array should be taken into consideration.Generic method can be written to just accept arrays of any type.,"The Item class should have the responsibility of deciding whether the item provided and itself are same or not. This is just as the 'equals()' method in all of Java's classes.If we provide the equals method in ShoppingCart Class it voilates the Single Responsibility Principle. Since, the equals method we write in shopping cart will be for the Concrete class Item, what if the inventory is updated with another Concrete class called 'SpecialItem' - this will force us to modify that equals() code to accommodate the new class. As the principle says - A class should have only one reason to change. Thus, we keep the equals method in the Item class.Moreover, if we write the equals method in the ShoppingCart, we risk showing off how the Items are compared and thus provide the implementation details of our Items class.","The clone() method normally results in a shallow copy. Furthermore, the clone method returns an Object type reference which has to be explicitly cast back into the appropriate type.","Advantages:The prime advantage of this approach is that the information is tightly encapsulated within the Person object. Thus, we as system designers just have to access one Object i.e Person to get all the information about him.Since the location of birth is an information about the Person and defines the Person, it has a has-a relationship which is consistent with this design.Disadvantages:Repetition of information in multiple Person objects born at the same place. For example, Me and my sister are born in the same city which means that our Objects have the same Location Object. 'Same' means in respect of data - as Location Objects they are both private to my Object and her Object respectively.","The advantage of this option is that there will be fixed number of Location Objects present. For example, Suppose Country X has hypothetically 10 places or Locations then our system will have only 10 Location objects in the system. There is thus no repetition of information in this case.The Person object is created for each individual and thus they will grow as number of People increase. But the number of locations remain the same.Furthermore, it will be easy to find the corresponding location object for instantiating the information about any person due to limited number of Locations.Following one location reference leads us to a list of People who were born in that location which is very efficient for demographics.Disadvantages:Just as it is easy to get all the People who were born at one location, it would be really inefficient to get the information about the birthplace of a Person - if we have information about only that Person! There is no way provided for us to find the location if we have the reference to the Person object.",Advantage:The advantage here would be that we have a central index 'possibly' keyed by the Person's name which can efficiently let us access to the Person fast enough.The third Object would provide a consistent interface to the Client for finding information about different People in general.Disadvantage:The size of the Table and thus the third Object will go through the roof - with the current population of the World. Maintaining such an object would be a matter of concern.The third object would also repeat information within itself by maintaining multiple location objects whose data is still the same just because they belong to a different Person.,IF we need only one object representing $1 - we can use the design pattern called Singleton.Singleton pattern makes the constructor private and declare a public interface which returns a new instance of the Class if and only if the value would be $1 and no other reference of the Class i.e. Object is created before.,"Maybe have a form which returns value as a decimal of the form Dollars.Cents!This can be useful when multiplying and dividing if we want to use USMoney objects for the same! But, the representation of cents which is the lowest generalized level is the most suited.",Yes. It should be used for getting the amount in the most general format which can be then manipulated to any format. i.e. Dollars - other currency etc.,"Because the USMoney class is framed that way  i.e. in Dollars and Cents. There is no way to get a proper value i.e. 3.14 to multiply another USMoney object by. getAmount converts to cents which will be much more and incompatible factor that what we had hope. Remember we want to multiply or divide by 3.14 and not 3.14*100 which is the output of getAmount!For add and subtract, we can easily do this by just adding or subtracting the cents and making a new USMoney Object by converting the cents to Dollars and Cents!Thus, we use doubles for Multiplication and division.","An elegant way would be to use Template Method Pattern to display the currency in different ways for each country. The idea lies in the fact that no matter what '3.14' is going to be '3.14'. This means that the logic for converting whatever value is passed to the '3.14' form, we use the same logic or the same method.Thus, for achieving different formats, we make the format method abstract and allow the subclasses i.e. Country-specific instances of the Currency class implement their own versions of the display method. We make the Currency class abstract too. Thus, in this abstract class we embed the logic and the display method in a final function which converts and displays the currency.Once, we inherit into country specific classes, we can call the standard method that we declared above and get the currency displayed in the appropriate format.","The advantage of lazy initialization is efficiency. We do not create and initialize an object or a reference until we need it. This saves us considerable computation time and space (if the initialization is expensive). Furthermore, if that object is not needed it is never created which is really efficient.For example, we should never create a database connection unless needed. Lazy initialization is thus particularly useful when we know that creation and initialization of the Object requires a lot of resources, a lot of time and if the Object has less probability of ever being used.",The prime disadvantage of lazy initialization is that the code to implement it becomes complex since we have to check if the object exists each time - if not create and initialize it.Complex code leads to problems in error reporting and debugging.Overhead of maintaining the input parameters for lazy initialization - which may not be needed after the initialization is also a problem.,"Publicly available variables are available to all! If they are not initialized as soon as the program or system starts and if they are referred before initialization, they can result is system failure and security concerns.","The iterators are more object-oriented and efficient way of accessing the data in any collection. In this particular design, we are assuming that the 'said' collection is ordered by index as we are providing a for loop for accessing each element. Furthermore, we also thus imply that all objects in the collection can also be obtained by the index given and that the index 'i' of the collection WILL ALWAYS start with ZERO.This assumption is sometimes wrong. Not all collections have indices starting from zero. There are a few collections in Java which won't be ordered with indices starting from zero. This can prove as a costly assumption.Iterators on the other hand have the principle of providing us with all the objects that are currently present in the collection which we can work with. This is very useful because there is also no fear of having the 'IndexOutOfBounds' Exception. They also have the hasNext() and Next() functions which internally take care of iterating through the collection - consistent with how the collection is ordered.","I am the Observer in this case and the Subject is the Executive as I am trying to call him for something and thus, he is the one providing the information to me.",The third choice!Since I called him and left a message - which is analogous to adding myself to his observer list - I am sure that he will call me back when he gets time or gets information ( in 'pattern' talk ),"For this scenario, it is the push model that is implemented.As mentioned, for one Button - addActionListener adds the listeners and registers them with the button. Thus, listeners are the observers which are registering themselves with the publisher i.e. JButton.Once, the action occurs, JButton iterates through the list of its observers i.e. the listeners and notifies them. Thus, it is a Publisher  -> Observers ( on Action ) - which is a push Model.","If there is a scenario where observers cannot have a high wait time OR where they wait only on the input from the publisher - pull model is the most efficient. Thus, whenever observer finishes its work, it polls the publisher for more data to work on.If there is a scenario where the only work performed or state change depends on the publisher i.e. for a display system which does not have its own logic but depends on the central processor to provide input and change its state - push model is much more efficient."
,,,102,2,1,2,2,2,2,2,2,2,2,2,0,2,0,1,3,4,2,4,2,2,3,2,3,3,3,3,4,2,2,7,3,3,3,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,"Strategy pattern. Each time you calculate the area of a region, you need to know what the function is that you are calculating the region underneath. For each of the type of function, the procedure to calculate the area is different.","Template pattern. The printTicket method() can be defined in the abstract class which calls addHeaders(), printTicketContent(), addFooters(). The addHeaders() and addFooters()  can be declared as abstract methods. The subclasses of the abstract class can be defined for each of the country and they implement the addHeaders(), and addFooters() as required.",Composite pattern. The container can be a simple component or a composite component which contains in it a simple or composite component.,Adapter pattern. An adapter can be written which will make the interface compatible with the client's program.,Flyweight pattern. All variables having the same value can point to the same String object in memory.,Bridge pattern. The bridge pattern is used to decouple an abstraction from its implementation so that the two can vary independently. Here we have various abstractions (the threads) and various implementations (for each OS).,"Memento pattern. When the second side is disassembled, the first side acts as the Memento.",This is the Template as the actual outOfOrder and swap tasks are delegated to the subclasses.,"The purpose of Adpater pattern is used to make two incompatible objects work together. e.g. The client uses the data in some form but to get the actual work done, the data needs to be in some other form. Here, there is no such case.","This pattern is AbstractFactory. Here, the DocumentCreator contains functions to create a family of documents which contain elements like letter, resume etc.","In Prototype pattern, the objects are created by cloning some default object. This is needed when, the cost of object creation using new method is high. In the above example, the objects are created depending upon the types of the Document. The objects are not cloned.",The pattern is Chain of Responsibility. The Database object is used to get the Model. Model object is used get the Element. Thus the responsibility of getting the Element is passed through different objects.,"The purpose of Adpater pattern is used to make two incompatible objects work together. e.g. The client uses the data in some form but to get the actual work done, the data needs to be in some other form. Here, there is no such case. The Database, Model and Elements need to be handled differently and need not be compatible.",The pattern is Singleton. Each of the different dialog boxes have just one instance at a time.,AbstractFactory pattern is used to create families of related or dependent objects without specifying their concrete classes. Here the different dialogue boxes can be considered as related objects but they are created independent of the family type (they don't belong to any family).,No. the constructor is empty. This should class should have a constructor which initializes the hour and minutes variables.,The class variant should be that the value of hour should be between 0 and 23 inclusive and the value of minutes should be between 0 and 59 inclusive.,The array A and array B should not be null. Lengths of array A and B must be the same.,"Yes. 1) If the array A is null or array B is null, then what should be the output is not specified in the requirements? e.g. Should it print a message or just do nothing etc. 2)  If the lengths of arrays A and B are not same, then what should be done? e.g if the length of array A is greater, then array B does not have enough space to contain the elements from A. In that case what should be done?",The values of array B should be in the same order as they were in the array A. The length of array B should be same as the length of array A.,The method should itself check for the preconditions and should handle the situation properly in case the preconditions are not satisfied.,"The ShoppingCart class should have the responsibility of deciding whether two Items are same or not. It can check in the CreateItem() method whether it's ArrayList contains an Item with the same product id and if it contains such an Item, then it can call the set_quantity() method on that object of Item to increment the quantity by 1.","The default implementation of clone method performs a shallow copy. The 'shallow copy' copies the references of the non-primitive variables from one object to other. So, when the object o1 is set to null, all the non-primitive variables in it are set to null i.e their references are set to null. The same references are used by the object o2. So. all the non-primitive variables are also set to null. To avoid this, the clone method should be overridden by the class MyClass.","Advantage: A Person's birth location information can be easily found out as the Person object contains a reference of the Location object. Disadvantage: If the Person residential address also needs to be stored, then the single location reference is not sufficient.","Advantage: It would be easy to find out all the Persons born at the same Location.Also, if a Person has two locations - one for place of birth and other for residential address, then subclasses can be created of Location for each type and then two objects can contain the same Person's object.Disadvantage: If the Person's birth location information is needed, then all the Location objects need to be searched to find out where the Person belongs.",Advantage: It becomes easier to maintain the code as third class has the responsibility of maintaining the mapping between Person and Location objects.Disadvantage: It leads to increase in coupling between the classes.,The USMoney class can be made Singleton as there is need to maintain only one object of such class throughout the system.,There may be a need to represent the amount in different forms. e.g. someone may need the amount in dollars and not cents in which case  the amount needs to presented in decimal form or it may be needed in different currency. But this conversion from cents to dollars or any other form should be done by some other class. The conversion responsibility should be given to some other class. Advantage: The USMoney class doesn't need to maintain code for different types conversions. Disadvantage: The other class need to know the internals of the USMoney class.,"Yes. As the USMoney is immutable, no one should be allowed to change its variables.  We cannot make the dollar and cents variable as public as then someone can change their value. But the amount should be accessible to other objects. For this, the getter method i.e getAmount() is used and there should be no setter method.","In the real world, one value of money is never multiplied or divided by the another value of money. Generally, two values of money are added or subtracted or the value of money can be multiplied and divided by numbers. Object oriented language's purpose is to maintain the objects just like the entities in the real world.",The Money class can be subclassed for each of the country. It will have different implementation for displaying the value of money. Strategy pattern can be used here.,"The advantage is that the lazy initialization saves memory until the singleton object is needed. Lazy initialization is particularly useful when the object takes a long time to construct. e.g heavy GUI components, the object consumes a significant amount of resources and there is a good chance the object will not be used.","Each time a variable is used, the time is spent in checking if the variable is initialized or not. There may be overhead for maintaining the inputs for the initialization that may not be needed after the initialization.More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.","If the variables are declared public, then they can be used prior to the initialization in which case the program may behave unexpectedly.","The iteration design pattern allows clients to iterate over the elements of a collection without knowing how the collection is implemented. In the above design, the client needs to know how the collection is implemented. Also, the client cannot run the two separate traversals at a time. Also, the collection needs to implement the get(int i) method.",The Observer is the executive. The Subject is the person who wants to reach the executive.,"The last one. In observer pattern, the publisher notifies the observer when some event happens. In the above example, the person who wants to reach the executive generates a message which the executive reads it and then take action (calling back). The person acts an publisher who publishes the message and the executive acts as subscriber who subscribes the messages.","The ActionListener interface uses both the push and pull model of communication. The ActionListener object doesn't poll the subject for the information every now and then. Instead, when an event happens, the JButton notifies the ActionListner of an event e.g. click on the button. So here push method is used. After that ActionListener uses the pull method to retrieve the information about the event e.g. event.getEventSource and then takes the appropriate action. Here, pull method is used.","Pull method can be used when there is need to retrieve a particular information and not the whole information and when it is needed. e.g while reading a file, the file can be read character by character or line by line depending upon the requirements. The reader pulls the data as required.The push can be used when there is need to supply the data as soon as it is generated. e.g. hardware interrupts."
,,,95,2,1,2,2,2,2,2,2,2,2,2,0,2,2,2,3,4,2,4,2,2,0,4,3,3,2,3,4,2,2,4,3,3,3,6,0,2,3,4
,,,,Strategy.,Template Method.,Composite.,Bridge.,Singleton.,Adapter.,Memento.,Template method pattern.,"Adapter design pattern is used when you want two different classes with incompatible interfaces to work together. Clearly, this is not the case. This is instead a case of redefining certain steps of an algorithm without letting them to change the algorithm's structure, which is what Template method pattern does.",Abstract factory pattern.,"Prototype pattern allows an object to create customized objects without knowing their class or any details of how to create them. In this case, clearly objects are created from various factory classes.",MVC pattern.,The above example clearly goes beyond adapter pattern which is used when you want two different classes with incompatible interfaces to work together. In the above there is clearly a  separation of responsibilities where the model contains the data and is not concerned with how it is displayed or with interactions with the user.,Factory method pattern.,"This is not an Abstract Factory since it provides an interface for creating families of related or dependent objects, in our case we're not defining an interface for families of objects.",No the class is not well formed. There is a scope for violations of certain invariants like setting the hour to any integer more than 24 and setting minutes to any integer more than 60. This clearly will not represent a valid time.,The number of minutes should be less than or equal to 60.The number of hours should be less than or equal to 24.,The array B must have the same length as array A.Both must be integer arrays.,"Instead of using A and B as mnemonics, could've used ""Copies the values of array passed as the 1st formal parameter (A) into array passed as the 2nd formal parameter (B) in the same order.""Does not specify what will happen if the arrays are of different length or if they are non-integers.",1. Copies the values of array A into array B in the same order.2. The old values in B are lost.,1. Use Object references instead of int.2. Handle the dissimilar size within the method by throwing an exception.,"ShoppingCart should have the responsibility of deciding whether two Items are the same, as the decision would involve the _items ArrayList field, which is a part of the ShoppingCart class. This will be in accordance to the Expert pattern, which states that the object that contains the necessary data to perform a task should be the object that manipulates the data. Thus ensuring elegance.","When you set the reference o1 to null, only the reference o1 is set to null and not o2, since o2 is a completely independent of o1 being a different reference. Thus o2.anymethod(); will not throw a NullPointerException.","This approach has the advantage that all the information of a person object is stored in the object itself (Expert pattern). Cohesion is maximised with respect to the person object. On the other hand, a small but tolerable disadvantage of this design is that a location object corresponding to a location will get created multiple times. However, if the location is stored as a string constant the complier will store it in the text section and this will no more be an overhead.","This approach minimises cohesion and increases coupling. There is no proper separation of responsibility. For example to get birth place of a person named ""Einstein"", you will have to traverse through the person collection of each location object, which clearly is not a good design.","This approach is slightly better than the 2nd approach but not the best. The advantage is that as compared to 1, less person objects will be created. However, to locate the birthplace of a person, you will again have to search the table with the person key.",Subclassing and then using a singleton pattern.,"Though the getAmount method can return amount in various other forms, but that will come at a cost of introducing a non-uniform interface. Since, other subclasses and classes using getAmount would already have been created keeping the cent value of amount in consideration. If conversions are needed, it could be the responsibility of a separate class that takes in amount in cents and returns the various formats required.","Yes, getAmount abstracts the way and the value we retrieve as the amount. It also encapsulates the amount which can be useful for validations etc.",This is done so that add and subtract are not type dependent. Hence same interface can be used if we later decide to modify the structure of USMoney objects.,"We can use the Template method pattern to implement the invariant parts of an algorithm once and leave it up to subclasses to implement the behavior that can vary, namely the display format of the currency.","1. If you never use the value, you don't pay for it.2. Initialization costs can be more spread out by not initializing everything at once.3. In some cases, startup appears to be faster.4. Ability to delay until needed information is available.",1. Code needed to check to see if it is time to initialize the value each time it is used.2. Time spent in the above code each time the value is used.3. Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.4. More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.,"There could chances of error due to exposing the instance variable publicly, as the initialization code  will be spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion. Also, to avoid a NullPointerException, a class must self-encapsulate fields that have lazy initialization. That is, a class cannot refer directly to such fields, but must access them through a method.",This design will only support indexed collections. It will not work with linked containers like LinkedList.,Observer: meSubject: executive,"Leave a message asking the executive to call you back when she is free. Since in an observer pattern, an object, called the subject, maintains a list of its dependent, called observers, and notifies them automatically of any state changes. This matches closely with an executive calling back people after reading the messages.","The ActionListener interface uses the push model. A listener that wants to subscribe to mouse-click events that occur in a button needs to implement this ActionListener interface and must register with the button through the button's addActionListener method. Then, when the user clicks in the button, the button's behavior is to generate an ActionEvent object that contains the details of the mouse click and then call the actionPerformed method of all listeners, passing them the ActionEvent as the argument. This is clearly the push mode of communication where no polling is required.","A pull method is better suited in a client server model like a web application where a server responds only when the client sends a request.A push method works better in a notification model, for example like automatically sending a registration email through the web app (using observers). In a notification model, the user expects notifications to be sent automatically based on the state of the objects."
,,,93,2,1,2,2,1,0,2,2,2,2,0,0,2,0,2,3,2,2,4,2,2,2,2,3,2,3,3,4,2,1,7,3,3,3,6,2,4,4,4
,,,,Strategy Pattern,Template Method.,Composite Pattern,Adapter Pattern,Singleton Pattern,Visitor Pattern,Memento Pattern,This is Template Pattern.,"This is Template pattern because there is a well defined sequence of operation to be performed for sorting which includes outOfOrder and swap methods. The BubbleSorter abstract class must look like this:public abstract class BubbleSorter{public void sort(){public boolean outOfOrder();public  void swap();}abstract public boolean outOfOrder();abstract public void swap();}Here, the class which will extend the BubbleSorter class needs to implement both outOfOrder and swap methods in a particular fashion in which swap succeeds outOfOrder.In case of Adapter Pattern, we need to define an implementation which handles the incompatibility issues between two interfaces which is different from the explanation given above.",This is Facade Pattern,"This is facade pattern because class DocumentCreator provides simplified interface to the client to create a number of documents without letting client to go into complexity of the subsystem to create documents. It helps in making the DocumentCreator system easy to use for clients. DocumentCreator class is responsible for creating a particular type of documents for a client.In Prototype pattern, the objects are created using prototypical instance and new objects are created by copying the created instance. In the above problem, the simplified interface is provided to user and no information about object creation is given.",It is Chain of Responsibility Pattern.,"This is not an Adapter Pattern because there is fine separation of responsibilities among the classes. The client class uses database to get model. Then it uses retrieved model to get an Element. And after getting element it, it retrieves information from that element. In case of adapter pattern, there is a common interface built that acts as a connector to available interfaces.",It is Command Pattern.,"This is not Abstract Factory Pattern because in this case, a command is given to Dialog Box creator class which interprets the command based on the input. In AbstractFactory pattern, we have ability to create objects of related families and not passing the command.","No. the class fails to implement encapsulation principle. According to encapsulation, the instance variable of class needs to be made private and getter and setter methods should be defined to prevent them from being modified from outside the class. In the above case, it is default access to instance variables, which makes other classes in same package the power to modify these variables. This can be protected by using",1) The value of hour must be between 0 and 23.2) The value of hour must not be negative.3) The value of minutes must be between 0 and 594) The value of minutes must not be negative.5) The value of minutes or hour can not be in fractions.,The precondition should be:1) Array A is not empty.2) Size of array B should be large enough to hold values of array A3) Both array A and B should not be NULL.,"Yes. The method name says copyArray(int[] A, int[]B) which means that the contents of array A will be copied to Array B but it is not mentioned that Contents of array B will be lost. In general reading of the name of method, it appears that contents of array B will remain and array A contents will be appended to array B. However, in the method description, it says that contents of array B will be lost. Thus, it violates the Principle of Least Astonishment.",Post conditions:1) All elements of array A are copied to array B.2) The new size of array B is same as size of array A.,We can check for the some conditions before we call the above method  The following checks can be made:1) Check for the size difference between array B and array A.2) Check if Array A is not empty.3) Check if both array A and B are not NULL.,"It should be ShoppingCart class which will compare whether two items are same or not .As per Design by Contract principle, it is the responsibility of ShoppingCart class to perform operation on item objects. Here Item class acts a a setter and getter for Items but the responsibility of operations on all items is delegated to ShoppingCart class.","This example is wrong because on assignment o1=null, only reference of o1 points to null. However, the reference o2 is still pointing to object created by o1 earlier. Thus, calling o2.anymethod() even when o2=o1 is used will not throw NullPointerException. This can be checked by following example:public class MyClass{	public void hello()	{		System.out.println(""hello"");			}	public static void main(String[] args)	{		MyClass o1, o2;		o1 = new MyClass();		// ... Do some processing		o2 = o1 ;		// ... Do some more processing.		o1 = null;		o2.hello();	}}This program will print ""hello"" even if o2=o1 is used.","Advantage: 1) Composition is preferred here. 2) Person object can reuse the same location object if one already exists. Disadvantages: 1) In case multiple persons are born at same place, we are duplicating the data for location variable.Instead we can use location collection that stores the person objects born at same location.","Advantages:1) In case of storing the person objects, we are reducing the number of  location variables. Here, one location variable will be storing multiple person objects.2) Will provide us the statistics like count of persons born at particular location.Disadvantages: 1) In case we need to find where a particular person was born, we need to iterate through all the location collections to find the collection where person is stored.","Advantages:1) Well defined way of storing data. 2) If implemented using HashMap, it will give us a fast method to find birth location for a person.Disadvantages:1) If we need to find out how many persons were born at particular location, we need to iterate through whole table to find the count.2) We need not create location object for each person. Rather we can have one location object for each location and use same object.",USMoney class should use Singleton pattern for Object representing $1. This way if an object exists for $1 it will be returned else a new object will be created for $1. The object for $1 needs to be lazy initialized in public static method so that other classes can call it to obtain that object.,"Alternative:1) The best is if we can change the return type of getAmount to USMoney which represents the object currently holding the value in dollar and cents format. Advantages:No need to worry about the calculation of Dollar to cents. We need to calculate cents and Dollar separately.Disadvantages:We need to take care of calculation if value of cents>100. 2) We can pass return double that represents the USMoney in decimal point format. Eg: 24.56Advantages:We need to use objects to store the return type.Also, the number of values increase as dollar and cent value is taken care of separately.Disadvantages:We need to take care of value after decimal point. Need to implement logic for restraining it to two decimal places after decimal point.",Yes. We need getAmount method. This method returns the value of current money in long format.This method can be used in compareTo method in which we accept USMoney Object. Calling getAmount on that object will return value in long format which can be used for comparing two objects.,"This is because while adding and subtracting we need to  take care of just the cent value going above 100 but in case of multiply and divide, it becomes cumbersome as the values can go very high(multiplication) or very low(division). If we implement multiplication and division using Objects, we need to handle complex operations for doing so.","To handle such cases, we can implement a Decorator pattern in which we can attach additional responsibilities to an object dynamically. It provides a flexible alternative to sub-classing for extending functionality. In this case, we can create a CurrencyDecorator which defines the two methods that already exist along with the new method to use comma in place of period.  This CurrencyDecorator will sub-class already existing Currency class.public CurrencyDecorator extends Currency{public String getCommaSymbol(){}}","1) Lazy Initialization is a performance optimization where you defer (potentially expensive) object creation until just before you actually need it.2) The key reason for doing this is that (often) you can avoid creating the object completely if you never need it.3) If you never use the value, you don't pay for it.4) Ability to delay until needed information is available.",1) Code needed to check to see if it is time to initialize the value each time it is used.2) Time spent in the above code each time the value is used.3) Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.4) More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.,"The access modifier of instance variable during lazy initialization are made private so that no one can access the variable from outside the class. If made public, anyone can set value for instance variable rather than initializing it in that class. This violated principle of Encapsulation.","The main disadvantage of this design is the implementation of traversal logic in each of the collection classes. In some of the collections like ArrayList, which is dependent on index of the elements, get(i) will work fine. But for other collections like LinkedList, the collection needs to iterate through all the elements to get i-th element. It will introduce same iteration in each of Collection class. This violated DRY principle.If we implement iterator objects for each type of collection, they can be reused using Composition with similar type of collections. We can define iterator class for particular type of collection and then let other classes of similar type to use the same iterator by passing the object of the class to iterate over.  But using above approach we need to implement get() in each of the class.",Observer: UserSubject: Executive,"The third choice"" Leave a message asking the executive to call you back when she is free"" is the one that corresponds more closely to the Observer Pattern. This is because here user as an observer registers to the subject by leaving a message and asking executive to call back when free. So, whenever executive is free, he will call back all the people who left him the message of calling back.","It uses Push Model. This is because whenever there is a click, the JButton notifies all the listeners those who register with the button. As per the definition of Push Model, the subject passes the information to observer. Same is the case with JButton and listeners. Here Subject is JButton and listeners are observer.","Push Model: This model would be well suited where the subscribers register themselves to the subject and wait for subject to provide them only  updated information. This can happen in case when passing the information to observers incurs a huge cost like sending over the network. In such case, subject only sends the information if the information is updated. Example: Spacecraft sending information to all its listeners on earth. Here, whenever spacecraft records a new information, only then it needs to send information to stations registered with it.  Pull Model: This model is useful when the observers continuously monitor for updated information. A good example can be threads in Operating System. Threads wait for availability of lock on a particular resource and keeps checking it in a loop. Here, resource is subject which lets thread know its availability and thread is observer which continuously monitors if the resource is available for use or not. Thread checking for resource availability does not incur huge cost as it consumes very less OS time."
,,,89,2,1,2,2,1,0,2,2,2,1,1,0,1,0,2,2,4,2,4,2,2,0,2,3,3,3,3,4,2,2,4,3,3,2,6,2,4,4,4
,,,,strategy pattern because it can choose the particular algorithm from the family of algorithms.,Template pattern.,Composite pattern.,Adapter pattern.,Singleton pattern.,Bridge pattern,chain of responsibility,Factory method.,"It is not adapter because, because in adapter we delegate the functionality to a hidden class, also we are not writing any wrapper to the existing class.",Abstract Factory.,"Prototype pattern means every time we are creating the exact same object using clone.But here that is not the case, as the documents are derived from a simple abstract class.",chain of responsibility.,"In Adapter,there is already pre existing implementation, we are just writing a wrapper to use the existing implementation for other system.But the situation here is something like...The objects become parts of a chain and the request is sent from one object to another across the chain until one of the objects will handle it.",Mediator pattern.,"this is not a case of Abstract Factory, because there is no creation of one of multiple families of objects here. The present situation needs various dialog boxes to pop up when a particular key sequence is typed in and do what they need to do, Mediator suits the most because it manages communication between different classes in a complex system.","yes the above class is well formed because of the following 1. all the code is executed at the same level.2. the class is doing only one thing i.e. 24hr clock.3. it is using intention revealing names to variables,methods.getHour,setHour etc.",the class invariant for the above class1. hour should be in range of 1 ... 24.2. minutes should be in range of  0 ... 60.,1. the length of both the arrays should be same.,"There is ambiguity about the order of insertion of elements A in to B, it is specified as same order but that can draw many possibilities from left to right or the other way around.The order should be mentioned more clearly or explicitly.",The post conditions should be whether both the arrays are same.i.e.for(i in length)  if(A[i] == B[i]),we can add a boolean flag to the parameters of the method copyArray() which will state whether or not to proceed with the copying and the flag inturn is set by checking the length of both arrays.,"The Item class should have the responsibility of deciding whether two Items are the same, according to the design principle that a class should do one thing only. The shopping cart deals with billing and adding Items, also anyways the test of equality of items depends on productIds so it is a good way to have it in Item class.we can think this as an example of Observer pattern, where object from Item is subscribed to Shopping Cart, whenever an item is added in cart, that will notify the subscriber, here we can have a method to check the equality of items.","this is wrong because we have not assigned memory for object o2.The initialization of o2 is missing.The second part is pretty clear giving the usage of clone, it is a method in java for object duplication.","Advantages:1.it is elegant, we are adding only one instance variable to person object.Disadvantages:1.It would be hard to find persons belonging to one place of birth.","Advantages:1. we can have results such as number of persons  born in that location almost instantaneously.Disadvantages:1.it is not an elegant way, as it is avoiding the design principle of simplicity.","Advantages:1. this is also a better way  in a way that non of the base objects need to be  modified, adhering to the design principle of ""separation of responsibilities"".Disadvantages:1.creation of extra objects.","The way in which only one object is ever created that represents $1,is that we keep track of all the money objects created in a ArrayList(or any other collections) then when ever a new object is created we check the getAmount() method and our collection. This way we can avoid creation of multiple objects with the same $1.",yes.1. dollars and cents represented by one floating point number as java double.Advantages:1. we can represent far larger numbers and fractional parts of dollars conveniently.2.Also as the quantity of money is being represented by single number it avoids awkward calculations(initially where there were 2 numbers one to hold dollors and other to cents)Disadvantages:1. it increases complexity of the system.2. the round off error caused by floating point problems can rise significant problems. Dollars and cents represented by one long integerAdv1.money is still represented by single value2.still can hold large values.Disadv:1.problems of integer division and truncation of results.,"yes.It can be used to calculate the amount carried by that particular object.Later when all the currencies are incorporated in the design, at some point we might be interested in the amount that is hold by the object, hence getAmount() will be useful here.","we add and subtract USMoney objects because we are in the same level, and thats why it is possible, where as when we do multiply and division, additional constraints come into picture, while division the denominator can't be 0 etc, hence to adhere to these constraints both multiply and divide use plain doubles.It is simpler this way.","We can have an adapter pattern implemented for the US Money class, where in a wrapper is provided to the existing class, it adds the functionality that is required by the new currency such as putting a comma or displaying the currency format in a new way altogether.Inside this adapter we can have a strategy pattern for choosing the type of currency.This can be an elegant way to handle such currency-specific differences.","1.suppose the Singleton object takes a long time to create andyou don?t want a long delay during the start up of your application. 2.suppose the object uses a lot of memory, and so you don?t want to create it at all unless it is needed.","1.The main disadvantage of lazy initialization is the time penalty associated with each access of the variable caused by the condition check.2. Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.","instance variables that are initialized lazily  should not me made public because, the purpose of having only instance is already being served by the lazy initialization itself.","1.Here we are accessing the collections via an integer index.It is not an elegant way to do because this reveals the indexed position in the list to the client which is very unusual.2.Also the method get(int i) is made public, with which any one can access this method.",subject(Publisher): executiveobserver(Subscriber): you (me),"The one that closely matches Observer pattern is ""Leave a message asking the executives to call you back when she is free"".As observer pattern defines a one-to-manydependency between objects so that when oneobject changes state, all of its dependents arenotified and updated automatically.That is exactly what is happening in the 3rd case.",ActionListener interface implements Pull model as it is a method that lets listeners register with the button so they can be notified when the button is clicked.In this scenario it is subscriber which is requesting its publisher to send it updates whenever there is one.,pull model1. the observers should be registered via addActionListener() for each observer.The buttons dont care whose subscribing to them.push model1.It should be able to send messages to all the listeners it has.
,,,82.5,2,1,2,2,1,2,0,0,2,2,2,0,2,0,2,1,2,2,4,2,2,3,1,3,2,3,2,3,2,2,7,3,3,1.5,6,2,4,1,1
,,,,Strategy,Interpreter,Composite,Adapter,Flyweight,Bridge,Builder,Bridge,This is not adapting to work with another person's interface.,Abstract Factory,"Documents are not created by cloning an instance of Letter, Resume, etc. - the creation of documents is more complex than that since they can vary in things such as the included text.",Proxy,"It isn't converting from a different interface, but using a model as a proxy to retrieve the information through.",Singleton,Only one of each kind of dialog box ever gets created.,"No, it doesn't make sure that hour is within 0 and 24 or that minutes are between 0 and 60 when being set.","hour  between 0 and 24minutes between 0 and 60Though, nothing within the class enforces this.",A and B are both integer arrays and array B has the same length as array A.,It doesn't specify what happens with the values of A.  Are they lost?,Old values in B are lost and B has the values of A in the same order.,The function would have to internally check the length of the arrays and modify array B to match the length of array A.,Item should have the responsibility.  This is to reduce coupling.  There is no need to go through Shopping cart any time items need to be compared.,"It redefines the class of o2, which Java does not allow.  Setting o1 to null also only changes o1's pointer to null - it doesn't affect what o2 is pointing at.","Person has-a place of birth makes sense.  This implementation makes it easy to find, given a person, where that person was born.  However, to find people born in a specific location, each Person must be checked.","A location has-many persons born there.  This implementation makes it easy to find, given a location, all of the people born there.  However, to find where a specific person was born, each Location's collection of Person objects must be checked for that person.","Looking up by person or location is easy to do with a table.  This third object takes responsibility off of both Location and Person.  This third object must be remembered to be used is a possible drawback, but not a significant one.","Use a builder class that keeps a collection of currently existing USMoney objects created with it.  If requested to build with an existing amount of money, it will return that USMoney object.  Otherwise, it will create a new USMoney and store it in the collection.","I don't think getAmount should have additional variations since that adds additional responsibility to the USMoney class - the getAmount in other forms will only be needed in special cases.  An adapter class could be used to convert from the returned long value to the desired format, if the alternate format is intended to be used in a different interface.  A decorator could also be used to add additional variations.  These are both good since they keep extra functionality out of USMoney, though an adapter makes more sense for simply varying formatting.","Depends on the situation.  The getAmount method doesn't seem necessary if USMoney is handling all the mathematical operations and if the money is always displayed via the toString method.  However, if the amount is used to do some outside operation such as conversion, the getAmount method is necessary.","Logically, when working with money, money is multiplied by more money or divided by more money.  As an example, if I want to divide my rent of $1200 four ways, I divide it by 4 people, not by $4.  If division and multiplication were by USMoney objects this would not only not make sense semantically, but put an additional burden in programming of having to create a new USMoney object to perform multiplication or division.","The display for such a country could use an interpreter to take one of the two forms already implemented, interpret them, and present the currency as desired.",-Saves cost of initializing values that may not be used anytime soon (possibly never).-,Cost penalty in checking when initialization is needed.  Unspecified initialization can also lead to confusion.,"If publicly available, other classes could try to use null values causing NullPointerExceptions.  With lazy initialization, it must be ensured that the values get initialized before they are accessed, which involves encapsulation.","This design allows elements to be accessed out of order, which may not be desired.",I am the observer.  The executive is the subject.,"Leave a message asking the executive to call you back when she is free. In this case, when the subject changes its state, the observer is notified.","It uses the push model, since the subject (JButton) passes the information of when it is clicked to the observers (actionListeners).","When there is a lot of data and each observer might not want all of that data the pull model is preferred since the observer can just pull what they are interested in when they are interested in it  The push model is preferred however, if all of the observers are interested in the same data.  Push requires the subject to know what its observers need while pull has that knowledge within the observer itself.  Push has a synchronization advantage since it notifies as soon as a change occurs rather than at the nearest ""checkpoint."""
,,,88,2,0,2,2,2,2,0,0,2,2,2,1,2,2,2,3,2,2,4,2,2,2,2,3,3,3,2,4,2,3,4,2,3,3,0,2,4,4,4
,,,,Statergy,Factory method,Composite,Adapter,Singleton,Bridge,Memento,Bridge,This is not an adapter cause in adapter we modify an existing interface so that it becomes usable(we create a wrapper),Decorator,This is not a prototype pattern cause we are not copying instances or using cloning here.,We can use the Facade pattern here to provide a uniform interface,This is not an adapter pattern again cause we do not have incompatible interfaces here.,Interpreter -> Since we have provided a particular pattern (keys being pressed) we can use this pattern.We can also further use the Factory method design pattern,It is not an abstract factory method because abstract factory method would create a family of related objects.,A good way is to specify what makes objects of a class well-formed is to list the class invariants. A class invariantis a statement about the state of objects of the class between public method calls.This is NOT a well formed class as we do not check for the value f hours and minutes before setting them.,invariant 0<=hour && hour < 24;invariant 0<=minutes && minutes < 60,Codn1 : Length of both the arrays are the same.Codn2 : Both of the variables passes must be integer arrays>>if this is not in Java the length of the array needs to be made global so that it is accessible in the copyArray method,We are copying the elements of array A into array B but we are not returning array B.In fact we are not returning anything. which means the only way we can tell about an error is by throwing an exception.,Check if the elements in array A and array B are the same.,Handle all error scenarios in the method like checking for length and type of arrays inside the method.,The shoppingCart class should shave the responsibility of checking if the two items are the same.(in the AddItem method)Expert pattern - Assign a responsibility to the class that has the information needed to carry out the responsibility.,we need to use o2 = (MyClass)o1.clone()which provides the typecasting needed to assign the generic Object reference returned from clone to a reference to a MyClass object.Also MyClass needs to implement the cloneable interface,it would be difficult to associate a person with a particular location object Inheritence is used,Once location objects can have multtiple person objects associated with it. as different ppl can share the same birthday.Delegation is used.,This would be a better implementation as it would be able to relate to the person and location objects as a tuple.,We can use the singleton pattern to make sure that only object of USMoney class is created that represents $1,The getamount can return the amount in the desired notation depending on the locale being used.,Yes we need the getamount method to retrieve the value of the amount variable that is set in the constructor. Conider the following method.public long getAmount(Currency currency){if( this.currency.equals(currency))return amount;elsereturn 0;},"Whenever arithmetic is done with money (e.g., adding two amounts together),the cents and dollar values will need to be adjusted to keep the cents within therange of 0 to 99 hence USmoney object is neededIf you divide $1 by 3, you will get 33 cents. When you multiply the result by 3, you get 99 cents. That is, a penny was lost from the original dollar when first divided by 3 and then multiplied by 3, a very undesirable outcome for those who need to keep track of every cent.",We would need to extend the java.util.Currency and then add to it our new representation of the currency.,"Lazy Initialization is a performance optimization where you defer  (potentially expensive) object creation until just before you actually need it. One example is to not create a database connection up front, but only just before you need to get data from the database. The key reason for doing this is that (often) you can avoid creating the object completely if you never need it.","The main disadvantage of lazy initialization is that your code becomes more complex because you need to check to see if the attribute has been defined yet and, if not, obtain its value. Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. Sometimes, this can lead to confusion.",In Lazy initialization we initialize the variable in the method where we check if it already has a reference. And we need only this method to access the variable hence we need to make it private. If it is made public then any one can access and change the variable.,"There is a problem with size(). Sometimes you don't know the size yet. Some producer thread could be adding elements, while another thread wants to start reading. If it needs the size first,C.size() it can not start before the producer thread has finished.A collection might be so big, that the elements don't fit in memory all together. An iterator only provides access to one element at a time, so it needs to fit in only one element.>Looping through linked lists is O(n^2) in time without iterators. for (int i = 0; i < C.size(); i++) {    Object data = C.get(i);To get to element #5, the list starts at the head element and follows 4 links. To get to element #6 on the next loop, it starts at the head again, following all the same links (plus one). An iterator would be clever enough to remember the last position, giving O(n). A lot faster.The iterator hides how the elements are stored and only provides access which is a nice abstraction.",The observer is the one who is waiting for notifications. In this scenario the observer is THE PERSON who is trying to reach the executive of a companyThe Subject (Publisher) here is the Executive who will notify the observer when she is free.,The third option is most closer to the Observer pattern. This is because leaving a message is like registering for updates with the publisher. And when the publisher is free it(she) would update the observer,Pull Model,"The pattern(Observer) is used to reduce coupling. If you have an object that needs to share it's state with others, without knowing who those objects are, we need to use this pattern.Here> The Subject is coupled only to the Observer base class.> The client configures the number and type of Observers.> Observers register themselves with the Subject.> The Subject broadcasts events to all registered Observers.> The Subject may ?push? information at the Observers, or, the Observers may ?pull? the information they need from the Subject."
,,,80,2,0,2,2,1,2,2,0,2,0,2,2,2,0,2,3,4,2,4,2,2,2,2,1,1,1,3,3,2,3,3,3,3,2,6,2,4,0,1
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,state,template method,builder,adapter,flyweight,abstract factory,composite,abstract pattern,"Because adapter provide a ""connection approach"" for two incompatible interfaces, and here we can directly call the abstract method.",factory method,"Because we know how to create them by calling different implementation. But for prototype, we do not know their class or any details of how to create them.",Chain of Responsibility,Because we do not need to design an interface to connect the manager and the client.,state,Because it does not provide an interface for creating families of related or dependent objects without specifying their concrete classes.,"No. To keep the class well-formed, we should list the class invariants.","The class invariant for this class is the hour format, it should always use the 24-hour clock.",The array B must have the same length as array A.,yes. First we should come with an assertion to check whether the length of array B is the same as the length of the array A.,The values in array B is the same as the values in array A.,"We can weaken the postcondition, like we do not require the values in array B is the same as the values in array A.","the class ShoppingCart should be responsible for deciding whether two items are the same. When you add an item, you should check whether the same item has been added before by checking its product id. The design pattern used here is prototype. When a new item is being added, we first check if the same item being added is already in the shopping cart, if it is, then we just get the item id  and increase the quantity. Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.","The prototype pattern is used when the type of objects to create is determined by a prototypical instance, which is cloned to produce new objects.",Pro: It can provide clear and exact info for each person.Con: It takes too much spaces.,"Con: It is like an one-to-many relation for each location. If there is any change in the location, it may influence a lot of persons.",Con: It may require a adapter to connect these two tables. And searching for the two tables may need much time.,We can use singleton pattern.,"We can use two integers, one for dollars and one for cents, or use one long integer, with an implied decimal point. The advantage is they are easier to read than the cents returned as a long value. The disadvantage is they all cannot present different currencies.","Yes. When you need to deposit or withdraw some money from the bank account, after adding or subtracting some number, you can know how much money left in your bank account by the getMoney method.","Because for add and subtract, the # of digits after the decimal point won't increase, but for multiply and divide, the # of digits probably increase so we should use plain doubles instead of USMoney objects.",We can get part of each form and combine them together. e.g. we get the display method of the currency symbol in the 1st form and the display method of the amount in the 2nd form and then use facade to combine them to show the way we want.,"The object creation maybe potentially expensive, and we can defer that by using lazy initialization until just before we actually need it, so we do not need to initialize the object at the beginning to avoid the expensive process.",The disadvantage of lazy initialization is the time penalty associated with each access of the variable.,For safety purpose. We want to achieve thread-safe.,It has to have the access to the internal members of the aggregate. we can make the iterator an inner class of the aggregate class.,Observer: youSubject: the executive in the company,"The third one - Leave a message asking the executive to call you back when she is free - is most corresponded to the observe pattern. The observe pattern is the subject maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods. In this case, the observer (you) depends on the subject (executive), and the subject (the executive) should notify the observe (you) when she is free.","The push model is used. When the button is clicked, the JButton notifies all the listeners by calling their actionPerformed method, it is like the useful info is passed by the subject (JButton)  to the observer(the listeners), not the observer require info from the subject.","Using push model, we have to implement that the JButton is informed when the button is clicked."
,,,69.5,0,1,1,2,2,1,1,0,2,1,1,0,2,0,2,3,0,2,4,2,2,0,0,2,2,2,3,4,2,3,3,3,2,1.5,3,2,4,4,0
,,,,state pattern,template method,Composite pattern,Adapter,Abstract factory,bridge pattern,visitors,It use Facade pattern.,"Because it shield the client from details. And adapter pattern converts the interface of a class to one expected by clients, if it even don't know that what kind of objects are stored in the array, how can they even do the conversion. So, it's not an Adapter.",Factory method.,"For prototype, it is that a prototypical instance of the class is maintained, and when a new object of that class is needed, the prototypical instance is cloned. It's not the case here, we don't need to clone the prototypical instance. The subclass will create new instance.",Template method.,"We don't need to convert the existing class to one expected by the client. Here what it does is that is defines the skeleton of how to deal with the database and define some steps. The subclass may change some certain steps, but the structure remains the same.",strategy pattern.,Abstract factory defines that families of related objects need to be instantiated from single place in the code. Here is a run-time selection. We don't know what kind of object should be instantiated unless we have press the key.,"No, the guideline in 4.4 said that be aware that, although it can increase the efficiency of your code, caching values instead of computing them when they are needed can also increase the complexity and number of invariants of your class.And the above code just as what the guideline said.",0<= hour; hour <= 240<= minutes; minutes <= 60,The array B must have the same length as array A.,It didn't clearly specify which is the the array that copy from and which is the one that copy to.,Copy the values of array A into array in the same order.,"The method could firstly check that whether the length of array A and array B are the same, if not, throws an exception.","I think it's class Item should decide whether the two item are same. Because according to expert pattern, the object that contains the necessary data to perform a task should be the object that manipulates the data. To see whether the two item are the same, we need to compare their productID and then change the quantity. They are all the data belongs to the class Item, so it's the responsibility of Item.","Because the return type for o1.clone() is an object. By this example, the exception will also be returned. What we should define here is :o2 = (MyClass)o1.clone()","Every time we need to initialize a location object when we create an person object.and it violates that minimizing coupling. However, this kind of design make it easy for us to get the person's birth place. Suppose we have a person object p1, and a method called getBirthPlace() defined in the class, then by p1.getBirthPlace(), we could get the person's birth place.","To some extent, it avoid the duplication. However, the problem here is that if other object delete the original person object, it will make the Location object reference to null.","It adhere to the OO design principle. The third object works as a ""gatekeeper"" and it adheres to the principle that ""Only one class should be responsible for knowing and maintaining a set of data,even if that data is used by many other classes.""However, consider the situation in which you have a gatekeeper of a massive collection of objects. If the collection changes infrequently but there are frequent requests for the size of the collection, then it makes little sense to traverse the collection counting the number of objects every time its size needs to be known",We could use the design pattern Flyweight to implement it. We could make another class called USMoneyManager for maintaining all the state of USMoney while one system only maintain one insance of USmoney with certain value.,"Yes, we could use double to represent the money, such as 3.14, rather representing it with 314 cents. The advantage of using double to represent money is that it represent far larger numbers and you can represent fractional parts of dollars conveniently. However, can increase the complexity of the design and the round-off error caused by floating point approximations can raise signifi cant problems.","It used to return the amount of money in cents. Actually we need it. When we initialize the Money object, the parameter passed in are dollars and cents. We need a uniform way to represent it, which will provide us a easy way to do the follow operation.",We could not multiply or divide two objects unless we overload the operations times and divide in the code.,"We could make an interface called MoneyRepresentation, and the interface contains an method called GetMoney, all the different Money such as US money or Japanese money, etc, implements the interface and give their own implementation to represent the money.","1. if we never use it, it need not to be initialized. 2. Initialization cost could be reduced by not need to initialization all the things at once.",1. We need to check whether the class has been initialized. 2. there is overhead for maintaining the inputs for the initialization that may not be needed after the initialization.,"As we have provide a method to get the instance variable and the instance variable is used to tell whether the class has been initialized, if making it publicly, any one outside the class could also use it, and even change it, it will obey what singleton pattern asks.","It make all the detailed operation on specific data exposed to the client. It's the big problem of this design, but also the advantage of iterators pattern, which provides a way to access the elements of an aggregated object without exposing its underlying representations.",observer: Executive in a companySubject: the person that try to reach an executive,"The third one: Leave a message asking the executive to call you back when she is free. For observer pattern, publishers produce information that is of interest to other objects in the system. And an object that is interested in a piece of this information subscribes to this publisher. The third just satisfies this case, the person sends message to the executive, and if it is of interest to the executive, it will call back.","It probably use the push model. Because for the observer pattern, the publisher will push the message to all its subscriber. However, there is one thing that for observer pattern, publisher only sends message to it's registered subscriber while the push model push the data the observer no matter you need it or not.","It's better that if there is a system that all the users are listeners and the subject will send the message to all the people, and all the people get the message and decides if they need it."
,,,82,1,1,2,2,1,2,1,0,0,1,2,0,2,0,1,3,2,2,4,2,2,5,2,3,2,3,3,3,1,1,7,3,3,2,6,0,2,4,1
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,State Design Pattern.,Decorator Design Pattern.,Composite Design Pattern,Adapter Design Pattern.,Singleton Design Pattern.,Bridge Design Pattern.,Memento Design Pattern.,"1) This is Template Method Pattern2) The template method in this case is the method that has the skeleton that does the sorting.3) For comparing the objects, the outOfOrder() method is abstract.So subclasses are supposed to implement it.4) So if you want to sort an Array of Integers, you will create an IntArr class that extends the BubbleSorter class and implements outOfOrder() by comparing values. Similarly StrArr class can provide outOfOrder() method by extending BubbleSorter and providing String compare.","1) Adapter holds an instance of Adaptee and implements the target Interface expected by the client.2) Here, the Bubble Sort algorithm logic is already abstracted out and some specific tasks within the sort algorithm like outOfOrder() and swap() will be implemented by subclasses.3) So there is no need to hold an instance of Adaptee nor is there an implementation of target interface required.","1) This is Factory Method pattern2) Here, we have one method per class/subclass that creates the specific kind of Object. In this way, the object creation is encapsulated in specific subclasses.3) Also, since client is aware, he is aware which kind of object is going to be created - this is peculiar of Factory Method.","1) In Prototype pattern, you use a Prototypical instance to create the actual type of object.2) But there, you do not know which kind of object is going to be created till runtime.3) So Prototype is used, when type of class is not known till runtime.",1) The Pattern here is Chain of Responsibility.2) Chain of Responsibility is used when more than one object are to be given a chance to handle a request.,"1) Adapter holds an instance of Adaptee and implements the target Interface expected by the client.2) Also, in Adpater, composition is required. Here, there is no composition. Client simply retrieves a Model from Database, then an Element from the Model and then required information from Element.So there is not Adaptee class which needs to behave as per an expected client target interface.","1) This is Command Pattern.2) It decouples the requester(invoker object) of an action from the object that actually performs the action.3) Also, there are various ways by which Find dialog box can be opened, one can open it via the File Menu item. 4) So irrespective of the Invoker, the same action needs to be performed. 5) So the Command Design pattern will encapsulate method invocations.","1) Abstract Factory encapsulates Object Creation.2) It provides an interface for creating families of objects with particular hierarchy without having to specify their type in advance.3) However, there is no apparent hierarchy in any of the dialog boxes here neither is there any encapsulation of object creation.",- The above class is Not well-formed.- The 'Class Invariant' for the Time class would be that value of 'hour' should be between 0 to 23 and value of 'minutes' should be between 0 to 59. - The setHour() and setMinutes() method modifies the hour and minute values of the Time Object without checking this condition.This means it is possible to assign negative values or values out of the specified range for hour and minutes.- We will need to add 'satisfyInvariants()' function and include an 'assert' at then end of both the modifier functions.,"Class Invariant:1) The value of hour should be between 0 to 23 and the value of minutes should be between 0 to 59.hour => [o, 23], minutes => [0, 59]bool satisfyInvariants() {   if (hour > 23 || hour < 0)    return false;   if (minutes > 59 || minutes < 0)    return false;    return true;}Include the following line at the end of every modifier method i.e. in setHour() and setMinutes()assert satisfyIntervals() : ""Invalid Time Value""",1) The lengths of Array A &amp; Array B must be same.2) A &amp; B must be valid integer arrays. (can not contain unicode values or NaN etc.),"1) Copied in 'Same order' is ambiguous. What exactly means by same order. Does it mean copy from lower index to higher index or vice-versa, is not specified.2) What happens if the lengths of the two arrays are not same is not specified.3) What to expect if one or both the arrays are empty is not specified.4) It is not specified if the copyArray method is thread-safe or not.","1) Array B must be equal to Array A, element-by-element.2) The original values in Array B should be overwritten.","1) An ""if"" condition has to be included inside the method that checks if the two arrays are of equal length or not. 2) Or you could pass the lengths of the two arrays as parameters and have them compared inside the function.Do copy only of the lengths are same.","1) The Item class should keep track of checking if two items are same and of so, then it should increment the quantity value.2) This is according to the 'Expert Design Pattern' which says that the class that has the data should be the on to manipulate it.3) Item class has the_productId as well as _quantity.     The value of ""zero"" _quantity means that the item is not in Cart.    Before creating new item, iterate over all the items in _items and then if the productID matches, only increment the _quantity.4) The Iterator design pattern can be used for iterating over _items.   But then actually checking prodyctID values and updating the _quantity value must be done by Item","1) It should have been o2 = (MyClass)o1.clone();2) MyClass should implement the Cloneable Interface.3) MyClass should override the Object's clone() method. Also in that method, it should call super.clone() i.e. Object's clone method.4) The default implementation of clone does a shallow copy.","Advantages - 1) Each person has only one Location. So via this approach, it is easy to extract the birth place given a person.2) Disadvatanges - 1) Finding the place of birth given a Person is easy but finding the persons given a Location is not easy.2) There is information duplication since many persons might have the same place of birth and you would have to store that many copies of Location objects.","Advantages-1) Given a location, it is easier to find out the people who have birthplace there.Disadvantages-1) Many people may have the same Location. So the Location object might need to store references of millions of person objects.2) It is difficult to find out the birthplace directly given just a Person object since there is no backway reference..","Advantages-1) Minimum information lookup time since table can be looked up both ways - person-wise as well as location-wise.2) Minimum information duplication since every Person and Location object is initialized exactly once and the table keeps the track of references.3) Adding new Persons and Locations is comparatively easy,4) A better division of responsibilities among objects.Disadvantages-1) Difficult to setup the table","1) The Singleton Pattern can be used for achieving this.2) Make the constructor private.3) Define a 'public static synchronized"" method getInstance()     This method will check if the value of the object created is ""1"" or          not.    If so, it will not create a new instance if it already exists and will just return a reference to it.","1) Some additionals getter methods can be included in the class2) There can be getCents() method and getDollars() method which returns the number of dollars and cents respectively.3) There can also be getFractionalCents() method which only returns the number of cents remaining after the maximum possible dollar value - like returning 14 for $3.14 etc.Advantages of other getter methods - 1) If the applications using the USMoney class require the outputs in these formats, then the specific getter methods are helpful.2) Provides a more succinct and complete interface for reading the values of the class elements.Disadvantages - 1) Adding more getter methods provides other ways for exposing information. 2) A decision has to be taken if all methods need to be public or not.","1) If we have getCents(), getDollars() and getFractionalCents() methods, then getAmount() method is not needed since the combination of these three methods does exactly what getAmount() does and we dont want to repeat code and violate the DRY principle.2) The getAmount() method can be thought of as a to_String() method.   The getCents() will return the long value containing total number of cents.",1) Because multiply and divide multiply and divide the money by the specified factors. But plus and minus adds to money values.So you can add $3.14 & $6.28 which basically means adding two long variables - but the second parameter is also a USMoney class object.2) In multiplication you just specify by which factor you want to multiply or divide and continue.,"1) An elegant way to achieve this behavior is using the Decorator Pattern.2) Decorator pattern is used for extending the objects at Runtime. It is used for adding functionality without changing the base class.3) This means that the Specific Money class that requires to_string() method to display money value in a different format will simply hold an Instance of the ConcretMoney class and is to_string() method will display the money value in expected format.4) Suppose Money is the abstract base class. It has to_string_1() and to_string_2() abstract methods. ConcreteMoney class extends Money. It has to_string_1() and to_string_2() methods that display the money value in the two formats specified in the problem.5) We can create an abstract Decorator class that extends the Money class. And then a ConcreteDecorator class that extends the Decorator class. The ConcreteDecorator class will hold an instance of Money class - by Polymorphism it means it can hold an instance of ConcreteMoney class. It will use delegation for doing any other money specific operation.6) It will have its own to_string_3() method that displays the money value in the way expected. In this way, Decorator adds functionality without changing the Base class.","1) It increases the efficiency of the program since the objects will be initialized only when needed.2) It will utilize the available memory more effectively, since the memory will be used up only when needed.3) It will save space.","1) The main disadvantage of lazy initialization is the time penalty associated with each access of the variable caused by the 'checking_if_currently_null_or_not' test. 2) Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.3) Also, there should be no direct access of the lazy variable. Direct access to the lazy variable would bypass the 'initialize on first access' code.4) If you add new instance variables, you have to update the initialize method.5) If ""null"" is an acceptable value that a variable can take in your program. then you will need to specify some other 'uninitialized' value.","1) If the lazy variables are available publicly, then there is no control of who can access them. This access might result in bypassing the initializing code- resulting in program crashing or unpredictable output.","1) Collections should not implement Iterator interface.     In the design given in the problem, it is not possible to have multiple Iterators working over the same collection. So for example, if you were to find out product of the collection with itself, you need two iterators. In the above design, ""get()"" method is the only way by which the i'th element can be retrieved. 2) Also, every Collection needs to be aware of how to traverse over it in the get method. So if the type of Collection changes say from ArrayList to LinkedList, the get() method will need to change as well. This violates the 'Open-Close' principle.3) Also, in this design, the responsibility of iterating is placed on the Collection, in Iterator pattern, it will be handled by Iterator, thus achieving more cohesion.",1) The executive is the Publisher.2) The Observer is us. We want to meet with the executive.Executive can have many subscribers.,"Option 3 seems closer.In Observer Pattern, the subject has notify() method via which the subject notifies the subscribers of any change in it. This is equivalent to the executive calling us back. Also subscribers need to register to a Subject. This is equivalent when we leave a message with the executive to contact us when he is free.","1) It uses the Push Model2) When a click event occurs, all the listeners that have registered the ActionListener for click event will be notified via the actionPerformed method.3) Here, the listeners/observers do not have to continuously poll but are notified i.e. it is the Push Model. Updates are pushed by the Subject.","Email notification system - Push model would be better.Suppose, the chat application and calendar application have registered themselves as subscribers for the email application.The email application i.e. the subject in this case, when receives an email, notifies all the subscribers about the email received."
,,,101.5,0,2,2,2,1,2,2,2,2,1,2,0,2,0,2,3,4,2,4,2,2,5,4,3,3,3,3,4,3,2,7,3,3,1.5,6,2,4,4,2
,,,,strategy pattern,decorator pattern,composite pattern,adapter pattern,Singleton pattern,bridge pattern,template,iterator,"This is not an Adapter pattern because we do not try to make one interface adapted to another system,we do not have an existing interface that we are trying to design to.",Abstract Factory,This is not an example of prototype because we do not have a situation where we have to create customized objects and class of them is not known. DocumentCreator provides interface to create a number of documents. The system here has number of derived concrete versions and one of them is invoked based on the requirements. We do not clone an object here.,Chain of responsibility.,"This is not an Adapter because we do not have any specific interface to which we are designing to. Here we have a client class opens a connection then it gets a model ,which then uses the model to get an element. At each step the request is passed along from one handler to the next.",state pattern.,This is not an Abstract Factory because it is not trying to instantiate any object based on some criteria. It only takes the input from the user and based on the present state it executes an action. Abstract Factory does not take a present state into consideration.,This is not a well formed class because it is calculating the time based on the instance variables. It also doesnt check each time when we are trying to set hours or minutes whether they are valid or not. It is ok for the gethour() to return hour. But it is not ok for the sethour() to directly set the hour. We need to check first whether the argument passed is a valid hour or not. This will help us ensure that the class invariants are satisfied before the method execution completes.,public void setMinutes(int minutes){if(minutes >= 0 && minutes < 60)      this.minutes = minutes;}Before the public method returns the object should be back in a well formed state. That is why we place some conditions in the public method which ensures that the class invariant is satisfied before the method returns. The class invariants can be that minutes should always be greater than or equal to zero and less than 60. Hours should always be less than or equal to 23 and greater than or equal to 0,the preconditions for this method would be to check if the size of array B is same as size of array A. assert(getLength(A)==getLength(B));,the behaviour specified mentions that the array A is copied into array B. It does not mention anything about what will be done to array A. Also it does not clearly indicate what will happen if array B is of length greater than array A.,The postconditions are that the array B contents should now be equal to array A contents in the same order as A.,"we should make the precondition as weak as possible. (x!=x  -- false) for eg - getLength(A)!=getLength(A)we should not check for the lengths of the arrays by the caller. To ensure that the clients be aware of what could happen in all cases, we could incorporate the precondition into the postcondition and say exactly what would happen if the precondition is not satisfied. the programmer is notified of the error more quickly.","According to the guidelines of oo designing, Expert pattern says that the object which has the necessary data to perform a task should be the object that manipulates the data.Here we need to ensure that the same item added to the cart is not added into the array list but it should be used to increase the quantity of the already existing item. If the product_id of the product being added is the same as the product present in the cart then we should update quantity. here the Item class has all the information about the product so we must give the responsibility of checking for a duplicate product to the Item class. We can justify our answer using Expert Pattern.","This example is wrong because, we have declared o2 as MyClass o2 in the top statement. But in the fourth line of the code, we say object o2 =o1. When we are trying to create a reference of an object we must store it in an object of the same type. here there is a redeclaration which conflicts with the original declaration. Hence the example is wrong.",Advantage: If each person object has an instance variable location then it is easy to get the location given a person object.Disadvantage: The Person needs to know about location object.,"advantage:If location keeps collection of references to person objects, then it is easy to find all the persons in one location. disadvantage: there has to be many references stored for each location object.",advantage: the third object maintains all the information. so the person and location need not worry about maintaining the information.disadvantage: extra code addition is required. we have to create an extra object which is not good.,We can use a singleton pattern to create one object of a given type. Firstly since $1 is something that would be created very often we should have a subclass called Usd1_usmoney for usmoney that would be instantiated whenever we wanted a $1 object for a usmoney class. The Usd1_usmoney class could have a method called getinstance(). When ever we want to create a money object. we could call a method and check if a money object of that type is already present. If it is then we should return the same object. Otherwise we should create a new object representing $1.To achieve this the constructor should be private static. The method getisntance() should be public static. In this way we could redesign the usmoney class so that only one object is ever created for 1$.,There are several alternatives. One is floating point. Advantages: It is good because we just use one variable to represent money. Disadvantage: it is a problem when we have values like 3.141. we need to consider rounding off which again may lead to comples issues.Second is two ints: Here we would have to use two int variables one is for dollars and the other is for cents. advantage: it is clearly represented now for both dollars and cents. we need not worry about rounding off like the above floating point method.disadvantage: we have to maintain two seperate variables. Also when the cents value crosses 99 we need to make it 0 and add one dollar to the dollar variable. We need to ensure that the cent value is alwasy between 0 and 99. Third method is : one long it representing dollars for example. Here we would represent one dollar as long value $1.Advantage: It is good because we have to deal with only one variable here. disadvantage: when we have a value say $1 and if we want to divide it by 3. then we would get 1$/3 =33 cents. and if we multiply 33 cents with 3 we get 99 cents and not $1. we have lost a cent in this calculation.,yes we need a method getAmount().getAmount method would be used to get the amount of money that particular usmoney object represents.,When we add two usmoney objects we want to ensure that we do not add a usmoney object with a non usmoney object. In reality we need to add or subtract a usmoney object with another usmoney object only and not with any other object not referencing money. For example we may have a situation where we gained extra money and added it to our wallet in real life. we would not add the number of candies we earned to the money we have in real life.But when dividing we would not divide money in one wallet with the money in other wallet. We would try to divide or multiple the money in one wallet with a double to calculate certain fractions of our money left with us. we would not gain anything useful by dividing or multiplying money with other money object. It does not make sense to do so. Hence we multiply and divide by plain doubles. and add and subtract usmoney objects.,We can handle such country specific currencies by making those countries overwrite the methods in the currency class. WE can use strategy pattern here to handle such country specific issues. For example if a country named X need a new representation we can use a strategy pattern to make the display function choose its own display function to display the currency in the new format.,advantages of lazy initialization are that the initialization of variables can be postponed to an extent until they are needed. some instance variables are sometimes costly to initialize and they may not be used as well. Hence by using lazy initialization we can postpone their initialization until a future point of time and save resources. it is done on demand.,"The main disadvantage of lazy initialization is the time penalty associated with each access of the variable caused by the test that we would have to make for the isNil or isnvalidvalue etc. Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.",we do not want to make the instance variables which are initialized lazily public because there is a high chance that some other class tries to use these public variables even before they are intitialized and hence it may lead to errors. That is why we should not have them declared as public and always ensure that they are accesses securely. an example of doing it is by modifying the getter accessor method to ensure the variable is initialized the first time it is accessed.,Here we are accessing the data directly and are able to manipulate the data directly as well. Iterator pattern ensures that we are not given direct access to data at any time. The client need not know any details of the implementation of the collection to iterate over the collection.if the implementation of the collection changes then the code for sequencing over it has to change as well.These are the disadvantages of not using iterator objects.,observer is myself( the person who is calling the executive)subject is the executive.,Leave a message asking the executive to call you back when she is free.,push modelthe ActionListener interface uses the push model for communication because according to the design we are registering the observer with the JButton Class. So whenever the JButton is clicked the actionPerformed method of the observer and notifies it. This happens whenever the JButton is clicked whether the observer needs the information or not. Hence it follows the push model.In the pull model the observer polls the JButton for the information. This is not what is happening the above scenario mentioned. Hence it uses the push model.,"Some requirement for which push model will be better suited is when we are trying to use a canvas editor with three buttons on the top. each time we click on the canvas we need to have a figure displayed based on the last button clicked on the top. Here it is better to use push method, otherwise the observer has to poll each of the buttons each time to know their lastclicked time . also the buttons will then have to maintain a seperate variable listclikedtime to store when they were last clicked.A pull model will be better suited in programs is:If we want to get notified about every engine cycle that is to display an RPM measurement to the driver.Observer pattern: The engine publishes an ""engine cycle"" event to all observers for each cycle. Create a listener that counts events and updates the RPM display.Polling: The RPM display asks the engine at regular intervals for an engine cycle counter, and updates the RPM display accordinglyIn the above example it is better to use polling than the observer pattern, because it is not quite good to have the engine push the information for every cycle."
,,,96,2,2,2,2,1,2,0,0,2,2,2,0,2,0,1,3,4,2,4,2,2,5,4,3,3,3,1,3,2,2,4,3,3,3,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Template Method,Decorator,Composite,Adapter,Singleton,Bridge,Visitor,"Template Method. The BubbleSorter provides a Template. There could be different subclasses of this base class for different type of data such as integers, floating point numbers, etc. which implement the outOfOrder and swap functions.",This is not an Adapter because there are no incompatible interfaces involved. Adapter is used to make a system using one interface to work with a system using another interface.,Abstract Factory pattern.,"It is not a prototype because the type of documents to be created is known at the run time. In a prototype the type of document to be created is not known during the runtime and hence, it requires a clone of the prototypical object depending on the type at the runtime.",Facade,This is not an Adapter because there are no incompatible interfaces involved. Adapter is used to make a system using one interface to work with a system using another interface.,Singleton,AbstractFactory is used to create objects which are closely related. Here we are not creating families of objects.,"No. The constructor does not return a well formed object. To be well formed, the constructor should set the hour and minutes to default values. Also, while setting the values of minutes and hours the methods do not check if the values are valid that is hours should be between 0 and 23 and minutes should be between 0 and 59.",The value for hour should be between 0 and 23.The value for minutes should be between 0 and 59.,A and B are not nullA and B are of the same length,The behavior of the method is not defined if the lengths are different or if one of the arrays is null. This should be handled in the method to make it less ambiguous. This would remove the necessity of the preconditions and hence the users of this method will not have to worry to satisfy those preconditions.,Old values in Array B are lost Array B contains all Elements from Array A in same order if A and B are not null and are of equal sizeThe outcome is not specified If either A or B is null or if A and B are not of the same length.,The method should check is both A and B are not null and their lengths are equal.,"We can use Mediator pattern to check if the item is already in the cart. The mediator pattern decouples the Item from ShoppingCart and manages the mappings between the objects of the two classes. The mediator can also provide additional functionality without changing the class implementations, for example, showing availability of the items in the shopping cart.","If the MyClass contains members of any class type then only the object references to those members are copied and hence the member references in both the original object as well as the cloned object refer to the same object.For a prototype pattern, we require that the original prototype is kept to create clones in the future.",Advantage:The information about the person is kept in the Person object itselfDisadvantage:Tight coupling between the Person and Location objects.Extra space requirements,Advantages:Easy to get data such as all people born at that LocationDisadvantage:Tight coupling between the Location and Person class.Increases complexity to find a particular Person who was born at a Location,"Advantage:This is an example of Mediator pattern. Provides many-to-many mapping between Person and Location objects. Also, it decouples the Person and Location classes.Disadvantage:Increases complexity of the system.","Using a Singleton Pattern, we can ensure that the USMoney object is created exactly once.",Yes. The method could return the value in the form of a fraction. (Dollars.Cents).Clients can use the methods depending on the way in which they want to display the amountBut this would not be efficient and elegant as there would be multiple methods to display the amount and the clients would require to remember each of them,The getAmount method is used to get the amount stored in the USMoney object. The amount field may be private and hence we require getAmount method to maintain encapsulation,"This is because in real world, we generally add amounts of money, but we do not multiply two amounts of money. We may multiple or divide an integer or a fraction to the amount of money we have.",The information about the currency is placed in the Currency class for that country. This Currency class can extend the java.util.Currency class by adding subclasses which return the symbols for the currencies for the nations that require to print the amounts in the third form.,"It speeds up the initialization process of the system because the objects which are not required are not initialized, reducing the overall time required.We avoid creating the object completely if we never need it.The time for initialization is amortized over the run of the program and is not condensed at the beginning","Time penalty associated with each access of the variable caused by the #isNil test. Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.Code becomes more complex because we need to check if the objects are initialized every time we try to access them","Making the variables which are lazily initialized available publicly will increase the complexity of the code as the clients who want to use the variables will have to check if the variables are initialized every time they reference the variables.This would also increase the processing time which would offset the time saved by lazy initialization.Also, we would have to provide methods to initialize the public variables when a client references them for the first time.",The iterator pattern allows to traverse the collection without exposing the implementation details. It also allows to provide different iterators to traverse the collection in different ways. The above implementation tightly couples the client with the collection class. It also requires for different client classes to implement their own looping constructs even if they traverse the collection in the same manner. The above solution does not provide the level of abstraction that the Iterator pattern provides.,Observer: ExecutiveSubject: You,"The third choice corresponds most closely to the Observer pattern. In this case, the Observer, that is the executive observes the voicemail. The subject, that is you, notifies the observer about the fact that you want to talk to her. When she listens to the message, she will call you back.","The ActionListener interface uses the push model. The input to the actionPerformed method in the Listener gets an event object. The event object consists all the information about the event that may or may not be required by the listener. In the example in the textbook, the event object has the information about the clicked button, but the listener only requires the source of the button.","A pull model is used when the observer needs only a certain amount of information from the subject. Pull model is used in a client-server architecture where the layered systems in the backend pull states from the object.A push model is used for desktop applications, It is suited for Model-View-Controller architecture."
,,,96,0,2,2,2,1,2,0,2,2,2,2,2,2,2,2,3,4,2,4,2,2,5,3,3,3,3,3,4,2,2,3,3,3,2,6,0,2,4,3
,,,,Strategy Pattern,Abstract Factory,Composite Pattern,Adapter Pattern,Singleton Pattern,Builder Pattern,Prototype Pattern,Template Pattern,It is not an adapter pattern because adapter pattern does the job of  translating one interface for a class into a compatible interface. An adapter allows classes to work together that normally could not because of incompatible interfaces. There is no such requirement in this scenario,Decorator Pattern,"The prototype pattern is used when the type of objects to create is determined by a prototypical instance, which is cloned to produce new objects. There are no such prototypical instances in the scenario.",Chain of Responsibility,In this scenario there are no incompatible interfaces. There is no need of translating one to another. Thus this is not an adapter pattern.,Singleton Pattern,The abstract factory pattern is used to encapsulate a group of  factories with a common theme. Clients using an abstract factory creates a concrete implementation of the abstract factory and then uses the generic interfaces to create pertinent objects. The above scenario does not have this requirement.,Yes this class is well formed. It does only what a Time class is supposed to do. It maintains the hour and minutes. Provides accessor methods to these data members. It also provides a default constructor (although without any implementation logic) so that compiler does not have to insert its default constructor.,If the time is represented in 24 hour scale:the value of hour can only be in the range of 00 to 23.Minutes can be only in the range of 00 to 59.(no negative values are allowed)In case of a 12 hour scale:the value of hour can only be in the range of 00 to 12.(no negative values are allowed),Integer array A should be valid.Integer array B should be valid and can be either empty or has its existing values stored.A and B are integer arrays initialized of equal length.,Yes there is an ambiguity. I believe there should be a check on the type and dimension of the arrays that are passed to this function.,Pre-existing values of B are overwritten.Array B has all the values of Array A.Elements in both the arrays have the same order.Array A's elements are intact.,"public void copyArray(Object A, Object B) { ... }",Shopping Cart should be responsible to check whether the item being added is the same as an existing item. The code above uses the law of demeter. The responsibilities of a classes are distributed in a justified manner.,"In a prototype pattern, there should be an abstract base class that specifies a pure virtual clone() method. This base class is used to create a prototypical instance when it is rather expensive to create objects in the standard way. The above code uses no such abstract class that implements a Cloneable that clones o2 from o1. Thus this example does not use a Prototype pattern.",This is a good design as it uses composition. Person object contains an instance of type Location. However the disadvantage of this design is that there is increased coupling between objects of Location and Person.,This is not such a good design as we should not expect objects of class Location to maintain this information.,This is a good design as it reduces the coupling between these 2 objects.,We can use Singleton pattern to serve this purpose. To make sure that there is only one object ever created that represents $1 we can have a private constructor and a getInstance(). We also need to make sure that there is no accessor method to change the value to be represented.,"Yes there should be additional variations in the getAmount method. This allows data to be exported in the way the end user wants it. Also returning the number of cents is not the most readable way to represent money. In short, additional variations should be a side effect of the new formats in which the data is requested.",Yes we need a getAmount method. This is needed because it is a good o-o principle to encapsulate data members and provide accessor methods that manipulate it.,"This is because in a general scenario we do not divide or multiply 2 or more USMoney objects. We either divide the money into n parts or multiply it m times(note that n and m are random numbers). Thus to avoid the trouble of converting from one format to another, we simply multiply and divide by plain doubles","Assuming that such a representation is not demanded by all the countries, the pre-existing java.util.currency class has a good existing design and it need not be changed. We can serve all such countries who specially request these formats by including an object of the currency class in our custom class and represent money in whichever format the country wants by modifying the original representation used by the object of java.util.currency.",It saves memory and allocates memory to objects only when they are instantiated. Thus a system which has n classes but is not in use at this point does not eat up the memory only with class definitions.,"If proper care is not taken to initialize such objects, this can lead to anomalous behavior(viz. Null pointer exception) and unexpected behavior which can be an overhead to debug.",An object's instance variable initialized lazily or not should not be made publicly available. This is not a good o-o practice.,This is not such a good design. This is because the iterator gives a unified understanding of accessing and iterating through items of a collection. The above design incorporates a method to get element at the ith position. In the future we will have to write other such methods to handle elements of the collection. Instead of this creating a separate iterator object that takes care of all of these operations for you provides loose coupling and higher cohesion of the underlying system,You are the observerExecutive is the publisher(actually there should be some a personal assistant or a status message on the company IM that conveys the executive's availability),3rd choice. The state of the executive is being observed by me. Thus I subscribe to know her states (free or not). (Assuming) She will call me back is the situation in which she publishes her availability.,It uses the push model. This is because addActionListener() notifies all the registered listeners unconditionally once they register.,"In Mobile IP when a mobile agent tries to poll for foreign agents in the newly moved location, the pull model would be better suited. This can save the foreign agents from periodically broadcasting their availability in case there are very few visitors. In a stock market when there are many people interested in the current status of the market, all such interested users can be notified of fluctuations in the market using the push model."
,,,86,2,0,2,2,1,0,1,2,2,0,2,0,2,2,2,1,4,2,4,2,1,0,3,3,2,2,3,4,2,2,4,3,3,1,6,2,4,4,4
,,,,strategy pattern,decorator pattern,composite pattern,adpater pattern,prototype pattern,bridge pattern,builder pattern,strategy pattern.,An adapter pattern converts one interface into another interface. but here nothing like that happens. Here the algorithm is hidden and executed whenever it is called.,Template Method pattern.,"Prototype Pattern is used when creating an instance a given class is either expensive or complicated, and it tries to use the same representation for different objects and saves memory. Here totally two different documents are created.",chain of responsiblity pattern.,An adapter pattern provides a wrapper around an exisitng interface. But here the objects are passed to another object for handling and hence this is not an adapter interface.,Factory method pattern.,Because it knows in adavance which concrete classes will be used to create the dialog boxes.,since the sethour and setMinutes methods does not check for any validation the class is not well formed. Any one can change the value and make the clock inconsistent.,asset this.hour > 24 : <error message>hour cannot be greater than 24,A != NULL && B != NULL,yes. It doesnt say wat is the maximum size of the array and what if B doesnt have enough space to hold all the elements from A.,A.length == B.length,if (A==NULL)A = new Array();if (B++NULL)B = new Array(),A third class can be used to check if the item is already present.Iterator pattern can be used.An iterator inner class can be defined in the shoppingCart class and will be used by the third class to iterate through the items and return if the item is already there or not. then Add item will use this data to do the necessary updation.,Prototype pattern is used to hide the object creation of complex objects. But this example clearly says which class we are cloning. and prototype pattern is used when creating an instance of a given class is either expensive or complicated but here the object creation is simple. o2 should modify the instance according to the requirement before it uses the behaviours.,"Keeps the design simple. If there are no more extensions to the code, then the class is highly cohesive because the place of birth is highly related to a person. If we want to find the persons of a location, then we have to access the person object first and then check the location to see if it matches. If more informations are required to save, then we need to have more object in the person object.",This design is an advantage if we have more number of Persons and less number of locations. if you want to location specific persons you can retreieve it easily.If the collection datastructure is changed then we have to change the code in all places. If there are lot of locations and less number of users this design wastes the memory. It is expensive to search for a person's place of birth.,"Easy acces in both ways given the person object to find the location or given the location to find the users.If more fields are to be added, then the table has to add more columns to it and should case statements to find in which column we should search for. For example if we need to find the persons date of birth we need to return the value of column 3.",Singleton patternpublic class USMoney implements Money{private static USMoney instance = null;private int value = 0;private USMoney(long cents) {  this.value = cents;}(if instance == null) {instance = new USMoney(100);return instance;}}public static synchronized Singleton instance(){if (instance == null) {instance = new Singleton();}return instance;}},yes. the number of decimal points can be different for different countries. eg. USA uses 2 and Japan uses 0. so we need to distinguish that which cannot be done in a single long value.A floating point value can be used to represent the value. But floating point uses more that 6 decimal points which is unnesscary.we can use 2 integers to calculate the dollars and cents. but we have an extra processing of addition and converting cents into dollars.,yes we need get amount method which can be used along with get rate method to calculate the original values of different currencies and convert them appropriately. Since each currency has a different value,because there will be loss due to round off errors. ex. 100/3 = 33 33 * 3 = 99 . one cent is lost,"Template Method pattern can be used.A template method pattern does not alter the algorithm for printing, but just redefines the skeleton of the algorithm. so we can have separate functions for differnect curriencies and redefine the algorithm based on the reqrement with the comma or putting the symbol at the end.",avoids creating the one instance until the first timeinstance is called. If the creation of the instance is expensive then lazy initilization doesnt burden the system.,"In a multi processing threading environment, it is possible that two threads call the constructor at the same time and see that the instance is null and creates 2 objects which totally spoils the design pattern",Because you can set that instance to NULL and again one more instance which is not the property of a singleton pattern,"This implementation works only for an ordered collection. If the data structure is changed to a hashmap or hashset or binary tree then we have to use another kind of approach to traverse through the elements.And if there is a change in the internal element retrieval, then we have to modify the code in all for loops which are used to iterate,",Observer - Me (you in the question context)Publisher - Executive,"Choice 3. I send a message to the executive when she becomes free. So when there is a change in the state of the subject, she gives me a call.",push model. Whenever there is a change in the button (click) it notifies (pushes) all the listeners.,"Push Model will be suited for any real time telecasts. Something often changes like weather report. When the users subscribe to a weather report application, whenever there is a change in the weather, the application will notify all the users. A pull model will be unsuited here because it is a waste of bandwidth if all the users are polling for an update from the application every 5 seconds."
,,,88,2,2,2,2,0,2,0,2,2,0,0,0,2,0,2,3,1,2,4,1,1,0,2,3,3,3,3,3,2,3,7,3,3,3,6,2,4,4,4
,,,,Facade,Template method,Composite,Adapter,Singleton,Prototype,Memento,Facade,There is not a interface we MUST design to. But we need a simpler interface. Here we provide a unified interface.,Abstract Factory,We do NOT create new objects BY COPYING a prototype class or something like that.,Iterator,There is not pre-existing class.,Oberserver,"We define a dependency between objects  so that one changes its state, dependency is notified. instead of creating new sets of objects.",No. We should make Hour and Minute as two other classes. And have their getters and setters in their own class. That will be good for managing the time. So Time class have to variable : Hour hours; and Minute minutes,/*@invariant 0<=hour && hour <=24; @*/ //class invariant    /*@invariant 0<=minutes && minutes < 60; @*/ //class invariant,A is readable integer array and B is writable integer array.,"The name of A and B should be clear like that : toBeCopy,and copyInto.",Array B has the same ordered value as array A and same length,Set the postcondition as True,ShoppingCart class,"We need to place the ""public Object clone()"" definition in the MyClass class. And only after that can we correctly use ""o2 = o1.clone();","Adv: simple, we can get the person's location very quickly by seeing its ""location"" variable. Each person has one and only one birthplace so that put this variable in Person object will make the location as a attribute of a person.Disadv: many person born in the same place but they must maintain a variable separately.",Adv: it's clear to see the number of persons or other infos regarding to the person of a particular location.Disadv: the collection regarding to the person who was borned there might very large and hard to manage.,Adv: It is more clear to see a mapping between a person and his/her birthplace. It's convenient to count the number of person from each location.Disadv: extra cost to maintain a third part table.,we can define the $1 as a singleton object that there is only one object of a class.,"Yes. We should maintain a variable to represent the number of ""$1"". eg: count;  Adv: it's easy to know how many ""$1"" and Disadv: one more variable to maintain, that increase the system cost.",No. That's used for knowing the number of dollars and cents that it represents. We can actually set a variable to represent that.,Multiply and divide is more complicated and use plain doubles will be simple and easy to realize.,We create a subclass of currency(eg: myContryCurrency)  for that country derived from the currency. Then we create a new method called myTypeofCurrency which can show the form we like.,It will minimize the work which is done by the computer and improve the performance. We don't have to pay much attention on initialization.,"The main disadvantage of lazy initialization is the time penalty associated with each access of the variable caused by the #isNil test. Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.","A public available instance might be called by other classes. If it is initialized lazily, the call by other classes might have some error. because the call by others might happen before the call by itself.","Not all object can be calculate its size. for example, an array has a size, so the code above applied. But if we want to iterate a set of objects which is defined by users, the C.size might not work properly.",Observer: MeSubject: Executive,"The third one. The subject maintain a list of its dependents, and calls the observers, usually by calling one of the methods which is provided by the observer. In the third one, the message is like a path that observer leaves to the subject. In the first and second one, it's always the observer is trying instead of subject calling.","Yes. ActionListener is the observer and user is subject. when user not click the button, the observer just polls the subject for the info(listen), here it use the Pull model. If user(subject) push the button, an information is passed from user(subject) to listener(observer) and listener will call a relative method provided bu user( subject), so here it use the Push model.","The program should make observer always active. The observer should also provide method(s) that if something happen, the subject can call the method to notify the observer.An example: Drawing graphs. If we want to draw a circle, the model in charged of drawing have to get the information about what graphs I want to draw. For example: circle or ellipse or rectangle."
,,,82,1,1,2,2,1,1,2,0,2,2,2,0,2,0,2,1,3,2,4,2,2,0,2,3,3,3,3,3,2,2,4,3,3,2,6,2,4,1,2
,,,,Strategy Pattern,Abstract Factory,Composite,Adapter,Builder,Template Method?,Memento,Bridge,Adapter makes things work after they're designed whereas Bridge makes them work before they are.,Builder,Builder can use one of the other patterns to implement which components get built. Prototype uses Singleton in their implementations.,Iterator,It provides a way to access the elements of an aggregate object sequentially without exposing its underlying representationThough Adapter lets classes work together it just works around the interface of the class like a wrapper,Command,It encapsulates the client request in an object. Abstract Factory tries create families between related objects,"No.The hour parameter is set in between the public calls. When the control is at line which calls the method getMinutes there is a possibility that the the hour value has changes. So example, instead of 1.59 pm, it shows as 2.59  pm",This is the class invariant which changes the state of the object between public method callspublic void setHour(int hour) { this.hour = hour; },"Length of array B must be same as array AArray A should be integer array, same as array B",If array B length should be same then it should be created on the fly after comparing with array AIt is said that old values of B is lost thus the possibility of lengths being same is not 100%,Order of elements after copying from A to B must be same,Then only two arrays should be passed irrespective of their size or type,ShoppingCart is responsible for deciding the similarity of items.Particular Item is a singleton object and will not keep track.Prototype pattern suggest that a clone of the Item is formed,The objects here is not cloned. But an entirely different object is created,ADV: Makes sense as a Person class should have a Location variable which tells his place of birthDIS-ADV: Makes the structure complex. A class within a class.,ADV: Useful when you need to know all the people born in one particular locationDIS-ADV: Person class will have difficulty in accessing and modifying it's Location parameters,ADV: Similar to Mediator. Promotes loose coupling by keeping objects from referring to each other explicitly.DIS-ADV: Introducing a third class will just increase the complexity,The USMoney class can be made as a Singleton Class,Alternate: It can return the value as two separate integers. One for dollars and the other for centsADV : Easy to understandDIS-ADV : Problem of carry from cents to dollarsAlternate: Money as FloatADV : Manipulation becomes very easyDIS-ADV :Confusion with three or more digit accuracy after decimal point. Only two digit accuracy makes sense,"It will be used, for example, for display purposes, calculation of new transactions.","Multiplication and division of money by plain doubles make sense. For example, Money is never divided among money. It is divided among people.And we multiply cost of an item with its quantity",Currency class in Java follows the decorator design pattern which helps attach additional responsibilities to an object dynamically. We can create an abstract Money class add methodsThe method will check the ISO 4217 code of that currency and display accordingly,"- If you never use the value, you don't pay for it.- Initialization costs can be more spread out by not initializing     everything at once.- Start-up appears to be faster.- Ability to delay until needed information is available.",#NAME?,The public instance variables can be used by any other class as well. The fact that it is not yet initialized might not be known to an outsider class.,It does not support multiple simultaneous traversals of a collection. Each class object needs to be taken care of one at a time,"Publisher is the executive who publishes his statusObserver is you, as you are polling to get his availability status",SecondThe observer keeps polling the company until the executive (publisher) is free,Push model.When the button is clicked the information is pushed on to the method addActionListener.,Objects are dependent on each otherThey have one-to-many dependencyFor a pull modelThere needs to be frequent polling from the observer.
,,,69,2,0,2,2,0,0,2,0,0,0,0,0,1,0,1,2,0,2,4,2,1,0,0,2,3,3,3,4,2,2,5,3,3,1,6,2,1,4,4
,,,,command,Strategy,Composite,Adapter,Prototype,Bridge,Momento,Template Method,"Using the TEMPLATE METHOD pattern, we can separate the bubble sort algorithm out into an abstract base class named BubbleSorter.Because here we see that inheritance is being used. We are not converting any interface as per expectation of the client",Abstract Factory,In abstarct factory when we create factories we use inheritance but in prototyping we use delagtion. Prototyep does not require subclassing.,Chain of Responsibility,Here the objects who send teh commadn do not know what object will receive it and handle it Adapter is meant to change the interface of an existing object but we are not changing any interface here to get the required.Chain of Responsibility address how you can decouple senders and receivers,Command Pattern,"We can encapsulate a request as an object, thereby letting parameterize clients with different requests.Command decouples the object that invokes the operation from the one that knows how to perform it.aBSTRACT FACTORY NEEDS inheritance whereas we will be using delegation here .","Yes the class is well formed since the ""well formed "" means that methods that do similar things are laid out similarly. Here we see that the getter and setters of hours and minutes have been laid out in the same fashion.The signature of getter for hour is public int getHour() { return hour; } which is similar to that of minutespublic int getMinutes() { return minutes; }",The class invariant constrains the state stored in the object.The useful effect of class invariants in object-oriented software is enhanced in the presence of inheritanceSo if we have an Hour class which inherits from the time class.public class Hour extends Time{   public Hour{ super();}So we will inherit even the methods of minutes which are not needed for hours. To do better  We will then actually change the time class to delegate the responsibility of getting the hours from hours class For example:public class Time{   Hour h;   Minutes  m  public int getHour() { return h.hour; },The length of arrays should be same. a.size() == b.size()The type of the values should be same. Both should be integer arraysThe index element 1 of array A  should replace index element 1 in array B.,"The method defines here can have different size of arrays and still the elements will be replaced. In that case if Array A is bigger than B some elements of A will not be copied and If array B is bigger than A then space will be left in Array B .The precondition is strong , we could also have both arrays having general objects and the same thing can be done with same result.The post condition mentions that the length of both arrays should be equal. What if array B is larger we still will have the same result .So I feel those are the ambiguties .",Post condition is that all the array B elements are replaced by the array A elements with no space left in array B since equal sized arrays.Now the array A becomes equal to Array B in size as well as content .A[] a = B[] b.,"public void copyArray (Object[] A,Object[] B)Since we do not care whatever the objects are since they are all objects because of type of arrays being Object arrays.","According to the design principle we know that every class should be responsible for doing one thing and doing it well . Class Item here is has the concept model regarding  the products. That means it has all the information about the product . All the methods are defined which are appropriate for the concept . And high cohesion because behaviors and responsibility are related . There is also a princilple of encapsulation which says that A class should have the knowing and doing responsibilties differently . So Shopping cart is the one which is take the info from Item class and doing the mathematical operation. So we should have a different class which actually controls the various actions regarding which object to do what and when . Since we need to do comparing here , we should have a different class . But according to ExpertPattern it says that the object has the necessary data to perform the task  should be the one to do so . So above Item class has the required info . So we see there is a conflict between the design principles. Our ultimate goal is to achieve OPEN-CLOSED PRINCIPLE . So here I suggest that Item class will delegate the responsibility of comparison to a third class .","The default value returned by clone() is of type Object and here above we need to actually typecast o1 to MyClass since o2 is of type My Class.There are some problems also1. When we make o1 = null , it means that the reference variable o1 is not pointing to any object .. And we have already made o2 to point to same object to which o1 was pointing to . But making o1= null does not mean that o2 will point to null.The object is still there but o2 is still poiniting to it .Hence the above example is wrong","Advantage = You do not have to inherit from Person class. We can simply have a reference to Location objects and actually delegate the responsibility of returning the location of the person to the Location class.Disadvantage :You are actually depending on the Location class to return you the correct answer . which is increasing the dependence of one class on other class. So it is a bad idea. Take  a case if someone fiddles around with location class, then we will get wrong values hereof Person's location","Advantage: Follows the principle that class does one thing and does it well. Location class is supposed to give us location and in this case by refering to Person it will do it well .Disadvantage = The class can explode if we start keeping refernece for so many person objects. Also even if we using iteration to track , location class will still need to depend on the Person class . So constant tracking will need to take place. Possible to have inheritance but for no worth at all .",Advantage =  Here the advantage is that if some data needs to be changed then we need to do it at only one place since a third object is having all the details .Follows the principle that all data should be stored at one place . Disadvantage = When if new persons join we will need to go ahead and modify the class which actually violates the open closed principle.,if we use the Singleton pattern here we can make sure that only one instance of object is created and that too of value fixed as 1$. no one can change it since the value of the instance variable will be final  and not accessible to evry  one,"To allow mixed arithmetic using these money classes, it turns out that the only change we need to make to the USMoney interface is that all the methods will need to use a type other than USMoney for the parameters and return type. To allow any type of money to be passed as the parameter, we need a common superclass orinterface Money for all our classes. In fact, we need only take the public interface given for USMoney  and replace USMoney with Money everywhere to get the interface of the new Money superclass. Because we will want to move duplicated code up into the superclass, we will make Money an abstract class ratherthan a Java interface.Advantage will be that we are not changing coding to inteface and not to implementation .Disadvantage is that there can be lots of conditional statements which we need to avoid",Yes we will still need it . It is used to still calculate the Amount of money  in form of Money Object .,Since adding and subtracting any amount of money of type USMONey will give us the same type as USMOney object but if we multiple or divide we can get floating point values which we want to avoid since we want our Money to be of same type consistently throughout . Since we do not know the form of currency being described here .,Here there are two extra different behaviors  have been defined where the second form is being followed by a comma instead of period and the first form could have the sign at the end instead of front . SO we will use the state pattern where the two states have been defined as in interface and the different behavior can be handled inside the classes represented by States. That is we are allowing the state to alter its behavior when an internal state changes so object will appear to change its class.The object needing different behavior will maintain a reference to another object representing its state.,"Getter method allows changes to the instance object without changing the implementation . Also we will not be creating a lot many objects unnecessarily since it take up memory space. Lazy initialization should only be used if (a) the initialization of the instance variable would take a long time, or (b) consume a significant amount of resources and (c) there is a good chance the variable will not be used.","The time penalty associated with each access of the variable. Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.",Take a case of threads where each of them will be able to access teh value and modify accordingly which will give inconsistency among the value of the instance variable .We need to make it synchronized to avoid the problem .Making it publicly available will be kind of all having access to that instance and so Singleton pattern motive is destroyed.,In all the cases here we might be doing same thing with data but this has constrained us to knwo what kind of collection is it . For traversing another kind of data structure like hash map etc the obove will fail . It is important that a collection should provide a way to access its elements without exposing the internal structure to the client . So we can see that it does not support multiple different forms of traversals of a collection .Infact the interface is not uniform . With iterator it could have taken care of creating an instance of iterator that keeps track of where you are  by use of inner classes.So a way to walk through instances of that class.,Observer = MyselfSubject = Message which I left for executive,"The third choice is the most appropriate because according to the observer pattern , the observers should delegate the responsibility for an event to a central subject ( Message) in our case .Here we can see the one to many dependency between objects since when an executive is free it notifies all its dependents and update the message accordingly .Here the publisher and subscriber are not tightly coupled.",The key feature here is that the buttons which are publishers no longer need to know exactly what kind of listeners they have .All they care about is that all the listeneres implement the Action Listener interface ;that is the buttons care only that listeners have an actionPerformed method that the buttons can call when they are clicked. So push model.,"Push model - The subjects send detailed information about the change to the observer whether it uses it or not. Because the subject needs to send the detailed information to the observer this might be inefficient when a large amount of data needs to be sent and it is not used. Another aproach would be to send only the information required by the observer. In this case the subject should be able to distinguish between different types of observers and to know the required data of each of them, meaning that the subject layer is more coupled to observer layer.Pull model - The subject just notifies the observers when a change in his state appears and it's the responsibility of each observer to pull the required data from the subject. This can be inefficient because the communication is done in 2 steps and problems might appear in multithreading environments.So good only where it is a single thread environment .The efficiency can be improved by specifying which are the events on which each observer is interested. This can be realized by adding a new class defining an aspect. When an observer is registering it will provide the aspects in which it is interested"
,,,91,1,1,2,2,0,2,2,2,2,2,2,0,2,0,2,1,0,2,4,2,1,5,4,3,3,2,3,4,2,3,3,3,3,2,6,1,4,4,4
,,,,Strategy,Decorator,Composite,Adapter,Flyweight,Factory,Memento,"This is the template pattern. The abstract BubbleSorter defines the skeleton of the algorithm, requiring subclasses to implement outOfOrder.","The Adapter pattern converts the interface of a class into another interface that the client expects. The above problem talks of an implementation of an algorithm, without any specification on what interface is expected by a client.",Strategy,The prototype is used in systems the client code can make instances without knowing which specific class is being instantiated. The above problem talks of how to have a text editor with different kinds of document creators. It does not involve any client concerns about identifying which type of documentCreator was used.,Chain of responsibility,The Adapter pattern converts the interface of a class into another interface that the client expects. The above problem talks of workflow to use a database without any specification on what interface is expected by a client.,Factory.We can have a dialogBoxFactory that returns the corresponding dialog box for an input,"The Abstract factory provides an interface for creating families of related objects. In each of the scenarios specified above, we are dealing with a single object rather than a family.","Skrien: 'Public methods should always keep objects in a well-formed state'. This can be easily violated in the above implementation by setting the value of minutes to a negative value, which is not a well-formed state of time. Hence the above class in NOT well formed.",The class invariant for this class is that 0 <= hour <=23 and 0 <= minutes <=59. This invariant can be enforced using,The array B must have the same length as array A,"Yes, because of the nature of operation being performed, there is a chance that the operation cannot be performed successfully (in a case where B is shorter than A). In such a case, there is no way for the user to know if the method did what it was supposed to or failed. This ambiguity can be removed by having the method return a Boolean that indicates the outcome.",The values in array A and B must be in the same order.,"If the length of array B is not the same as array A, we should re-initialize array B with length of array A. As the old values in B are lost anyways, this change should not affect the correctness of the method.","The Item class should have the responsibility of deciding whether two Items are the same. This follows the principle of high cohesion and low coupling. Having the item class do everything related with an item (like comparing it with another one) increases the cohesion of the item class. Also, putting the comparison responsibility on the ShoppingCart class would increase the coupling between ShoppingCart and Item.","This is because some java objects are immutable.This means that those need to be represented in only one place in memory, regardless of how many variables that refer to them. In such a case making that object null will cause a NullPointerException to be thrown.",Advantages:1. Finding a person's place of birth becomes easy2. Setting a person't place of birth is easyDisadvantages:1. Makes the Person object complex (larger),"Advantages:1. Makes the Person object simpler (smaller)Disadvantages:1. Increases the state associated with a Location, making it complex. Each location now has to keep a list of persons associated with it.2. Finding a person's place of birth becomes costlier - a search is required in each location.3. Setting a person's place of birth becomes costlier - we need to check if such a location already exists, if not then create one and add that person to the location's state.",Advantages:1. Makes the Person object simpler (smaller)2. Makes the Location object simpler (smaller)Disadvantages:1. Finding a person's place of birth becomes costlier - a search is required in a table,"The USMoney class could be made a singleton. This can be achieved by having a static instance initialized to a value of $1, a getter for it and a private constructor","I do not believe additional variations are required. Having many functions that do the same thing can cause confusion in the user's mind. Any other representation of the value can be obtained by manipulating the number of cents returned. Having said that providing multiple variations does provide good user experience, with the user able to get the amount in a representation wished by him/her.","Yes, we do need a getAmount method. Since a Money object encapsulates a currency and a amount, the getAmount method can be used to find the numeric value of the money it represents.",Because of the way different money objects differ in their implementation. Hence we convert to a plain double and then multiply or divide.,"This can be handled by using the decorator pattern. For all countries that would like to display their currencies in form other than the standard, we could have a decorator class with a print() method that will use the print of the currency object to display the value in a pretty fashion.","Lazy initialization can reduce the memory usage of a program. Hence, with lazy initialization a program can be run with less memory, reducing its chance of getting a performance hit due to memory constraints such as swapping.","Lazy initialization may degrade run-time performance as on initial reference to an objects it needs to initialized first before use. Comparing with eager initialization, we can achieve better run time performance as live objects are sitting in runtime memory waiting to be called.","Any reference to an instance variable that is initialized lazily needs to check the variable has been initialized. Public visibility of such a object allows reference to it without enforcing this check. In case the object is not initialized, it will return a null.","This design deals with the internals of a collection. It does not provide an abstracted traversal technique. It leads to duplication of code. If we wanted to traverse 10 different collections, we would need to write the for loop 10 times, once for each collection. On the other hand if we had all the collections implement iterator, we would just need to initialize an iterator to 10 different ones, and have a single loop to traverse all of them.","The observer is you (self), and the subject is the executive.","Leave a message asking the executive to call you back when she is free.By leaving a message, you are registering yourself as an observer of the executive. When the executive changes state (becomes free), she will inform you. This is exactly how an observer pattern functions - Observers register with the subject, the subject informs all the observers on a state change","The JButton class sends an ActionEvent object to all the observers in case of a state change. The ActionEvent indicates that a component-defined action occurred. After that it is up to the observer to pull the states, that are interesting to it from the JButton object. Hence, it uses a pull model of communication",A choice of a push/pull method depends on the observer use case for a change in state.Push model:Should be used for simple subjects or observers with interests in the entire state of the subject.Pull model:Should be used for complex subjects or observers with interests in specific fields of the subject state. Pull can lead to a more efficient design where an observer pulls only what it needs to rather than having everything pushed by the subject.
,,,89,2,2,2,2,2,0,2,2,2,0,1,0,2,0,2,3,4,2,4,2,2,2,3,2,2,2,3,4,2,1,4,3,3,3,6,2,4,1,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy,flyweight,Composite,Adapter,Singleton,Bridge,Interpretor,Facade.,It is not adapter because it does not provides a different interface then the existing one. That is the system still has the same interface (i.e. a sort method). it's just that we hide how it is being implemented.,Factory Method,It is not a prototype because in it we are not cloning an existing object to create a new object. More over the client is aware of the type of object.,Template Method or Chain of Responsibility,It is because the interface of the application is not wrong. Also the pattern does not matches an existing client to a particular interface.,Interpretor,It is because in this pattern the client knows which type of object he wants to create.,Yes. Since the class has a consistent interface and a Well formed class has consistent interface. The interface is consistent because the setters/getters of both the instance variables are having same structure.,0<= hour; hour <= 23; 0<= minute; minute <= 59,Length of array B must be same as that of array A. Array A and B should not be empty.,Yes. the method says it copies the values in target array but actually it replaces them.,"The old values of the array B are replaced with the values of Array A in the same order as in array A. Array A remains as it is,",Array A could be empty. Array B can be any of any size and with any number of elements.,Item class must have the responsibility of comparing two items because it is item object which is having the access to the product Id's and according to the expert pattern - The object that contains the necessary data to perform a task should be the object that manipulates the data.or we can have a third comparator class which can do the task of comparing two items. It helps us to provide a better separation of functionality.,Because o1 and o2 are references and not the actual objects. So when o1 is set to null doesn't mean that the object to which it was pointing has become null. In java object is not dead (garbage collected) till some one is pointing at it. Ans we can see that still o2 is pointing to the object so it'll not give null pointer exception as said above.,disadv - duplication since the location object will also having the information. (DRY violated). Bad seperation of responsibility.Low cohesion.Also if we want to find all the people born at specific location we need to go through all the objects.Adv - it's easy to get the location of a specific person.,Adv -  easy to get all the people for a particular locationDisadv - Low cohesion.HIgh coupling.Bad seperation of responsibility.DRY not followed.,Disadv - 1. extra code.2. DRY violated since it is storing complete objects.Adv - Good seperation of responsibilty.,"Since USMoney is immutable we need to make all the instance variables as private, all the methods as final and remove the getter/setter from the USMoney class.",No. Since with USMoney class we are not trying to represent mixed money so there is no need to have additional getAmount method.Also by having a single getAmount method we can easily compare the USMoney objects created in different ways i.e. by passing cents or by passing dollars and cents.,Yes. It will be used to get the amount for the objects which are created by passing dollars and cents separately so that they can be easily compared.,Because in real world money is multiplied or divided by a factor instead of other money object. But money is always added and subtracted by other money objects. Apart from that the specifications also want us to do it in that way.,For this we can have a third class which can take care of displaying the money in appropriate form. Our money class can use this third class to display money.,"The advantages are 1. If you never use the value, you don't pay for it.2. Initialization costs can be more spread out by not initializing everything at once.3. In some cases, startup appears to be faster.4. Ability to delay until needed information is available.",1. Code needed to check to see if it is time to initialize the value each time it is used.2. Time spent in the above code each time the value is used.3. Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.4. More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.,It is because if they are publicly available then we will loose the instantiation control and so do the one of the reason of using singleton.,In this client has to take care of iterating over the collection and also it violates the goal of iterators of providing a uniform way of access to all the collections. It is because now a client can access the collection in any random order he wants instead of having a fixed sequential access.,I - ObserverExecutive - Publisher,Third One. Because in third one we have subscribed to the event and we'll be notified when the event occurs (i.e. when the executive will be free),Push Model. It is because the buttons pass the information whenever an event/click occurs and Actionlistenrs receive the information irrespective of the fact they want it or not since they are registered for it.,"Push will be better suited when we want to perform actions and tasks i.e. in places where user actions are to be translated to a specific method in the Controller part, which will ?push? the output to the View.While pull should be used in programs that handle request to show some kind of data."
,,,91,2,0,2,2,1,2,0,0,2,1,2,0,2,0,2,1,4,2,4,2,1,5,3,3,3,3,2,4,2,2,4,3,3,2,6,2,4,4,4
,,,,strategy pattern,Decorative pattern,Composite pattern,Adapter pattern,Flyweight pattern,Template pattern.,Prototype pattern.,Delegation pattern. a the sort is assigning its tasks to others to perform.,It is not adapter pattern cause in adapter pattern we convert the interface into another interface the client wants. And here we are not performing any kind of interface conversion to suit the client.,Factory pattern. Cause the subclasses are deciding which class to instantiate.,Prototype pattern is used when we want to create clones of the object. here each document is different and not of the same object type.,"Mediator pattern: this is because the client acts as a mediator between database ,model and element.",It is not adapter pattern cause in adapter pattern we convert the interface into another interface the client wants. And here we are not performing any kind of interface conversion to suit the client.,this is chain of responsibility pattern cause more than one object is given a chance to handle the request.,In abstract factory we provide an interface for of related objects. These objects in above example  are not related in anyways. each object has to be handled in a separate way.,The above class is not well formed. this is because there is no way to check if the time displayed by this class is valid or not. if it has some instance variable that recorded standard time we could check the vlaue of it against that instace variable and get to know if value displayed is right and hence the class would be well formed.,a class invariant for this would be statement of equality if we had an instance varibale that had the standard 24 hour clock time and compare it with the time given by this Time object.,the preconditions are@param A the integer array to be copied @param B the integer array into which the values will be copiedThe array B must have the same length as array A.,here the responsibility is of the client to satisfy the pre conditions.,Copies the values of array A into array B in the same order.* The old values in B are lost.,"To make the program regardless work what we should make the precondition strong.This means we should allow any size of both arrays,array a or array b either could be the one being copied or being copied into.",Class Item has the responsibility to decide if two items are the same by getting their product_id first and using that getting the quantity. If quantity greater than 1 that means the two items are the same.The expert pattern principle is used here. the object taking the data should alone be sued to handle the task.,This example is wrong because it doesn't tell how cloning an object is helping in prototype pattern. When same functionality needs to be performed and client doesn't know about the underlying interface he can use prototype design pattern. If we know the functionality being performed is similar to an existing instance we can just create a clone of it.,Advantage is using delegation here. We get the location of each person by creating object person only as we can access place of birth too.Disadvantage: Delegation makes the code dynamic which may become difficult to handle at run time.,Advantage:The location object does what it has to that is keep track of location of each person object.Disadvantage:As it is a collection we need to find the person id and get the location for that person id.,Advantage: All information to persons and their locations is available in one table. Disadvantage: This however is not good encapsulation as a third object is doing work what the person and location object are suppose to do.,for this we can use singleton pattern. This pattern allows to create only one instance of the class.,yes it should be returned in a way that is more vast data type. It is best to use interfaces as these give a widest possible type.,Here the getAmount is not needed as it is always going to be $1.there is no chanage in the amount.,We cannot multiply and divide USMoney object as adding two different datatypes is logically wrong and it cannot be spotted by the compiler so we have to take care it is of type USMoney. However for divide and multiply we can do it in doubles as it will throw error if incompatible types do this operation.,"We could use decorator pattern for representing currency-specific differences.This is because, if we have different subclasses allowing to attach responsibilities to the object dynamically. Depending on the requirement there are alternatives for subclassing to provide the functionality.",1.Suppose there is an abstract class common to two objects.Suppose it has an instance variable that is initialized and never used. Hence it is initialized lazily.2. As stated lazy initialization helps to postpone the creation of instance to a much later stage.,"1. there is a time penalty associated with each access.2.Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.",since they are initialized lazily it is better to make them private so that there is no error caused by using these variables by anybody outside the class.,"It doesn't follow principle of least surprise as iterator does. Iterator doesn't find size of collection ,it goes on moving ahead till the end reaches. Hence at times we can reach into an infinite loop.",Observer is the 3 choices and the subject is the executive.,Leave a message asking the executive to call you back when she is free is closest to observer pattern. this is because it tells the publisher that I have subscribed for you and whenever u make any change please notify it to me.,actionlistener is  a pull model as it polls information to the subject.,"a better example is weather forecast. Suppose different subscribers are there like who wants to display currentConditions(),statisticsDisplay() etc. The publisher will push information about temp(),humidity() etc which will be pulled by the subscribers."
,,,80,2,2,2,2,2,0,1,0,2,1,2,1,2,0,2,3,0,2,2,2,2,5,2,1,3,2,3,2,1,2,5,3,3,2,6,1,4,1,2
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy pattern,Template Method,Composite,Adapter pattern,Singleton pattern,Bridge pattern,Template pattern,Command,The intent of Adapter is converting an interface to another so that there is communication between the different interfaces. And no interface is converted here in this example.,Abstract Factory pattern,Because:1. Prototype pattern allows to make instances by copying existing instances. Here there is no copying of existing instances.2. Client is aware of the type.,Decorator,The intent of Adapter is converting an interface to another. And no interface is converted here in this example.,Chain of responsibilties,Because Abstract factories provides interface to create families of related or dependent products and here every command is independent. Chain of responsibilties is the most appropriate one as it can understand which command is fired and accordingly let a state handle the request.,No. The instances can be corrupted very easily because they have public modifiers and these modifiers are not checking for the state of the object before they are modified.The modifiers(setters) must check if the hour and minute variable values will be consistent as per the requirements and that the class invariants are met. Currently there are no checks or assertions in place and therefore there is a huge likelihood that these instance variables may have invalid values.,The class invariant  ishour <= 24 and hour >=0and minutes<=60 and minutes>=0,1. A and B must be integer arrays.2. Size of array B must be the same as size of array A.,"Yes, there are different cases of the inputs which the method has not specified in its documentation. Some cases are:1. What if one of them is null and then other array is not null.2. What if both are null. How should the methods behave in these scenarios?3. What is A is an array but not an integer array?Also how these incorrect cases must be handled is not explained.",Array B must have the same data and size as Array A in the same order.,"We must implement exception-throwing behavior. For that we should understand which cases result in error and handle them so that the method does not fail.For example, if one of the arrays is null, we should throw an exception and catch it to display a proper error message so that the program proceeds with the next set of inputs.","Class ShoppingCart should have the responsibility of checking whether same items are added to the shopping cart because:1. According to the Expert pattern, ""The object that contains the necessary data to perform a task should be the objectthat performs the task"".2. The Shopping cart class will have a list of items, so it has the data. Therefore it is its responsibility to check it there is already an item and if so then increment the counter of that item.",MyClass is not set to implement Cloneable.,"Advantages:1. By using delegation, it is easy to associate location of birth to the person.2. This person object is cohesive because it contains the place of birth as a component.Disadvantage:1. Object has 2 responsibilities to maintain which is Person and Location data.",Advantages: Can query easily by the birth place to get list of persons.DisadvantagesDisadvantage: Each Location object will have a list of Person objects.,Advantages:1. Loosely coupled design.Disadvantages:1. The design is not cohesive.2. The object has 2 responsibilities: to maintain person information and then location information.,"We have to have one extra long instance variable for the count and one long variable for the extra cents and this will represent the total amount. So if an object with value $10.10 is created, the instance variable 'count' will be initialized to 10 and the cents field will be initialized to 10.",The getAmount() will return a long value corresponding to the total cents which is 100*value + cents.,Its used for converting the amount into cents and returning it.,"Because multiplying and dividing by a double will still yield a USMoney Object. Moreover, to divide and multiple we will have to get the value of the divisor using getAmount() and then do the operation.",1. We create a different currency class for the third form and extend it from java.util.Currency. 2. We override the toString() to suit our needs (to return a Stringusing a comma instead of a period or putting the symbol at the end).3. When we create an object we use subtyping so that the overriden method is chosen through polymorphism.,"1. If the object has expensive creation operation, the initialization of the instance variables with the actual values is delayed till the time we absolutely need it.2. Optimizes performance and hence optimizes the object creation time.3. Optimizes memory usage.4. Immutable objects can be initialized using this scheme by using the default value.","1. During multithreading, if two threads enter the critical section which multiple copies of the instance variable can get created.2. We have to take care that it is thread safe.","We would want that the instance variables be modified inside the class itself when there is need, so that there is only one source of modifying them. Making the instance variables public will only expose them to the external objects and in this case they may be initialized even before there is a need.",Disadvantage is that we have to make calls to the get method everytime we want a new object. We have lost the abstraction in the sense that we are now accessing the concrete object C which is a collection. Here the implementation will changes everytime the type of collection changes.,Observer: YouSubject: executive,"Leave a message asking the executive to call you back when she is free corresponds most closely to the observer pattern.In this case, the third case ""Leave a message asking the executive to call you back when she is free"" corresponds most closely to the observer pattern because ""Leave a message"" means you have subscribed to the executive. The executive will call me back (notify me) on an event which is when she is free.",ActionListener uses push model because it notifies all the listeners(its pushes its state on the observers) rather than exposing its public getter methods which the listeners(observes) can access.,Push method is better suited when the subject is not exposing its internal state. Therefore it notifies in case of a change in its state.Pull method is better suited in cases where the observes want to directly access the internal state by constantly checking the state of the subject.
,,,84,2,1,2,2,1,2,0,0,2,2,2,0,2,0,1,3,2,2,4,2,2,2,0,3,3,3,1,3,1,1,4,3,3,3,6,2,4,4,4
,,,,Strategy Pattern. Based on the function under which area is to be calculated we can decide on our strategy.,Decorator. We add or remove headers and footers to system as we want. Decorator facilitates easy adding and removing of behavior.,Composite.,Adapter,Singleton,Flyweight,Memento,The above pattern resembles the Strategy pattern. The sort method decides the strategy of actions to be performed(swapping or not swapping) from the outOfOrder methods output.,Adapter is used when there are compatibility issues. In this scenario I am not seeing any conflicts. I agree that sort method is unaware of the kind of object being passed to it but Adapter pattern is just required to solve the above compatiblity issue but here the sort method performs action based on certain strategy.,This a Facade. The DocumentCreator provides a unified interface to create different types of files.,Prototype pattern is used when you know there are fiixed number of prototypes you want to clone. But here the number of prototype is not always fixed. Moreover the DocumentCreator mentioned above provides interfaces to provide some functionality all in one place. So it is a Facade rather than prototype.,"This is Template Method design pattern. You would provide a template method where you would specify the order in which client class operate( first open database connection, then getting the model and finally using the model to get the Element)","This cannot be adapter for sure because for the given scenario, it doesnt talk of having multiple kind of connection or model or element type. If that was the case we would need adapter to adapt to a particular type. Also situation demand to have a template kind of thing for doing sequence of steps and hence Template Method would be best suited.","This can be observer and Factory Method pattern. Observer because the processor waits for action to be performed to react to it. Factory Method because we know which subclasses are going to instantiate their objects. Since the question says existing one can also be used, it can also be made a Singleton pattern.","It cannot be a abstract factory because it is clearly mentioned we dont want factory object whose type we dont know., The question clearly mentions we know what kind of dialog box needs to be opened.","The class described above has instance variables. Now since the state of instance value can be changed by setter methods which are public, we need to ensure that setter methods for hour and minutes don't leave the class in not a well formed state. So we need to have assertion before the setter method terminates in order to ensure that classes are well formed.",The class invariant for this class is  - public void setHour(int hour){this.hour = hour;assert isWellformed(hour);}public void setMinutes(int minutes){this.minutes = minutes;assert isWellformed(minutes);}boolean isWellformed(int a){if (a!=null)    return true;return false;},#NAME?,The behavior of the method doesnt provide sufficient information for the case when the two array are of different length. Information should be provided whether to throw a exception or proceed with the algorithm.,"If executed properly, values of array A are copied in array BThe copying of values from A to B is in same order.Old values of array B are lost.",Removing the precondition that the two arrays are integer array would allow the method to work no matter what it was passed.,We can have a _quantity as a singleton instance for each item. It is initialized to 0 when Item class is initiailized. Now since it has only instance it can keep track of items being added.To decide the whether to increase or decrease the quantity variable we can make a use of strategy which determines whether to add the item as new type of item or increase the _quantity since there is already a item of that product_idSo I think we can combine singleton and strategy pattern.,"Cloning an object and then manipulating it changes the value in cloned object too! In the above example, specially in the second part, they say o2 = o1.clone(); o1=null; followed by o2.anymethod(); and they say it does not give exception. This is wrong as making o1 null will make o2 null as well.",Its more tightly coupled. If Location name changes then you need to modify all person object which use that location,Mapping of location object to multiple person object is not desirable as handling the relationship wont be done efficiently,Since both the person objects and location objects are loosely coupled changes in any one of them or both doesnt affect other objects.,"We can make use of singleton pattern, which implies that only one instance of class is ever created. Since we want only one object ever created we can make use of Singleton pattern. To do this we can make the money object private and provide a accessor method in the class which can initialize this object. Once initialized it cannot be reinitialized until the program runs to completion and thus serve our purpose.",The getAmount() returns the number of cents. Now it is possible that we always dont require the amount to be in cents. The implementation of getAmount should be flexible such that it can return the amount in generic form to a caller of that function and then that caller can display the amount in formatted form.The advantage of getAmount returning just number of cents is that it makes the implementation of the function easy. Disadvantage is that we may want the return value to be of any form and hence always returning in terms of cent is not feasible in such case.,In case we have only one class representing both mixed and simple money class then we can return the value of the instance variable by using some methods like the convertTo( ) which returns an instance of a class with appropriate format. as was done when we only implemented one class MixedMoney class as implementation of Currency interface and wrote a CurrencyConverter helper to convert between mixed and simple Money.,Multiplication and division may not necessarily return the values in the format required by the object. So we need to perform those two operation using plain doubles before converting them back to USMoney objects.,This is a classic example of the Decorator pattern. We can have methods to add various properties to a basic money object. Then as and when is required we can implement a decorator interface and decorate the money object as required to our needs.,One doesnt create an instance of class until it is required. this saves the memory in cases we dont not require to instantiate a class thus saving time and money.,"The main disadvantage of lazy initialization is the time penalty associated with each access of the variable caused by the test which checks for it value(null or not)Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.","To ensure thread safety of instance variable, it is better not to make the instance variable public. When we do a lazy initialization we need to make sure only members of the class they are instance can change its value(whenever requried). So we dont generally make these intance variable public.","Iterator pattern in itself is more modular. Also it decouples the iteration logic from the collection so that we dont need to worry of what kind of collection we are iterating over. In the above example, we are writing code to implementation rather than interface which violates one of the design principle. Hence I think its better to have a generic get(int) function that is capable of returning any kind data it iterates over.","The caller (in this case, I am) the observer since I poll for the executive (Subject) to get his attention. The executive would be the subject since we are waiting for his attention.","I think - 'Call and be put on hold until the executive is free' is more closely related to Observer because you are awaiting for the executive to respond so that you can act on it.The second scenario is not as related to observer pattern as in observer pattern, the observer notifies the listener only when the publisher wants to publish information.In the third scenario, I leave a message for a callback. In observer pattern, the observer never asks the publisher to publish.",Since the interface has a method a actionperformed it notifies of actionEvent e to the listener. hence it uses a push model.,WeatherData example where the weather station pushes the information to the device and the device uses pull model to poll the station for the data.
,,,80,2,2,2,2,1,0,2,2,2,1,0,0,2,0,2,3,0,2,4,2,1,0,2,2,1,2,3,4,1,1,7,3,3,3,6,2,2,4,2
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Template method pattern,Decorator,Composite Pattern,Adapter pattern,Singleton Pattern,Strategy pattern,Memento design pattern,It is a template Method pattern,Because we do not require to alter an interface to provide communication with another interface. That is what adapter does.,It is a factory method pattern.,This is because we are not cloning a particular object and returning that object but  we are creating a whole new object as per the client requirement,it is a chain of responsibility pattern,"This is because it is not said that the classes cannot communicate with each other due to differences in their codebase, framework etc. So no need to implement an adapter interface to communicate between them,",It is a command pattern,It is not abstract factory because it does not defines any interface for creating a set of conrete classes. Here some classes are instantiated just that we need to check the command and reopen them like a dialog box.,"No. Because when we set the the hour and the minutes of  the Time class then it represents the time at that particular state. But when we return the values of hours and minutes to get the actual time it does not show the actual time. So, basically the user would get two different values when it check this time and the system time.",Equality of value of the System Time and the we get from the Time object (ie. hours and minutes),1) The lengths of Array A and Array B must be the same. 2) Both the array A and array B must be valid integer arrays.,"1) The statement that is copies in same order is ambiguous. What exactly is the same order. No information is provided regarding the order. 2) In case if any of the arrays are empty, then what is to be done3) What happens in multithreaded application if the method is not thread safe4) What if lengths of two arrays are not same as specified.",1) Array A must be equal to array B 2) The values of array B should be overwritten,1) The condition to check if the two arrays are of equal length has to be included  in the method.2) Comparing the length of two arrays by passing their length in the function and comparing them,The item class should be responsible for deciding whether two items are same or not. In this way we are following the Expert Pattern as all the checking will be done in Item class using its product Id and no information of any other object or class is required. If we had chosen ShoppingCart class then it would have required the information of Item's product Id to check thus referring the Item class.,This example is wring firstly because we wont get the null pointer exception as the Object o2 will be referencing to the memory location which Object o1 initially referenced.,Adv-1) easy to extract the birth place given a person as each person has only one locationDisadv-1) Finding the birth place given a person is easy but finding the person given a location is not easy.2)Many persons might have same birth place so there is a chance of duplicate information,"Adv-1) If we are given a location, the easy to find the people having birthplace thereDisadv-1) There can be a case where many people will have the same location and hence it need to store references of millions of objects",Adv-1) Here the person and location object is initialized exactly once hence minimum duplicate information and the table keeps track of the references.2) Adding new person and location is comparatively easy.3) Division of responsibilities among the objects is advantages here.disadv1) We require additional objects unnecessarily.2) It will be difficult to setup the table,"We can use SIngleton pattern here to create Money variable of value $1. So, it returns $1 when we call getMoney method. (where money is the instance, so getMoney equivalent to getInstance and hence if Money is null, initialize it to $1)",1) Amount can be returned as dollars and cents which can be handled as two integers but requires us to handle two values each time.2) Amount can be returned as Amount object which encapsulates the dollars and cents but again additional memory required for that object.3) Amount can be returned,1) getAmount is required if we want to compare different amounts like 5 dollars is equal to 500 cents. Hence getAmount will give us 500 cents in both getAmount calls which can be used to compare and see if they are equal. 2) If we had getDollars and getCents method then we would not have required the getAmount in case of USMoney.,1) Multiply and divide multiplies and divides by given factors while plus and minus uses the money values. 2) Also handling the values will be difficult as the multiply and divide would require additional calculation of dollars and cents.,"We need to extend the currency class to provide new class say NewCurrency class. It will have a constructor that will take information like symbol and number of fractional digits but will also take another information like representation(which is a string array) that takes way of representing.eg String[] rep = {""SYM"",""AMT"","".""} (defines symbol first, amount with period)    String[] rep = {""AMT"",,""SYM"","",""} (defines amount first, then sysmbol with comma)       Hence we can override display method that checks and representation string array and displays accordingly.","1) To have instance created on first call to Instance() method.2) To define the initialization order for static variables. 3) useful in JIT process, which initializes  static property when (and only when) any method uses this static property. If the property is not used, then the instance is not created.","1) This approach is harmful for multithreaded applications, where two threads can enter the control block at same time creating two instances of member variable. 2) It is not good for performance if additional checks are required to make it thread-safe",This is because any subclass of the Singleton class can use that public variable.The getinstance method will have no use as the variable can be obtained through subclasses.,"1) It exposes the internal implementation of the collection. 2) If I need to switch from one collection to another like from arraylist to some another collection I need to rewrite the code that used get().3) So, code is geared towards the data structure or the collection while iterator has the hasNext() functions that take care of traversing of whichever collection.4) Here the client of the code will have to know if we changed the underlying collection.",The subject(publisher) is the executive and I am the observer.,Third option corresponds closely to the Observer pattern. This is because I have to subscribe to the executive and when the executive is free she notifies me through the a call back when she is free. So the  state change is executive being free and then I get notified through a call back.,"The ActionListener interface uses a push model. They just need to register to the Subject and does not require polling the subject for the information. Here, when the information arrives (passed through clicking) then the subject passes the information to the registered observers. So, the clicking will involve one or any observer. So the observer does not necessarily need the information. Hence the push model.",1)  It can be used in I/O operations where devices are checked by polling if they are ready for the I/) operation.2)  Polling is used in Computer network polling where a client server or Network Hub polls each computer for data. Data can only be sent when the particular computer is polled.3) Pushing can be used in course registration system where students register for a course if it is not available and get notified as soon as it is available.
,,,90.5,0,2,2,2,1,0,2,2,2,1,2,0,2,0,2,1,0,2,4,2,2,5,3,3,3,3,3,4,2,2,4,3,3,1.5,6,2,4,4,4
,,,,Strategy pattern.,Builder pattern to build tickets based on the countries,Composite pattern,Adapter pattern,Singleton pattern,Bridge pattern to implement JVM on different OSes.,Prototype pattern.,"Its a Template pattern.Here we can see that the sort() method is already defined. So, it always does Bubble sort the same way as it always does. So, the sort() acts like a template method here.outOfOrder() method is like a hook which determines whether to swap or not. It might also be viewed as Bridge interface as it will bubble sort an array of any objects. So, it separated the representation/abstraction from the implementation.","Its not an adapter because 1. The hook method outOfOrder()  that you provided was not an adapter to any existing interface.2. You didn't modify any interface which was like non-compatible.3. You didn't adapat it to any specific interface that was needed like, sorting an array of Double objects, etc.","This is definitely ""Abstract Factory"" pattern.Here ""DocumentCreator "" is the Abstract factory which creates abstract products like ""Letter"" & ""Resume"". FancyDocumentCreator or modernDocumentCreator are the concrete factories which will create Fancy Letters, Resumes  and modern Letterns, Resumes as the concrete products respectively.",This is not a Prototype because1. You don't clone the existing concrete products & instead return a new concrete product everytime.2. The concrete factories actually create these appropriate concrete products for you & not a registry which will clone them for you.,"Its ""Chain of Responsibility"" pattern.Here, we can see that the responsibility of ""information retrieval"" is transferred over from the Database to a Model to an Element & then the information is retireved. So, a single request is handled by linking the handlers (the above 3) together.",Its not an Adapter because1. you are calling the next handler in the chain to do the job for you instead of modifying some incompatible interface.2. There was no incompatible interface to deal with in the first place.,This can be Flyweight pattern. Here the already existing dialog boxes are reused instead of creating a new one everytime. The data that is typed in the box is the extrinsic data in this case.(find & replace boxes).,"This is not an abstract factory because you are not creating a new dialog box everytime the command is executed. Instead, you are using the existing object(shared representation) like the way Flyweight pattern does.","No the above class is not well formed because the class invariants can be easily violated here. No checking is done to preserve the invariants.For instance, we see that the ""hour"" & ""minutes"" fields can be set to any integer value(say -ve or hour>=24 or minutes >=60)  using the public setter method. So, at the end of public methods setHour() & setMinutes(), no checking is done to ensure the class invariant(below) is violated.",The time should never exceed 24 hrs & never be less than 0. i.e. 0<=hour<=24  & 0<=minutes<=59,"1.  B must be of same length/size as the A.2.  A actually contains the array of integers & not anything else.3. A is not null, so is B.","Yes. Since B may be an existing array, it might have junk values. Also, it might have a length different becuase of the existing junk values.So, although, A ,might be copied to B, B may have some values from previous computation at the end of the list. So, you have to take care that these values are terminated & size id computed properly.",1. B should have the same number of elements & the same elements as A.2. Ordering of the elements should be the same in both the arrays.,"You should use a tolerant approach.Basically you can add assertions before & after the copying operations in the methods to ensure that the invariants are preserved.i.e make sure the preconditions are preserved before performing the copying operations & the postconditions are met after the operation is performed & before the method call returns back.In this case, we might add assertions to do check the pre & post conditions.","The Item class should have the responsibility of checking the equality of items. We can simply override the equals & the hashcode methods of the Object in Java to check for equality of the items.This may be classified as ""EXPERT pattern"" as we see that the items are the ones who have the data & hance they should own the responsibility of checking the equality.","1.By default, classes in Java do not support cloning; the default implementation of the clone() method throws a CloneNotSupportedException. Therefore, we should override implementation of the clone() method. 2.Since the default implementation of Object.clone only performs a shallow copy, classes must also override clone to provide a custom implementation when a deep copy is desired.","Advantages:1. You can have the Location object store individual parts of the entire location like street name, apartment number, zip code, etc.2. The Location object can now have its class invariants to check for accuracy & integrity of the data.Disadvantages:1.The Person object may not have appropriate access privileges to access the required fields in the Location object.2. Extra method calls may have to be made to the Location object adding a bit of performance overhead.3. If a person has only one location, only one location object is created & you may end up wasting space to create a location object for every such person.","Advantages:1. You can aggregate Persons living in a particular location which is good if you want to gather aggregation statistics or apply some operation on the aggregation.2. For persons having the same location, they share the same location object, thus saving lots of space.Disadvantages:1. Finding the location in which a particular person resides might be hard.","Advantages:1. This might be a good design because we can design the table to share representations of persons & locations having same values.(like Flyweight pattern)2. Table is a good structure to visualize the model.Disadvantages:1.Looking up in the table might be hard. Indexing can be used to get around it.2.Concurrency can be an issue here. So, granular access might be needed which can get complicated.","You can use Singleton pattern to achieve just one instance of a particular amount in Java. Therefore, make the USMoney class as a singleton whenever you create an amount.","You could return the money in terms of amount of dollars & the cents by sending the USMoney object itself. May be we might want to present it a Double or BigDecimal type in java & view it as an amount with digits after the decimal point as the cents.Advantages:1. The returned amount by getAmount() can be represented(Dollar+Cents) more user friendly provided we have getters to access the dollars & cents from the returned USMoney object.2. The caller/client might want to do arithmeatic on the amount himself instead of using the USMoney's methods. SO, that why return it as Double so that its easier to perform any arithematic operations. Disavatages:1.Performing arithematic on the returned value(Dollar+Cents) from getAmoutn() would be hard. You might have to translate it to one common format(like cents) to do the arithematic on it.","Yes. If the client wants to perform an arithematic on the Amount himself rather than using the methods of USMoney class to perform the arithmeatic. Also, the client might want to do a scalar operation on that to. So, he might need getAmount() method.","adding & subtracting won't cause the precision(number of digits after the decimal point) of the USMoney(amount to change). It will be carried over & the result can be still represented in USMoney type.When we multiply or divide, the precision of the amount might change. Also, we might want to multiply or divide the amount by a fraction, which might give the amount as recurring decimals. Hence to avoid this, we mulitply & divide by a double & then truncate/round off the final amount & then reperesent it as a USMoney object.","In Java, you can change the separator either by setting a locale or using the DecimalFormatSymbols for formatting the number.Also, you can use the BigDecimal class can handle any number no matter how large it is (within the limitations of your computer's memory). BigDecimal stores numbers in an array. Each entry in the array represents a digit.","1.Lazy Initialization is a performance optimization where you defer (potentially expensive) object creation until just before you actually need it.E.g.: Not create a database connection up front, but only just before you need to get data from the database.2.Users don't have to pay the initialization time for features they will not use.(very useful in Cloud Computing because a user can save money.)3.Avoid long start up times in some Web applications.","1. For creating simple objects, Lazy initialization is not a good approach. 2. We can see that the cost of lazy initialization will be amortized over the run time f the program rather than condensing it at the beginning. This may not be desirable for all the applications.3. If the applications runs out of memory & you have lazily initialized an object, the object may never get created & cause undesirable exceptions.4.Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.5.More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.","If the instance variable is public, then the user can access it anytime without notification to the object. In such cases, if the object itself is not created/present, then it might have undesirable effects.","1. Since your getting the ith element of the Collection, the collection has to actually search the ith indexed element & return it. Requesting an item in the i-th place requires i operations to be done to traverse the list of nodes.  If its an array, then random access is faster. But you may not be able to store large data sets(like billion entries) in an array, as it wouldn't hold up in the memory.2. Iterator gives you a way to access the entire Collection without access to the representation.3. For concurrent traversals, this is not a good design. Say if 10 methods are trying to get the same indexed object, then they all have to be synchronized & have to wait on one another. 4. Iterators can do things like be fail-fast, so that if there is a concurrent modification to the structure you are accessing, you will know about it.",Executive is the Subject.you/Caller is the Observer,"The third option ""Leave a message asking the executive to call you back when she is free.""This step is like the observer is registering with the subject to receive notifications when the subject changes its state.","It uses the PUSH model.We can see that the JButton is our Subject & the listeners are our Observers. Whenever the JButton is clicked, we see that it notifies all the listeners by calling their actionPerformed() methods. So, the Subject is notifying all its observers/subscribers. Hence its the PUSH model.","When PUSH model should be used ?1.Observers subscribe to a single event type therefore require one single type of event data.2.The Push model ensures that Observers receive exactly the information they require.3.Observers are not coupled to an external e.g. state-querying interface & unlike PULL model, observers doesn't need to know where to look for when an event occurs e.g. the Subject. 4.Observers do not need to work hard to figure out what information changed.When PULL method should be used ?1.Observers have the liberty of reaching for the data which makes sense for them.2.You may want to reduce the traffic from Subject to the Observer because may be the observer doesn't need to get the updates frequently. E.g. Weather data app in your mobile. The updates are not that important. If we need the data, we can always ask for it."
,,,99,2,0,2,2,1,2,1,2,2,2,2,0,2,0,2,3,3,2,4,2,2,5,4,3,3,3,3,4,2,3,2,3,3,3,6,2,4,4,4
,,,,Strategy Pattern.,Template Pattern can be used with the hook method.,Composite pattern.,Adapter Pattern.,Flyweight Pattern.,Bridge Pattern.,Memento Pattern.,Bridge Pattern.,"Adapter pattern converts the interface of a class into another interface clients expect and lets the classes work together because of compatible interfaces. In this case, an abstraction is decoupled  from its implementation so that the two can vary without knowing the kind of objects.",Template Pattern.,"In this scenario, skeleton of an algorithm is defined, deferring some steps to subclasses.Lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure. Hence this does not correspond to the prototype pattern",Chain of Responsibilty.,The sender sends a request to its receiver by giving more than one object to handle the request. Here the receiving objects are chained and the request is passed along the chain until an object handles it.,Observer Pattern.,"The given scenario depicts a behavioral change rather than constructional. And in this case the Word processor needs to create dialog box, which just changes the current behavior. Hence the Abstract factory doesnot apply.","The above class is not well formed since the public methods of the class keeps the object in a well formed state but the constructor does not. The public methods getHour(), setHour(int hour), getMinutes(), setMinutes(int minutes) does the operations as required but the constructor does not initialize the instance variables.",private boolean test() {  if( (0<=hour && hour < 24) && invariant 0<=min && min <=59) @*/ //class invariant   return true; else return false;    }assert test();,Preconditions: A.length = B.length;  // size of array A and B should be same,The ambiguity in the behavior of the method as specified will be that the old values will be lost in the B array. this is because even if the empty array of same size is passes then the eventual result will be the same copy operation.,PostConditions:B[new_array] = A[array] // values will be equal after copy methodB[old_array] != B[new_array]  // Old values in B will not be same as new values.,Specifying the precondition to be false will make the method work irrespective of what ever is passed.,"Based upon the definition of the Expert pattern which states ""The object that contains the necessary data to perform a task should be the object that performs the task"", it should be the responsibility of the deciding whether the two items are same lies with ShoppingCart class. Since the Item class is used for having the items description, ShoppingCart that takes care of adding the item should be find the duplicates and add it to the number of items.","As per the example, in the second part clone copies all the values in to a new instance variable and hence no exception occurs. But since both the instances are of the same class type, there is no way a prototype pattern is implemented in the above example.",Advantages:Contained objects are accessed by the containing class solely through theirinterfaces.Good encapsulation.Fewer implementation dependencies.Disadvantges: Resulting systems tend to have more objects Interfaces must be carefully defined in order to use many different objects as composition block,"Using references, we could have exactly one Location object for each person, which would be independent of how many ever Location exist.",Advantages:Good encapsulation.Fewer implementation dependencies.Disadvantages: Resulting systems tend to have more objects,The USMoney class can be designed so that only one object is ever created that represents the value $1 by making sure that once the,"The getAmount() method returns the amount in cents as long value, but the USMoney class has constructors that initializes the class using two different constructors. So, there must be a variatoin that returns the value as USMoney object. Adv: Giving flexibiltiy for getting the way it is represented.","The getAmount method is needed in the USMoney class. It'd be useful in a way that it represents the value it holds, that it can be useful in computation.","Since the addition and subtraction requires the check that it can be performed between the same two types, but in the case of the multiply and divide the operation is done on the same object.",If a country wants to display a currency in a third format then the USMoney class can get the format by which it has to display the country's currency. Since there is going to be a variation from the initial way of displaying then the implementation can be done in the  toString method based on the display format.,"The advantages of lazy initialization are that users don't have to pay the initialization time for features they will not use. Suppose you were to initialize every component of your application up front. This could create a potentially long start time - users would have to wait dozens of seconds or minutes before your application is ready to use. They're waiting on and paying for initialization of features they may never use or not use right away.The advantages are :If you never use the value, you don't pay for it.Initialization costs can be more spread out by not initializing everything at once.In some cases, startup appears to be faster.Ability to delay until needed information is available.","The main disadvantage of lazy initialization is the time penalty associated with each access of the variable caused by the Nil test. Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.The disadvantages are :Code needed to check to see if it is time to initialize the value each time it is used.Time spent in the above code each time the value is used.Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.",There should be no direct access of the instance variable. Direct access to the instance variable would bypass the 'initialize on first access' code.,"This design has the advantage of iterators without having to create separate Iterator objects, but loses the elegance of exposing the representation and the implementation of the object.","The Observer in this scenario is the executive, and the person trying to contact the executive will be the publisher.","The third choice closely resembles the observer pattern since the problem intent is similar to that of the observer pattern, where there is a publisher in this case being the person contacting the executive publishes the message to the listener, the executive in a company.","The ActionListener interface uses the push model of communication. Since the listeners register with the interface, when ever the button is clicked the information is sent to the listeners rather than the listeners polling for the information.","In the Push model Observers subscribe to a single event type therefore require one single type of event data . The Push model is more general than the Pull model and completely decouples the Observers from the Subject. The Push model ensures that Observers receive exactly the information they requireObservers are not coupled to an external  interface.Observers do not need to work hard to figure out what information changed.Self-consistent state is guaranteed at all times. Since Observers receive a snapshot of the exact state at the moment of the notification, there is no risk that the Observers may get a wrong view of the state.If in case the message delivery is important than the coupling then the pull request is of more fitting model."
,,,82.5,2,1,2,2,2,2,2,0,2,0,0,0,0,0,2,3,4,2,4,2,1,2,3,1,1,3,3,4,2,2,5,3,3,1.5,6,0,3,4,3
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,strategy pattern,template method,composite pattern,adapter pattern,singleton pattern,mediator pattern,visitor pattern,mediator,"Adapter is used when we have the right data and behavior but the wrong interface. Clearly, this is not the case here and so not adapter",template method,there is no sub classing in prototype. It is done through delegation in prototype.,chain of responsibility,"There is no reference to an interface we need to code to here. Thus, it is not adapter",observer,"Abstract factory is used to create a new implementation of a factory interface. Each of this implementation knows how to create different kinds of objects. However, in this description, the editor has to know what to bring up when what is clicked","The methods does not check for the class invariants before each method is returned. This makes the class not well formed. If we have a boolean method which returns true if the classs invariants are satisified and pre conditions to ensure that the user inputs are valid, then we can say it is well formed.",hour < 24the hour should always be a number less than 24minutes<60the minutes should always be less than 60.,array B must have same length as array A.,The user should take care that the first parameter is the array to be copied and second parameter the array to which the values are copied.,the array B must have the elements in same order as array A.the old values must be lost,We can create a new array of the length of the given array in our method and then copy values into this array and return the new array to the caller.the syntax would now bepublic int[] copyArray(int[] A) { ... },"ShoppingCart class should have the responsibility of checking whether the two objects are equal or not.ShoppingCart class has the array list of the items in the cart. So, this class would have to check if the item to be added is already there or not. This can be the pre-condition in the method AddItem(); If we have the Item check this, there would be so many method calls to the Item Class which is not good. For a cart of 100 items, 100 method calls are made.","The clone method returns an object of type Object. So, typecasting is  needed to assign the generic Object reference returned from clone to a reference to a MyClass object.The clone method must be defined and the line should beo2=(MyClass) o1.clone(); will be correct.","advantage: We need not store redundant information-So DRY is followeddisadvantage: It is difficult to get information about the details of the persons belonging to a particular location. Also, the instantiation of Location object always inside Person class is difficult","Advantage: The people residing at a particular location can be easily tracked. disadvantage: Given a person, his location is difficult to tell. Everytime a new person object is created, care must be taken to add this object to the Location. Also, this does not sound O-O.","Advantage: Whenever you need the location of a particular person or the people in a specific location, you just query this third object.Disadvantage: We should remember to call the third object every time a new person is added. Also, DRY is violated.","Use singleton pattern.we should have a private getInstance(value) method. In this method, we initialize the getInstance(1) and whenevr the client tries to create a new instance of 1 dollar, this instance is returned","1. We can have float getAmountInDollars() method. This method computes the amount and returns the floating point representation of the amount.eg, if 105 is returned by getAmount, 1.05 is returned by the getAmountInDollars() method.2. Or We can have same method with a change as getAmount(Object OutputType) The client should then tell in which  format he wants the final output . We have a method Convert(). Our getAmount will call the method convert() and return the result.In the 1st method, we can call the methods directly without much worry but since the code inside is almost the same, this violates the DRY principleIn the second method, our job is done but it is not fair to ask the client what kind of output he wants because most of the clients require it in a single format.","The getAmount method returns the amount of money in cents. It can be positive or negative. It can be used for comparisions between several versions of money. i.e., 100 cents and 1 dollar should be equal. So we can use the getAmount to convert them into a single type and then compare","That does not make sense. suppose you need price of 10 mangoes and 4 apples, you multiplky price of each mango by 10 and price of each apple by 4 and then add these two. But it is not multiplication between two dollars is meaningless. So is division.","In the specific money class, after you get the symbol and number of fractional digits for your own money class, you have all the required details. implement your own display method (override it if you are extending from another class), and give it whatever look you want to. If you want to display a comma instead of period or move the symbol to the end, you are free to do because you define your own method.","We need not create an instance of the object at all if we never used it in our code. In those scenarios where whatever it is you are initializing might not be needed at all, and is expensive to initialize, (in terms of CPU cycles or resources), then implementing a lazy initializor saves that cost in those cases where the object is not required","If the object will always be required, or is relatively cheap to initialize, then there is no added benefit from a lazy initializer","Since these will be required, there is no point in making a lazy initialization. There is one instance and that will be returned whenever an instance is required.","1. In this method, you are telling the collection the element to be given. Suppose the way that the collection is to be traversed is different, e.g., in a binary tree, if you want to visit the child before you visit the sibling, you cannot implement it in this way. you are just getting the ith index but not doing what it is supposed to do.2. Also, when the requirement is such that you want to traverse the same collection twice in the same method(cross product), you need to write another implementation","Observer - me. I need to know when the executive is free. So I am the observerSubject - executive. I need the executive. So, she is the subject.","The last one.Leave a message asking the executive to call you back when she is free.Here, you need not worry about whether the executive is free or not all the time. All you need to do is to just left a message and she will hear it when shes free and then contact you.","push modelthis is because, whenever a button is clicked, all its listeners are notified . The observer just registers and waits.","Push-Suppose you are designing a painting tool with toolbar buttons say rectangle, square, ellipse. The canvas editor just registers to these and these buttons notifies the editor which has been clicked and subsequently that is drawn on the drawing pane.pull- consider the case where there are a hundred inputs in the subject and the observer is interested only in a few. Instead of sending all hundred inputs, the subject just notifies the observer minimally and the observer mines the details it needs from the subject"
,,,81,2,1,2,2,1,0,0,0,2,0,0,0,2,0,2,3,2,2,3,2,2,0,3,2,3,3,3,3,2,2,4,3,3,2,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy Pattern.,Decorator Pattern.,Composite Pattern.,Adapter Pattern.,Flyweight Pattern.,Bridge Pattern.,Prototype Pattern.,This is the Expert pattern because the messy details are extracted away into another class and the main sorting class is kept simple and only does what it is good at -- sorting.,"An  adapter is a wrapper to ensure that one class can use the facility of another class if they both are incompatible. There is no question of incompatibility here, just encapsulation of correct logic into its own class.  i.e. distribution of responsibility to the class that is good at performing that task.",This is the abstract factory pattern. The DocumentCreator is the abstract factory. 'FancyDocumentCreator' and 'modernDocumentCreator' are implementations of the abstract factory that create documents -- Letters or Resumes.,"The prototype pattern is  used to specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype. We do not want to make any copies of existing documents whose prototype is provided. Instead we want to construct documents based on which creator we posses. Hence this is abstract factory and not prototype.",This is the Chain of Responsibility pattern. Every stage in the chain processes some data and passes it along to the next element in the chain.,An  adapter is a wrapper to ensure that one class can use the facility of another class if they both are incompatible. It is very clear that each stage receives its input from the previous stage. This implies that they are compatible so we dont need adapters between them.,This is the State pattern. Based on the state of the input (depressed-key) the State changes and the corresponding logic kicks into action. Thus logic is state-dependent.,"The conditions of displaying the widow are decided at run-time and not compile time. Factories are good for generating different objects compile time. At run-time, depending on the depressed-key if we are to render different windows, then the state needs to be preserved which is why this is the state pattern. Also, factories will just 'produce' objects, but here we have to check if there is a window that is already 'open.","No. Because there is no provision to check if the setter is setting the values of the hour and minutes correctly. One will be able to set erroneous values to minutes (e.g. -ve values, value > 60 etc) and hours (e.g. -ve, > 24 etc).Also there is no display method to display the time correctly in proper format.",We could specify them in the comments as javadocs as follows:/*@invariant 0<=minutes && minutes  60; @*/ //class invariant/*@invariant 0<=hour && hour < 24; @*/ //class invariantOr we could use assert statements in the setters:public void setHour(int hour) {assert hour < 24 : hour;assert hour >= 0 : hour;this.hour = hour; }public void setMinutes(int minutes) { assert minutes < 60 : minutes;assert minutes >= 0 : minutes;this.minutes = minutes; },1) The important one is that the array B must have the same length as array A.2) Another 'implicit' precondition is that both arrays must be integers. But this is not explicitly mentioned.,"1) There is no mention of what will happen if the arrays are empty.2) There is also no explicit mention in the precondition that the arrays must be int and of the same datatype. What will happen when one is an int and another one a float or char?3) Also, there is no mention of what will happen if the arrays are null - what would happen if the null pointer is de-referenced is not mentioned.4) There is no mention that states that Array A will be left untouched (it is left to the client to implicitly assume that only B will be overwritten and not A).",1) Both arrays A and B will have the same contents.2) The contents of Both arrays  will be in the same order.3) Array B will lose its data.,1) The method should be able to dynamically allocate more memory to B if its size is lesser than A and copy A's content into it.2) If length of B greater than A then the method should be able to copy A's data into B and leave the remainder of B untouched (or clear it/ null it).3) Typecast accordingly so that an integer array can be copied into a float etc. in case A and B are of different datatype.4) Add null checks to ensure no null pointer exceptions occur.,"This an example of the Expert Pattern.The responsibility of deciding whether two Items are the same should reside in the 'class ShoppingCart' .The Item class is not concerned with 'other' items. It is only concerned with itself and the state of its data members.The Shopping cart is the one that removes, adds items to the list. Hence the onus is on the shopping cart to ensure the consistency of the list that it creates and thus keeps track of. It has the larger, more holistic view of the data (items in the cart) and thus it has the capability (and thus the expertise) to ensure that the item count is increased. Thus, this is an example of the Expert Pattern -- responsibilities should reside with the class that has the expertise to do the said task.","When we do:o2 = o1;What is copied into o2 is a reference to the object pointed to by o1. So now, o2 and o1 point to the same object in memory. When o1 is set to null, we just end up clearing the 'reference' to the object i.e. o1 no longer points to the object in memory. But o2 still does! o2.anymethod() will still work because there is still a reference to the object in memory stored in o2. The garbage collection process in java is such that, the JVM will not free up any objects in memory as long as there is an active reference to it present in the program. The active reference in our case is o2.When we do o2 = o1.clone; we get a NEW object (which will be stored in o2) the content of which is equal to the content of the object pointed to by o1. Since this a brand new object that resides in a completely different memory location compared to o1, it is unrelated to o1. So if we make o1=null; we are just losing the reference we had to the first object. The second object (returned) by clone is still active and o2.anymethod() will work just fine -- except that it is on an another object altogether not the first object that o1 initially pointed to.","Adv:1) Each person has only one place of birth so the only thing the person needs to do is have an extra instance variable. This is not too heavy on the memory requirement.2) This is a relatively clean solution. This is a form of 'Delegation' which is always a good idea.3) Given a person we can easily find out their place of birth without too much heavy-duty computation. The relevant data is easily available.Disadv:1) This creates a dependency (tight coupling) between Person and Location i.e. every time a Person is created, we need to ensure that the Location attribute is provided to it while creation.","1) Given a place (Location) we can easily find all the people (Person) who were born there by just accessing the data-structure that hold this info in the Location class.Disadv:1) This creates a dependency (tight coupling) between Person and Location i.e. every time a Person is created, we need to ensure that the corresponding Location object's collection attribute is updated accordingly.3) This is unwieldy and can lead to inconsistencies in the system if not properly updated.","Adv:1) This is a clean solution as neither Person nor Location is affected. We do not violate the Open-Closed principle. 2) This object acts as the central 'repository' where the Person and Location info is stored, so there is no confusion of what to update/where the data is stored etc.3) There is a reduced risk of breaking a Person or Location as they are no longer responsible for keeping track of the place of birth.Diadv:1) High lookup time: Since this collection has to be iterated every time we need to find out the place of birth etc. there will be a significant latency for this lookup. Hence this is not a very efficient solution.2) It would be better to store this kind of information in a Database table which is much more capable of responding to queries, and is a more persistent solution.","The USMoney class could have a class variable (static) called OneDoller which (initially null) would hold a reference to an instance of USMoney having a amount value $1.  There could be a getOneDollar() method which is similar to the getInstance() method of a singleton and this would return the the reference to the private static class variable (OneDollar). This would also perform lazy initialization if the value of OneDollar is null. There could also be a check in the setAmount() method (if present) that would check if the amount value is being set to $1 and if so then it would make the OneDollar variable point to that instance of USMoney. This way everytime a getOneDollar is performed, always the same instance is returned.","1) The amount can be returned as a Float.Adv:- It will be easier to print the amount by the client.- Manipulation easier i.e. addition etc is easy compared to having a method that adds cents and dollars separately.Diadv:- Anything after second decimal point is useless as cents cannot exceed 99, so there is wastage of memory and unwanted precision.- Need more storage capacity as floats are larger.2) The amount can be returned as two integers - one showing cents and another showing dollars.Adv:- It is easier for people to read and there is less confusion about the representation.Diasv:-Need complex addition methods that must keep track of sums in which cents exceed 100 and must hence increment the dollar value accordingly. Thus, more Complex.-Overhead of maintaining two variables which can lead to inconsistency and is cumbersome.","1) The getAmount method is necessary because it provides a way to regulate access control by not allowing outsiders to modify (or set) the  value. This is a much better alternative than making the internals public.2) It allows for the possibility of performing some computation on it (like maybe changing it to a more friendlier representation, logging the time of access etc.) before the value is returned. This ability is lost if we can access the value directly.","Usually when we deal with money we are predominantly concerned with operations like credit (add) or debit (subtract) which ""directly involve money''. Operations like multiplication and division, are required on more mathematical scenarios e.g. calculating the total price of all shares given the price of an individual share. Thus such situations (where we have to perform multiplication and division) are more math-centric and must be encapsulated away in another Computation class instead of putting them in the Money class.There are hardly any situations where you would want to multiply two Money objects.","So basically our Currency class (say MyCurrency) should be able to do everything that the java.util.Currency does with the added speciality that it must print out the currency in a custom format. This satisfies all conditions of the Liskov substitution Principle. Hence, the simplest thing to do would be to subclass 'MyClass' from 'java.util.Currency' and Override the method responsible for displaying the Currency with our own custom version of the method, which displays the currency in the required format. This is the most simplest and hence the most elegant way to accomplish the task without having to change code in the java.util.Currency class. Thus, we also preserve the Open-Closed principle.","It saves a lot of memory. If we were to allocate memory to objects when they were constructed itself, the memory requirements would increase a lot and we may end up not using some of the objects at all. It is better to have a more conservative approach to memory and create an object only when needed as it is more memory efficient.","One disadvantage of lazy initialization is the time penalty associated with each access of the variable. Whenever the access is done, the logic to initialize it will kick into action and this might cause an undesirable latency especially for time/performance intensive application (where memory is usually a secondary goal).Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time -- this can also make the code a little unwieldy.","Because it might hold an erroneous value until initialization. If it is accessed before initialization (as it can very well be if it is publicly available), it can cause spurious values to be accessed in the code which can potentially break other things.","For small datasets, iterator and list based approaches (as shown above) have similar performance. For larger datasets, iterators save both time and space. For instance, if we have a very large dataset whose size is going to vary continuously (something like a queue, where data is continuously appended to the end) then it is not feasible to assume that there is conceivable end to the list, and that C.size() will return the end at all, (or even if it does return the correct end of the list, if the list is extremely large so that the size does not fit into a generic int variable, then the above code will fail).Another important advantage of Iterators is that they can point to sequences that don't exist except as a concept. For instance, you can make an iterator class that steps through prime numbers without actually having to build a container of primes.A final advantage of iterators is modularity. It is much more preferable to wrap your logic in a function call than having messy code (like the above example) spread throughout the program.",Publisher is the client (ME).Observer (subscriber) is the executive who is to return my call.,"The third choice:""Leave a message asking the executive to call you back when she is free.""The publisher  publishes a message and disengages i.e. he is not concerned with ensuring the correct reception of the message.The subscriber (executive) will receive the message (possibly from the  reception desk - say) and process it.Publisher and Subscriber are decoupled -- this a perfect example of the observer pattern.","The ActionListener interface uses the push model because the onus is on the JButton to send the notification to all the Observer (subscribers), and it does so whether the Observer needs that information or not.","Push Model:This is good when an event can occur sporadically and it is essential that the message be sent to the Observer IMMEDIATELY and without delay. This way, regardless of whether ALL subscribers want the notification or not - even if some of them require it immediately, the notification is promptly received. the others can simply ignore it if they dont want it. An example of this would be a system that raises alerts when something goes wrong (like an exception in the code etc)Pull Model:An example of this is - say - logging. The logger records all the activities and store them in the log. Whenever we want to look at the logged metadata, we 'pull' the data down based on our need. Thus the pull model is good when there is no urgent need for notifications, rather we are interested in the data only at certain times (say on a weekly basis) and pull it down when we need it."
,,,94,2,2,2,2,2,2,1,0,2,2,2,0,1,0,1,3,4,2,4,2,2,2,4,3,3,3,3,4,2,2,4,3,3,3,6,0,3,4,4
,,,,Strategy Pattern,Builder pattern,composite pattern,adapter pattern,flyweight pattern,Abstract factory,state pattern,Template Pattern,Here we are not adapting to any  particular interface.,Abstract factory Pattern,"""each with a different implementation of createLetter() and createResume() that would create a corresponding object like fancyLetter or modernResume.""Therefore we should not be using the  clone method.there fore not a prototype",MVC Pattern,Here we are not adapting to any  particular interface. but we are delegating the work to a responsible class.,State Pattern,Here we are not creating a family of objects but we are doing something based on the current state and event generated.,"Yes it is well formed because it has a consistent interfaceA well-formed class has a consistent interface. By ?consistent,? we mean that the methods that do similar things should be laid out similarly. Suppose a class maintains and manipulates the time.  It has ? a method that sets the hour and  ? a method that sets the  minutes.",0<=hour<=240<=minutes<=60,A.length is equal to B.length,The old values in B are lost .therefore if  any error occurs while copying the elements in array A into array B. we wont be able to revert to previous values of array B.,the Array B should be same as Array A. i.e all the elements in B are same the elements in array A including order of the elements.,Create a new array with the size of A and rename it as B and Copy all the elements in Array A in to array B.Free the previous array B.Copy all the elements in Array A in to array B and append a delimiter at the end of array B.,"Here we have to follow the Expert patternShopping cart class should have the responsibility of deciding whether two Items are the same.Because it is the object that maintains the collection of items. That object has the necessary data to perform the desired tasks, and so it should be the one to do so. This principle is called the Expert pattern.","public class Myclass implements Cloneable{	public Myclass clone() throws CloneNotSupportedException {        return (Myclass) super.clone();}   public void method1()   {	   System.out.println(""hello you there"");   }      public static void main(String args[])   {	   Myclass o2 = null;	   Myclass o1=new Myclass();	   try {		o2=o1.clone();	} catch (CloneNotSupportedException e) {		// TODO Auto-generated catch block		e.printStackTrace();	}	  // a.method1();	   a=null;	   b.method1();   }}This is the proper example.But consider the following examplepublic class Myclass extends First implements Cloneable{	public Myclass clone() throws CloneNotSupportedException {        return (Myclass) super.clone();}   public void method1()   {	   System.out.println(""hello you there"");   }      public static void main(String args[])   {	   Myclass o2 = null;	   Myclass o1=new Myclass();	   o2=o1;	   o1=null;	   o2.method1();   }}here when object o2  is referencing the same address as the object o1 . when o1 is initailized to null even then o2 will be pointing to the same object there fore when you say o2.anymethod() will execute properly","Advantage:Here if the location in which a person stays is changed it does not require us to change or modify other person objects and only the current person objects location variable has to be changed Disadvantage:If suppose the name of the location is changed from ""raleigh"" to ""some other name"" .Then we have to iterate through all the person objects check what their current location is and if it is ""raleigh"" then we have to change it to ""some other name"".","If suppose the name of the location is changed from ""raleigh"" to ""some other name"" .Then all we have to do is to cchange the name variable of the Location object.eg class Location{  String name;   Arraylist<Person> persons=new   Arraylist<Person>;}here we only have to change the name variable and there is no need to change the List.Disadvantage:Suppose each person has some different location.Then one object has to be created for each location.Memory is wasted, space constraint.","Advantage: No need to create a separate object for each Person or location.Therefore Space is more properly utilized.Disadvantage:If suppose the name of the location is changed from ""raleigh"" to ""some other name"" .Then we have to iterate through all the persons in the table check what their current location is ,and if it is ""raleigh"" then we have to change it to ""some other name"".Requires traversing all the persons in the table .More processing time",if usmoney.getAmount==1 then return the same object everytime whose value is 1$.Use singleton pattern,"alternatives is that it can be maintained as a String,int.Disadvantage:If it is maintained as a stringwe can convert the String amount into the appropriate amount value.so we cant use the getamount method in other methods sch as equals(Object o) and compare(object o) plus,minus...etc","Yes we need the getamount method  .It is need to get the amount of the usmoney object as It can be used  to compare the values of two usmoney objects.It can be used in the plus,minus methods.",In plus and minus methods one wants to add one usmoney objects amount to another us money objects amount.One cant divide an object by another object . in the Divide and Multiply methods.. we just want to increase the amount of the usmoney object by a certain factory.It can be done this waylet o be usmoney objecto.getamount()*factor,"overloading of toString method.In the money class create a new  toString methodpublic String toString(string FractionSeparator,String currency){ return amount/100+fractionSeparator+ currency;}","-If you never use the value, you don't pay for it.-Initialization costs can be more spread out by not initializing everything at once.-In some cases, startup appears to be faster.-Ability to delay until needed information is available.","disadvantage of lazy initialization is the time penalty associated with each access of the variable caused by the #isNil test. Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.Code needed to check to see if it is time to initialize the value each time it is used.Time spent in the code each time the value is used.Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.",* if the instance variable is public .Then  the object can access the variable directly without using the getter and setter methods .The problem   lazy intialization of the  instance variable is that the object can access its instance variable  without using the getter method ( Note :getter method  and setter method is the place where the instance variable is initialized if it is not initialized yet)  before the  instance variable is initialized causing exceptions.,"here it is assuming that all the elements in the collection are of the same type  Using an Iterator to iterate through a Collection is the safest and fastest way to traverse through a Collection especially when the type of the Collection is not known.For example, say you have a LinkedList. If you traverse the LinkedList using a for loop it will be slower than if you had used the Iterator. This is because the iterator for the LinkedList knows best how to traverse its collection.For collections like ArrayList and Vector, which are array-backed, it might not make a difference which method you choose.Iterators provide added facility to ""remove"" an object during iteration. Try that in a for loop and you are bound to face problems.",observer-the user who is trying to contact the executivesubject-Executive,"""Leave a message asking the executive to call you back when she is free.""It follows the hollywood principle of  ""don't call us, we'll call you."" Subject notifies the observers  in the observer pattern",Push model .Because only when the subject comes across an event it will send the information to the observers.(i.e when the button is pressed the event occurs and the data is pushed to all the observers i.e notify observers),Push should be used when there are more number of observers because it will reduce the processing time when compared to pulling where all the users will be trying to pull the data continuouslyPull should be used when there less number of observers .
,,,85,2,0,2,2,2,0,0,2,2,2,0,0,2,0,2,2,2,2,4,2,1,2,3,3,3,3,3,3,2,2,2,3,3,3,6,2,4,4,3
,,,,Strategy,builder.ticket is the final end product. It is constructed in small steps parts of it are createFooter and createHeader.It build various types of tickets for various countries.,composite,adapter,singletonIt provides only one instance.,"bridgeJava VM, Linux and Windows are abstractions of OS and threads have a Interface and concrete Implementations based on subclasses.",composite.left brake and right brake (primitives) and brakes(composite) behave in same way.,Facade.We are creating a new interface which abstracts the complex details of object types. The user of Bubblesorter knows only about functions outOforder and swap methods all other complex details are hidden.,This is not an adapter as we do not have an interface to design to.,Abstract FactoryAll the methods to create a letter and to create a resume are provided by the interface.,We do not have a prototypical instance to start with. and moreover client is aware of the type of the object to create.,Chain of Responsibility.client opens database connection and then uses that database to get a model and from it it gets the element.the database handles the request to model and model to element.,here we do not have an interface to design to. we are not dealing with incompatible interface and implementation.,observer and state.observer - as soon as ctrl-F button is pressed the Find dialog box is created.state - to determine if a dialog box is already opened.,the word processor is not providing the how to create various buttons. On some action the buttons are generated.,hour can be set to a number greater than 23 by a user and similarly minutes can be set to a number greater than 59. But in reality we do not have a time which has more than 24 hrs a day.,0<=hour<=230<=minutes<=59,a.length == b.length,accepts arrays of any size.,ith element of B is equal to ith element of A.for(i=0;i<a.length;i++)a[i]==b[i],If we want to remove the preconditions i.e we can have A and B of different lengths then we have to modify the copyArray function to deal with it.i.e If size if B is less than A then elements up to b.length-1 are copied into B.if size of B is greater than A then elements up to a.length are copied into B and rest are left as they are. This requires changes in post conditions also.,"The function to compare two items must be placed in the Item class. Encapsulation: A class is responsible for knowing and maintaining its data, even if it is used my many classes.",Prototype pattern is used when we do not know the class of the object we are creating and we don't even know how the constructor for the object looks like. But in the above case we know that o1 is of type MyClass and for creating o2 we can just use o2= new MyClass() instead of cloning.,Advantage:A person has a location object. Easy to represent the one - one relationship between person and location. All the details pertaining to person will be in person class.Disadvantage:Each person object has an object of location.So many objects are present.,Advantage:  can depict the same info with less number of objects as the location objects holds the details to person objects.Disadvantage: Some one may change the list and accidentally add a person who is already on some other different list. then a person has two locations which is false.,Advantage: A single object has all the details of person and location.Disadvantage: All the responsibilities of a person should be present in person class and this method introduces extra class.,include a function in USMoney class that says getDollar1(). This functions checks if already a dollar 1 object is created and if so it returns it. otherwise it creates one.Singleton pattern is used.d1 = USMoney.getDollar1() -- will create dollar1 object for first time.d2 = ISMoney.getDolalr1() -- will return th previously created one.,returning as two integers- dollars and cents. adv:gives clear idea of how many dollars and how many cents you are left with.disadv: while returning has to perform calculations and use 2 variables.returning as float: adv: It also gives clear idea of the amount present. suppose its easy to under 3.14 disadv: rounding off problems may occur.,Yes we need to have this getAmount() method to see the total amount of money present.After some series of operations like adding two simpleMoney and get a MixedMoney we can get the total money present by just calling getAmount() on mixedMoney class,We donot multiply and divide USMoney objects because these operations on USMoney objects doesn't make sense. How can we multiply $2 and $1. The operations multiple and divide are done by using plain doubles.consider the following case. The money with you is reduced to half then u perform division f the amount in USMoney object with 2 ( 2 as a number makes more sense here). But not with 2$ object.,In currency class add the following methods abstract String getPrefix() ; abstract String getSeperator (); abstract String getSuffix();In the subclasses give the implementations of these functions.In  money class toString() calculate the integer part and decimal part and store into two variables as inter_amount ad decimal_amount and return  currency.getPrefix()+ integer_amount+currency.getSeperator()+decimal_amount+currency.getSuffix();,The object is created when there is a need to use that object. We need not create an object way before using it.If we never use it we never create it.startup is fast.,overhead of maintaining the details that we do not use after initialization.more time spent in checking if the object has to be created or not.,publicly available instance variables will be used my many classes and hence initializing them lazily wouldn't save any time as each time we create a new object we might use the available instance methods. But if we lazily initialize them then more time is spent to check if they have to be initialized and to initialize at that moment.,An Iterator shouldn't depend on the details of implementation of collection. But each time here the way collection c is modified its get(i) function is modified.The size of the collection we are traversing also should be known.Whereas Iterators provide next() method which return true if next element is present.,executive is publisheryou are the subscriber.you are waiting for executive to be free. Executive informs you when he is free. you subscribe to executive and he publishes himself to be free when he is free.,third choice is more closely related to observer pattern.,push modelHere the action listener sets the button type to the clicked button when the button click event occurs and canvas is informed about it. Canvas never asks for the information.,"push model: It is used to report the event as soon as it occurred. It might be helpful while listening for key strokes,mouse clicks etc.Pull model: Observer doesn't want the information whenever an event occurs. Suppose we want to know if certain event occurrences have crossed a particular threshold. In this case each time the event occurs we need not notify the observer. Instead the observer will poll the subject whenever it need to find out the number of event occurrences."
,,,92,2,0,2,2,1,2,0,0,2,2,2,0,2,0,1,2,4,2,4,2,2,0,4,3,2,3,3,4,2,2,7,3,3,3,6,2,4,4,3
,,,,Strategy pattern. This is because calculating area for different graphs require different strategy.,Builder pattern: Here representation of tickets is varying although construction process is same.or Decorator Pattern: A ticket can be decorated in different way for each different county.,Composite pattern: This is an example of part-whole relationship.,Adaptor pattern: This is because an existing implementation has to be adapted to a different interface even though they functionally do the same job.,Flyweight pattern: supports sharing large number of string objects efficiently.,Bridge pattern: We can have a separate thread class hierarchy for different kind of threads (time-sliced and pre-emptive) and separate hierarchy for implementations. The implementations can be significantly different.,Memento pattern: we can save the memento before fixing and then make use that memento while assembling.,This is instance of Template method pattern. As it has an template method (sort) and there are multiple steps(outOfOrder and swap) in the algorithm which can be overridden and implemented by subclasses for each type.,"Adapter pattern is used only when we have an already existing object and its interface is not what we need. In our case, we do not have any interface for auxiliary methods(out of order and swap). So Adaptor is not applicable for this case.","This is an instance of Abstract factory(Document creator) and abstract products are letter, resume and concrete products are fancyLetter, modernResume. Finally, concrete factories are FancyDocumentCreator, modernDocumentCreator.","In prototype there are no class hierarchies for creating products. In this case, we see three class hierarchies. One for factories class hierarchies DocumentCreator, product class hierarchies for Letter and Resume.So prototype doesn't make any sense here.",This is an example of Proxy pattern. It shows that element is the key entity and it has many proxies like Database and Model to get to that element.,In this example we do not have any existing interface to adapt and the example is concerned about the way object is accessed.,This is an example of Factory Method pattern and Singleton pattern. First it uses factory method to get the different dialog boxes based on the keyed in parameter and it also uses singleton pattern to ensure only one instance of a particular type of DialogBox is created and returned.,This is not Abstract factory because we are not creating family of different objects. In we fact we are creating only one object dialogbox and concrete class is determined based on the parameter.,"Time is a single concept, but the user must keep track of two separate variables to work with time.2. Whenever arithmetic is done with time(e.g., moving time by specific amount like 2 days 6 hrs 12 minutes),the minutes and hour values will need to be adjusted to keep the minutes within therange of 0 to 59.3. When comparing two instances of times, you need to compare two values insteadof just one.",minutes will be in range 0 to 59and hours will be in from 0 to 23.,size of array B should be same as size of array A. That is B.length == A.length. .,"It doesn't talk about what would happen if array A is null object or even if array B is null object. Also, what would be returned in that case.Also will Array A be changed? is not cleared.",array B will contain same values of A at each corresponding index. We could also have something like array A is not modified,First of all null check on parameters should happen and throw NullPointerException if any of them is null. Second if size of B is greater that A then B should contains zeros in all the indexes greater than size of Array A. If size of B is less that size of A then,Item class should be responsible for checking if two objects are equal. This is because it has the data/information to perform equals task. This is in accordance to Expert Pattern which says the same.,"First of all o1.clone returns an Object type and so o1.clone(); has to be typecasted to MyClass type. Further, the above code throws CloneNotSupportedException and should be in a try catch block. Also, only if MyClass implements Clonable interface then the above code works as expected.",Advantages: We can only have as many instances locations as number of locations which is independent of number of persons.Disadvantages.: adds a level of indirection to fetch Location object contents. which could be inefficient.,Advantage: Easy to retrieve person/persons born based on given location.Disadvantage: Location object needs to be updated frequently as persons are born. And it also takes lot of time to find a person if you do not know where he is born. We need to go through all locations and search him in each of them.,Advantage: Very easy to find where a person is born if person is known.Disadvantage: We need to create multiple location objects in accordance to number of persons even though location objects pointing to same location have same content and only single object should suffice.,"USMoney could create a map maintaining currency amount corresponding USMoney object pair. When ever a new currency has to be created it checks if there is already an object for that amount in its map. If so, then it just returns the amount. Otherwise it creates a new instance of USMoney for that amount and stores it in its map before returning it to the user. Finally, all this functionality can be wrapped in getInstance method which takes amount as attribute and returns USMoney object as described above and we also need to make its constructor private.",getAmount method should be able to be customized so that it can return amount in1. Both cents and dollars in double.     Advantage: user need not calculate number of dollars from cents.      Disadvantage: If user wants to compare then he needs to work with  double values which have long precision.2. getMethod should take arguments Currency to convert to and CurrencyConvertor and should return money in that currency.    Advantage: user need not make use of CurrencyConvertor every time he needs to perform conversion.    Disadvantage: Unnecessary redirection if the Currency,"Not required, user need not be bothered about how much money he has. Instead, all he wants is, can he make a transaction while purchasing. If he gives money object to shop keeper then he should be able to compare the service/product cost (another money object )with money object before going for it.","First of all it does not make sense to multiply two money objects. This is not a valid use case scenario. User generally adds, subtract to his wallet and only multiply when his amount got multiplied by certain factor and not money.","We can extract out the functionality of displaying currency in particular format from the money class into an interface called formatable. In formatable there is only one operation which takes currency type and returns a string (formatted currency) and money class should have an instance of formatable type and delegate whenever it needs to format by passing its object(this) as format method parameter. And concrete formatable classes can make use of currency object to retreive amount, code and any other attributes and return them in their own formatted string to Money class.",The application might not use the object when the application is launched. So there is no point of creating them at start of application. As long as it is not used yet then we save memory.,Accessing the object first time will take lot of time as it has to do initialization for the first time.,If an instance is made public then any one can initialize it. There is no control for that class in its initialization. Some thing that is already initialized can be set to null by any other class as its instance is accessible for everyone.,The problem with design is that it doesn't allow multiple traversals  on the same collection object. This is because state information about traversal is coupled with collection object instead of having it in separate object like iterator.,Subject: ExecutiveObserver: Me,Third choice closely matches with Observer pattern. Because we are updating subject by leaving a message and execute will notify him(observer) by calling him back after certain amount of time.,It uses pull model because actionPerformed which is equivalent to update receives parameter ActionEvent that contains minimal information about the event. ActionEvent contains minimal information about source(getSource method returns object) and listener needs to pull appropriate information from source.,"If requirement is to have an observer as open as possible then pull model is better. This is because push model assumes that subjects know something about their observer needs. and makes it less reusable as subject class makes assumptions about observers which is not true always. On otherhand in pull model subject is ignorant of its observers and hence can be used with any observer and hence is better if we need to accommodation varied observers.However, if efficiency is the concern/requirement then push model is better compared pull model because in pull model observers classes must identify what has been changed with out help from the subject."
,,,103,2,2,2,2,2,2,2,2,2,2,0,1,2,2,2,2,4,2,4,2,2,5,4,1,3,1,3,4,1,2,7,3,3,3,6,2,4,4,4
,,,,Strategy,Template Method.,Composite,Adapter. The interface is not compatible so you design to interface.,"Prototype. By implementing Cloneable, a class allows field - by field copies to be made of its instances.",Abstract Factory,State,Template Method.,It is not an Adapter as we do not have to design to any interface to perform the swap or outofOrder functionality. There is no need of any wrapper here as we are not dealing with any incompatible classes.,Abstract Factory,It is not an example of Prototype as we are not cloning to create an identical copy of new Letter or resume each time. But instead we have a different implementations of createLetter() and createResume() which is equal to providing an interface for creating a family of products rather than identical objects.,Chain of responsibilityAt each step the request is passed on to the next handler. The connection object helps get a model which in turn helps get an element.,"It is not an Adapter as you are not designing to any particular interface. Here, we are not looking for a wrapper functionality to be provided as we are not dealing with incompatible classes.","Factory Method. Here the subclasses like Find, and Font are used to determine which object has to be created.","It is not an Abstract Factory as you are not providing an interface for creating a family of products like a family of dialogue boxes. Instead objects of specific classes are being created here like a Find box, Font box. Am Abstract Factory does not specify the concrete classes. You would not know the class of which an object has to be created.",This class is not well - formed as there are no pre - conditions and post - conditions specified.,"Class invariants tell us what is true while any public method of the class is not executing. In this class the integrity constraints could be to check, 1. The value of hour is not more than 242. The value of minutes not more than 60",1st precondition: Check if both the arrays are of the same lengthA.length.equals(B.length)2nd precondition: Check if array A is null or notA == null,It is not clear from the method declaration which array is copied into which.,1st postcondition: Check if both the arrays A and B have the same elements2nd postcondition: Check if the array A has the same values before and after the copy method.,We should weaken the precondition to a condition which always passes such as false { x!= x },This is based on the Expert Pattern. The object that contains the data to perform a task should be responsible for manipulating the data. The ShoppingCart class should be responsible for deciding if two items are the same. Here the ShoppingCart class contains data regarding the items billed.,"The class is supposed to implement the Cloneable interface if it intends to override the clone method and call it as it has clled. Otherwise, instead of calling it as o1.clone(), we are supposed to invoke super.clone() as the Object's code for cloning objects should be invoked.","The advantage of this design is that the Person object has direct access to the Location.The disadvantage with this method is that the Person needs to know how Location is being implemented. Any change to Location, would call for a change with all the Persons. It also does not allow more than one traversal at a time.","The advantage in this design is that it is nicely encapsulated. It is easiest for the location to maintain the reference, it provides high cohesion and a single place contact.The disadvantage with this method is that only one traversal of location can be possible at a given time.",The advantage of this method is that an iterator can encapsulate to retrieve the data of a specific Person.The disadvantage with this method is that we have extra addition to the code and extra objects.,1. Make all the instance variable of USMoney class private2. Declare the USMoney class or all its methods final3. Do not provide any setter/mutator methods.,"The advantages of representing it as a long value are1. money is still represented by a single value and 2. it allows very large monetary values but avoids most of the problems of round-off error that occur with fl oating point numbers.The disadvantages are:The problems of integer division and the truncation of the result.If you divide $1 by 3, you will get 33 cents. When you multiply the result by 3, you get 99 cents. That is, a penny was lost from the original dollar when first divided by 3 and then multiplied by 3, a very undesirable outcome for those who need to keep track of every cent.","Yes, we need the getAmount method. The getAmount method returns the amount of money in cents. It can be positive or negative.","Since USMoney objects are immutable, the arithmetic operations do not change the current object, and instead they return a new USMoney object with the new amount of dollars and cents.The times and dividedBy methods use floating point calculationsand, as a result, have round-off issues to deal with. Hence they are doubles and not USMoney Objects","The Java Currency class implements the Singleton pattern. With this currency class, we can easily display the money using the currency symbol orthe currency's ISO 4217 code. The solution is to use a Currency class, each instance of which represents a different currency that knows the necessary information for that currency, including the ISO code, the numberof fraction digits, and another other currency-specific information. In the java.util package there is such a Currency class, with exactly the desired behavior, including a getCurrencyCode method that returns the three-character code for the currency it represents, a getSymbol method that the symbol for the currency (such as the ?$? symbol for U.S. dollars) and a getDefaultFractionalDigits method that tells you where to place the decimal point.There is no conditional expression necessary for determining which currency symbol to display.Instead, a Currency object gives the symbol to us.","If the object uses a lot of memory, you would not want to create it at all unless it is needed. Lazy Initialization helps you achieve this. You can also modify the instance before it is returned. If you are returning the instance variable, to make any change to it you need not change the client code.","The main disadvantage of lazy initialization is the time penalty associated with each access of the variable caused when you test if an instance has been created or not. Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.",The cost of checking if an instance has been created or not is too much and getInstance() method also has a substantial performance overhead.,The concern of maintaining the collection and traversing the collection are now together which does not separate responsbilities. Several traversals of the collection is not possible. All the collections would now have to implement the get method. All the developers should be made aware of this fact. The user of this code would have to be aware of the method which returns the values and also the user now gets involved with the implementation details of how the collection and get method are being implemented.,You are the observer and the executive is the subject.,The third choice where you leave a message asking the executive to call you back when she is free corresponds most closely to the Observer pattern. Leaving a message with the executive corresponds to registering as an observer with the subject. The executive calling you back when she is free is similar to the observer getting notified of any changes happening to the subject.,It uses a push model as when a button is clicked it passes on useful information to the Observer.,"Example for a pull model: Suppose we have a class which provides the weather data. And there are observers who need weather data. But not all obsevers need all the data available with the WeatherData class. Some might need only the rainfall changes, some might need only the humidity changes. In this case, instead of having the subject push all weatherdata to the observers, we can let the observers pull only the required data from the subject. Example for a push model: In a super market, when items are getting added to an invoice, the GUI should get changed at the same time. Here, the subject should push the data about the item invoiced to the GUI rather than wait for the GUI to pull the item information from the subject."
,,,87.5,2,1,2,2,0,0,0,2,2,2,2,0,2,0,2,2,2,2,3,2,1,2,2,3,1,3,3,3,2,3,7,3,3,1.5,6,2,4,4,4
,,,,Strategy,Facade,Composite,Adapter,Singleton,Template,Builder,The pattern is Bridge pattern since it is used to decompose the components and allows for implementation to change independently of the other underlying methods.,It is not an Adapter pattern since it does not involve converting the interface to a desired interface.,It is the Decorator pattern since it adds additional responsibilities to the concrete classes based on the client requirement. It allows for extending functionalities to its concrete classes as required.,This is not an example of Prototype since it does not require to create a clone of the object or copying the instance.,"It is Builder pattern since it separates the construction of the connection from its representation. Hence, here the client just needs the information, and builder will build the entire complex process of opening a connection, retrieving values or adding/updating values. The end result for the client is to view the needed information.","This is not an Adapter because adapter is used to work on an existing interface and modify the code to match the client requirements to the desired output. Here, there is no desired interface and the client is not concerned with adapting or modifying anything.","It is the Command pattern since it encapsulates the request and based on the request, displays the interface that is associated with that command.",It is not an Abstract Factory pattern because it does not allow for working with multiple families of commands at the same time.,"The class is not well formed because the public methods do not keep the objects in a well formed state. Here, the object is modified and returned in the same class and hence could modify the existing state of the object.","A class invariant for this class would be to have a boolean variable to identify it its using a 24 hour clock format or 12 hour clock format. Along with that, ensuring that time in hour is 0<=hour<=24 and time in minutes is 0<=minutes<=60.",The preconditions for this method are:1) the initial number of elements in A must be 0 or greater than 02) array index should not be out of bounds,"The ambiguity in the behaviour of the method is that there is no explicit specification on the number of elements in array A and array B. There may be a possibility that array B would have more elements than array A. Hence after the copying of values is done from A to B, one must also check for the additional elements in B and ensure that those are removed from the array.",The postconditions are:1) to assert and check whether the old values in B are lost2) to assert and check whether the values in A are equal to the values in B,"On removing the precondition, the method would have to check for the length of the array A before carrying out the code to copy the elements and ensure that if the length is 0, then delete all values in array B, else start copying values.","The Item class should check for same items being added to the shopping cart by keeping a reference to the items that have already been selected. If the item is selected, it should just increment the quantity for that item. The ShoppingCart class cannot handle this because even if it identifies a duplicate item being added, it cannot modify the Item class and change its quantity due to the Open-Closed principle.","This example is wrong since the object should call super.clone to ensure proper cloning from the Object class. This is not a deep copy of the object and hence the objects are referring to two different memory locations. To make them refer to a single memory location, deep cloning should be done.",The advantage of this design is that it becomes easy to identify the location since each Person object will have an instance variable defined. It thus creates only one instance of a Person object. The disadvantage is that there would be a lot of Location objects that would have the same place of birth and would result in unnecessary duplication of same Location objects.,The creation of unnecessary duplicate Location objects is avoided and hence it makes it easier to refer to various Person objects having the same Location as place of birth. It helps on saving memory. It also helps in unambiguous identification of objects in the collection. The disadvantage of such a design is that there may be chances that,The table has the obvious advantage of referencing and locating the Person object with its Location object in the same row. The obvious disadvantage would be use of memory and space.,"To ensure only one object is ever created that represents $1, we can implement singleton pattern and ensure that only one instance of $1 is created and we can provide global access to this instance.","There should be additional variations on the getAmount method since $5 could be equivalent to many different formats in the case of number of $1 bills or number of cents. Hence, all possibilities should be taken into consideration which leads to variations. The disadvantage of such variations is that there would be a large number of possibilities and for each variation, a separate for of getAmount needs to be implemented which would make very large OO classes.","Yes, we need a getAmount method because this method is used to get the total cents for that amount. This could be useful when we have to represent money in different currencies or for calculations that require adjustments of cents into dollars.","Multiplication and division should be done by plain doubles since even though the money is an integer, there are problems with truncation of the result if divided as integers or on multiplication, undesirable outcome could be achieved by losing cents. Hence, to avoid these issues, we multiply and divide by plain doubles. But on addition and subtraction, the cents and dollar values need to be adjusted accordingly and hence, we use USMoney objects for these operations.","The Money class can use the Template method to identify the basic format and template of representing the currency in the decimal format. We can subclass the Template by having a different representation for the symbol, which has to be displayed before the decimal representation of the currency and we can have another subclass which will display the three-letter currency code after the decimal representation of the currency. Here, the advantage will be to not create the decimal representation each time since it is the desired and common framework. Only certain representation changes are to be made to that format by appending at either the front or at the back of the currency. For adding a third type of format for displaying the currency, we only need to create another subclass without having to change the entire program. This will lead to better abstraction and addition of different functionalities independent of any other code.","The main advantage for using lazy initialization is to get the behavior of having an instance created on only the first call to the Instance() method. It also helps in manipulating the instance before it returns a value. It also helps to add functionalities to the method without the need to change the rest of the program,","The main disadvantage of lazy initialization is the time penalty associated with each access of the variable. Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.","The publicly available instance variables may be required to be used at various locations throughout the code and also be modified. If they are initialized lazily, then the behaviour is created at the time of calling the Instance method and changing the instance right before returning. for public variables, we may want to change the behaviour at run time which would not be supported by lazy initialization.","The design is wrong since it is not thread safe. The object is getting modified at the time it is fetched, ie, when the traversal is going on. This could lead the collection to be in an inconsistent state.",Observer - Person trying to reach the executive in a company (here you)Subject - Executive,"The first method is most closely related to Observer pattern since here the observer will wait to be notified as soon as the executive is free. So when her state is changed to free, the observer will be notified.","ActionListener uses the push model since here when the JButton, the publisher, has to update its state when a click occurs, it notifies all the listeners and these listeners get the update notification whether it needs the information or not. It is the task of ActionListener to to take the notification only when the button is clicked and not keep on polling to get the current state.","A pull model would be better suited for a program like when we have to receive constant flight updates or bus/train updates to manage the schedules.A push model would be better suited for a program when some action needs to be taken only when required or asked, like clicking on a button to draw a shape. Here, there is no requirement of constant polling."
,,,84,2,0,2,2,1,0,0,0,2,0,2,0,2,0,2,3,2,2,4,2,2,2,4,3,2,3,3,3,2,3,7,3,3,2,6,2,1,4,1
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,"Strategy pattern: The package has to call different functions depending upon the type of the curve.Interpreter: We can also say it has to interpret the kind of curve, interpreter could also be applicable in conjunction to strategy.",Decorator pattern since tickets have footers by default and we print headers in english/ french or both in addition.,"Composite pattern, since anytime a container might contain some other containers",Adapter - since we want to write an interface that we want but we don't want to change the class that someone has written,flyweight- this reduces memory since the string instance is shared.,"bridge - since we want to keep the interface for creating the two kinds of threads the same, but just change the implementation one for java VM and native operating system.","builder - process of building is the same, but just the parts may be different",Mediator promotes loosely coupled interaction between classes. Interacting classes need not know the details of the objects they have to communicate with. They just know the interface given by the mediator class. Mediator class takes care of the rest.,In the case of an adapter we know what kind of interface the client expects(so according to this question we'll know what kind of objects are stored in the array) and design a class that has the interface expected by the client and that talks to the original class that performs the actual operations.,the client is aware of the abstract class like Resume or Letter. So we know what we want to create. So Factory pattern is appropriate for this scenario.,"For a prototype we have already created an object which we want to clone. Prototype is just cloning, copying an already existing object, but here we have different implementations like createLetter() and createResume().","Chain of responsibility: The client first creates a connection to the database, using that a model is obtained(output from database) From the model an element is obtained.(output from model). From the element the information is retrieved(output from element.) The outputs at every stage are passed on to the next stage to get the final information. This represents Chain of responsibility.",Adapter is used when we have an already existing class which serves our purpose but does not have a right interface so the client can communicate with it. Adapter is not even closely related to the scenario given. We don't have classes that don't fit with our client code.,Singleton pattern if there are different type of dialog box classes. Every box here has only one instance which is used everywhere.Flyweight pattern if its a single dialog box class that just has one instance for each type of dialog,This is not an abstract factory since we are not dealing with the situation of how creating a new instance of the different dialog boxes based on the current situation. We just have to use the instance that is already available and make sure we have only one such instance.,"No, there is no default values for hour and minutes. There are no checks performed in the setHour and setMinutes to verify that valid times are assigned to hour and minutes instance variables.",public void setHour(int hour){    if (hour&gt;=0 &amp;&amp; hour &lt;=23)              this.hour=hour;}public void setMinutes(int minutes){   if(minutes&gt;=0 &amp;&amp; minutes&lt;=59)          this.minutes=minutes;},The indexes to the two arrays are the same.The length of A and length of B are the same.,We don't know if the Array A is finally copied into Array B after the copyArray is invoked. There is not return value from the copyArray that indicates of this.,"since I mentioned strong preconditions, postconditions are not necessary","We need to make a temporary copy of array B before calling the method, so in post condition we can check if Array A was the same size as temporary copy of array B and revert back to temporary Array B if their length is not same. We also have to check if the array was copied properly incase the lengths were the same. This is inefficient compared to using the precondition",Principle:Seperation of ResponsibilityChecking equality of two items should be the responsibility of the Item class. Expert pattern:Item should know if one instance is equal to the other.,The prototype is o1 and we are destroying the prototype in the statement o1=null. Next time the same object o1 cannot be used as a prototype. Creating a new object everytime defeats the purpose of the prototype design pattern,"This is a straight forward approach. We have to however make sure this instance variable does not create a new object for the same location like ""Raleigh"" several times for several persons. Location class has to take care of that.Since we need to keep track of the place of birth of each person, it is more likely that this information would be a responsibility of Person class to ""know location"" .","We want to keep track of the place of birth of a person. Most likely this information would be accessed through an object of type Person.for eg: good_person.getLocation()If the information is stored in Location object it would involve a lot of hassle in getting this information. This is not straight forward. We have to access the collection to get the details.Advantage of this approach is every location is created only once. There will not be several objects for ""Raleigh"".",We are wasting memory by having a third object for having location information.,"we could use flyweight pattern, if flyweight of $1 exists, we need not create a new $1. Otherwise we create an object for $1 as a flyweight.",We could have it return the amount in dollars a floating point number for eg: 1.33 represents 1$ 33 cents.Advantages: It is readable and convenient for user to read.Disadvantages: It would involve conversion of cents to dollars and cents. Error prone.,Yes we would need the getAmount method to get the amount of the money in USMoney. Access to the actual amount in the USMoney instance variable can be restricted by allowing users use only this getAmount method,"Addition and subtraction would mean adding and subtracting in USMoney eg 2 centsMultiply and divide indicate twice or thrice USMoney. The value by which we multiply or divide can have any precision, so double is appropriate.",I thought of the decorator pattern but the decorator pattern is to enhance the available functionality depending on the current situation.The strategy pattern seems appropriate since we can decide which method to call based on the type of currency.,"An object is initialized only when its required. Memory is not wasted by allocating space to it when its not used.If the object creation uses up a lot of resources ,we save on that by avoiding initialization in the constructor.",if lazy initialization is used everytime the object is checked to see if it's initialized before being used. There is an additional time penalty associated with it.,If a variable is publicly available chances are that it will be used more.Everytime it's used a check has to be performed to see if it's initialized.,Disadvantages of this approach:1. C is the collection and we have access to C. If we had used an iterator we wouldn't have access to C but just the interface provided by the iterator.2. If we used an iterator we could have modified the type of the element or performed some operations on it before passing it to the client.,Observer: MeSubject: Executive,Leave a message asking the executive to call you back when she is free is the one most close to the observer pattern. It's like getting registered(leave a message) to be notified when the subject(executive) is free,push model - The observer would have subscribed for mouse clicks on jbutton. The observer does not poll the subject but remains dormant till an event of interest(in this case button click) is notified by the subject(jbutton).,"push model - subscribing for a post on a forum.pull model - checking for status change on an online application processing site, unless you have registered for email notifications for change of status in application processing."
,,,92,2,2,2,2,2,2,0,0,1,1,2,0,2,0,2,3,4,2,4,1,2,2,2,3,3,2,3,4,2,2,4,3,3,3,6,2,4,4,4
,,,,Strategy Pattern,Decorator Pattern,Composite Pattern,Adapter Pattern,Flyweight Pattern,Bridge Pattern,Memento Pattern,Strategy Pattern,"Adapter allows classes to work together that normally could not because of incompatible interfaces. In this example, there is no ""incompatible interfaces"". We just have a BubbleSorted abstract base class, and we have a sort method that uses two more methods. Since outOfOrder is abstract, that makes sure it is implemented in a derived class. There is no way we have the issue of ""incompatible interfaces"", and thus, this cannot be an Adapter",Factory Pattern,"In Prototype, we make new instances by copying existing instances. We thus do a clone() in prototype. This should not be considered when new objects of many types must be created in a class hierarchy like this one.",Command Pattern,"Adapter allows classes to work together that normally could not because of incompatible interfaces. In this example, there is no ""incompatible interfaces"" that might have to interact with one other. The Client clearly uses the Database, Models and Elements classes. An adapter would have been more useful when we want to do a wrap around so that the two interfaces can interact.",State Pattern,"Abstract Factory provides an interface for creating families of related or dependant objects without specifying their concrete classes. In the above case, there might be many commands that might have to generate dialog boxes, and the commands are not related, and thus it doesn't fit into the Abstract Factory pattern.","This class is not well formed. The reason being, consider its state between two public calls. First, we do a setHour(), and then we call getMinutes(), getMinutes() would have to return minutes, which hasn't been set yet. This is possible because we can have an unparameterized constructor, and this class isn't well formed. Also, we can do setHour(33), which is more than the time on a 24 hour clock. Similar for setMinutes(62)","The variable hour must always be <24, and minutes <60 at all points of time. These are class invariants. Also, one other could be that if hour or min is not set, it should return 0, for instance.","A[] and B[] are both integer arrays, and A.length = B.length","We have done a copyArray with the params, but it might so happen that the changes are not reflected in the main program. In Java, everything is pass by value, so a copy of the reference is created to be passed, but that reference itself is passed by value. So, this is the ambiguity.","Array A and B have the exact same values, after the two Array's have been copied. Also, another could be to ensure they both don't point to the same array location, and are two different arrays in memory too.","A and B should be allowed to have a different length, so it should have the capability to add more elements to B, to extend the array, or make B a smaller size array if needed.","ShoppingCart should have the responsibility of deciding if two Items are the same. This is because ShoppingCart would just have to check if that Item exists in the list of items it has, and then accordingly update the order if that productId is already present.","Because clone() has to be implemented in MyClass, otherwise we can't do this. Also, clone() returns a type of Object.","The advantage is that this would use Location and Person would wrap around Location, and thus use it. This would ensure that each person has a location corresponding to him, which is pretty good.The disadvantage is that many people might be mapped onto the same location, and thus we would be storing location redundantly in such a case.","The advantage is that the repetition wont be there. People belonging to the same reference would be grouped together. The redundancy compared to the previous case is reduced.The disadvantage is that a single location would have many Person objects to reference, so it might not be such a good idea.","The advantage is that a Person will be mapped to his correct Location, and it is not redundantly storing Location each time.The disadvantage is that we have unnecessarily created a third object to do this. It can be done in a simpler way.","Similar to the singleton pattern, we can iterate through all the objects that have been created, and check if any of them have amount as 1 and Currency as USD. This would ensure that only one object is ever created that represents $1","We could have a variation that the getAmount method returns the amount as well as the type of currency its using. The advantage would be that we can then ensure what currency we are using. Thus, we won't add up two different currencies in such a case (even without the MixedMoney Class)The disadvantage would be that the system itself would become very rigid, and just to get the amount, as the user usually would be aware what type of object it is, and what kind of currency it must be holding.","A getAmount method would be used to show the amount or add the amount, etc. Since we have a way to add two different amounts of the same class, this is not really needed, unless we want to convert from one type of currency to another, based on exchange rates for instance.","In add and subtract, just plain numbers could have been added. For divide and multiply, such cases will not arise, and its assumed that they are compatible as no errors may be made.",Add a new method for this,"Some advantages of lazy initialization are : The memory isn't assigned for the object till an instance is created.If instantiation takes time, this is useful.If it consumes significant resources, then this would be useful.Initialization costs can be more spread out by not initializing everything at once.","The initialization occurs at an unspecified time, which is a disadvantage.Code needed to check to see if it is time to initialize the value each time it is used.Time spent in the above code each time the value is used.","Since creating these is assumed to take considerable time, then the instance variables might be used for other tasks, so performance issues will be significant. Sometimes, we have to make sure that it has been initialized before some other method uses it. These are the reasons not to make it publicly available.","Since we have a get with a parameter that takes in an int i, it might work for cases in which we have an index based collection. If the elements of the collection are stored randomly, there would be no point in having these objects stored sequentially, and so our get() method would take a long time when we have this for loop instead of using Iterator. Another case when the design might be flawed is if we decide to remove out certain elements from the collection. Say element 5 is now removed, if our loop keeps running till size(), and it is not an indexed collection, we have the problem that get(5) doesn't exist. By implementing iterator, it takes care of it instead of us doing the same job.",Subject(Publisher) : ExecutiveObserver : Customes who call,"The case of 'Keep calling back every few minutes until the executive is free.' resembles polling in the observer pattern. The polling is done to find out if an update has been made (for example to check if the isExecutiveFree() method) each time. Once the isExecutiveFree() method is checked for, the clients get to talk to the Executives.","The Push model is used in this case. This is because, the JButton notifies all listeners by calling their actionPerformed methods, when a click occurs. Thus, the information is passed to the observer whether he needs it or not, making it the push model","If we have a huge number of observers, and say an update is made not so frequently. Instead of each one of them polling and asking if an update has been made, a better solution would be to have the push model. However, if updates are made relatively frequently, and the number of observers are less, the pull model which uses polling would work out better. As an example, a technology called Ajax Push Engine (APE) does just this. Its useful because the server notifies clients of an update, instead of the typical polling mechanism."
,,,82,2,2,2,2,2,2,2,2,2,1,2,0,2,0,2,3,2,2,4,2,2,0,2,3,2,3,2,3,1,1,1,3,3,3,6,2,1,4,2
,,,,Strategy pattern.,Builder pattern,decorator pattern,Adapter pattern,Singleton Pattern,Facade pattern.,Memento Pattern,Factory Method pattern,"The outOfOrder is the hook method.The adapter pattern is used when the the two interface do not match with each other, and needs a adapter to wrap the object and provides a different interface to it. While in this scenario, the subclass needs to decide which concrete classes to create. It is about determining which concrete classes to create and not about warping one object and provides it a interface.",Abstract Factory pattern,"Prototype is just to create a new object, but it does not know until runtime the class of the object it needs to create. But under the condition described above, it is not concerned with runtime determination of which the objects it needs to create, but it needs a way to create a number of documents, which the abstract factory pattern can solve.",Template method pattern.,"The adapter pattern is used when the the two interface do not match with each other, and needs a adapter to wrap the object and provides a different interface to it. While the template method pattern concerns with steps of doing a task. In this scenario, to retrieve the data wanted. There is no need to wrap the object. What needed is to define the steps of retrieving the data.",Observer pattern,"The abstract factory is to provide an interface for creating a family of products such as dialog box. And methods to create products in an Abatract Factory are often implemented as Factory Method. In this scenario, it is not to create the products but to create the way to deal with a certain event which can later create a product such as dialog box.","No, it just caches the value of the time and not retrieve the system time each time. The actual time may be different from the time which is stored in the object. So it violates the guideline that Public methods should always keep object in a well-formed state.",DataTime time_system. DataTime is a Java class which provides the interface of retrieving the system time. One can create a method in the class of Time whose responsibility is to get the latest time by initializing the time_system object.,The precondition is that the A and B have the same type which are both int and they have the same length.,"Yeah, it is clear that whether the data is copied from A or copied from B. The name of the method should be copyArrayto or copyArrayfrom.In addition, If this method is in the A's class, then there is no need to write like this, just write  public void copyArray( int[] B) { ... }.Third, the name of the method do not specify what type is supported. If the user just passes it two string object then error occurs.",The B's length is not changed. The values in B are the same as the values in A. And the order in both array is the same. The array type of B is int.,Just change the int array to Object array.,"The class ShoppingCart should be responsible for deciding whether two items are the same. Because the ShoppingCart is responsible for maintaining the shopping items and decide which items have been added. By using delegation to items class, the ShoppingCart can access the productID and determine whether two items are the same.","The prototype should be used to determine which subclass the o2 should be refer to. It means that the prototype pattern is used that o2 can determine which subclass the o1 refers to. However, the there are no classes to inherit from the o1. So it means that they both refer to to same location which can lead to the problem above.",The advantage is that it is very easy to retrieve the location of a person and the person just need delegate that behavior to the location.The disadvantage is that when delegating the certain task. The person is not normally up to data as it would have been the task of the the person,The advantage it is very easy to retrieve the information of the people born in the same location. The disadvantage is that there are much information are contained in the location and leads to the high coupling. This also leads to many instances stored in the location object which is not good.,The advantage is that it is very easy for the person and location to know each other. And the responsibility is separated into the third class.The disadvantage is that it wastes a lot of space. The person and location need to store the information that does not exist.,Change the USMoney() method which is the initial construction method into the private. Determine whether the instance has been created or not.,It can. And it can return the value which is separated by the decimal point. The advantage of it is clear that the money is represented in the natural way the people view it. The disadvantage is that there are problems such as different country may place the decimal points in the different position. To the left of the last two digits or to the left of the last three digits is a major problem.,"No, we do not need. It is used by the USMoney object to get the amount of money in cents.","Because it makes no sense to double a money object. Whether it mean to double the amount or transform to another currency is unclear. The USMoney object is not the primitive type whose responsibility is just to maintain the value. However, there are many values and different objects type there. It just not that easy to understand for the programmer and the user to multiply a USMoney object.",We need to build a class which named CurrencyController to do the transformation. The class should know how to convert one kind of money into another and show the currency symbol of that class. The class needs to know the rate and other information to do the conversion.,"1. If one never use the value, you don't pay for it.2.Initialization costs can be more spread out by not initializing everything at once.3.Ability to delay until needed information is available.",1.Code needed to check to see if it is time to initialize the value each time it is used.2.Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.3. More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.,"Because the publicly instance is always shared or used by many times. Or there is a need to count the number of instances have been created, in which condition we need a instance variable to track it.","Different type of object such as string and int should rewrite the method of get which violate the dry principle. And each class need to implement its own get() method in its own class which violate the principle that one class should do one thing well. This case, the class should be responsible for implementing and doing the iterating job which instead should be the job of another class. Which means that this class perform the functions that are not part of its own responsibility which violate the principle that different kinds of responsibilities should be separated among different objects.",The observer is the one who is trying to reach the executive. The publisher is the executive.,"The  third condition corresponds most closely to the Observer pattern. By leaving a message, the observer tells the publisher that if certain condition is satisfied which in this case is when the executive is free, then what the publisher needs to do which in this case is to call back.If certain condition is not satisfied, the observer do not need to wait the time to call back every few minutes or waste the space to be put on hold.","The button can: button.addActionListener(new ActionListener()){}); use this to create a anonymous class to handle this. So it use the push model. It just registers the transaction. When the button is clicked, then this message is passed to the Observer immediately.","Push models treat people as passive consumers whose needs can be anticipated and shaped by centralized decision-makers. Pull models treat people as networked creators who are uniquely positioned to transform uncertainty from a problem into an opportunity. Pull models are designed to accelerate capability building by participants, helping them to learn as well as innovate, by pursuing trajectories of learning that are tailored to their specific needs."
,,,86,2,0,2,2,1,0,2,0,2,2,2,0,2,0,1,1,1,2,4,2,2,2,3,2,2,3,2,3,2,2,6,3,3,3,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy,"Template Pattern( with hooks : isFooterNeeded() , isHeaderNeeded() )",Composite Pattern,Adapter,Flyweight,Bridge,Builder,Template pattern,"This solution capture common parts of an algorithm in a single code sequence in abstract base class. This is not an Adapter pattern because, in Adapter pattern we try to design our classes to match an existing interface.",Abstract Factory Pattern.,"Both Prototype and Abstract factory deal with the same problem. They applies when you don?t know in advance what kind of object you?re going to create until run time.   In prototype we specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype. In prototype the parent class implements the Cloneable interface. In the given example it does not implement any such interface.",Facade Pattern. Because it uses 3 different classes and provides a simpler interface for performing database related operations.,In this case they goal is to provide a simpler higher level interface. Adapter tries to match the design of a class to an existing interface. Here the existing interface is as good as what the client would need.,"Prototype Pattern:The Prototype pattern addresses concerns the need to create an instance of a class, but the particular class is not known until run-time.This is also similar to Strategy pattern.","The reason why this cant be Abstract Factory is because, in Abstract Factory we define a Abstract Class with a method that creates a particular object. But The object created by this method can be of any type since many classes inherit from this abstract base class. This we cant determine exactly what type of object that needs to be created.","No, the above class is not well formed because the public methods does not always keep the object in well formed state. Here the well formedness is indicated by the fact that class should always display a valid 24 hour clock. The public methods setHour() and setMinutes() does not validate the input parameter to check if they confirm to the valid 24 hour clock format.",The class in variant for this class is0<= hour <= 230<= minutes <= 59,A & B should be non-null A.length() > 0 ( Array A should be non empty) B.length() = A.length() ( Array B must have same length as Array A),"Yes, the ambiguity lies in the statement : Copies the values of array A into array B in the same order.Any copy procedure will typically iterate over the elements of array A and copy each element into the Array B. The fact that the elements must be copied in the same order indicate is unclear if they must be in the sorted order or the same order as they appear in Array A.",The Array B will contain all the elements present in the Array A in the same order as they are present in the array A.,"We need to validate the input parameters to test for null and non-emptyness in Array A. and make sure that Array B is properly allocated to hold all elements of Array A. Thus if the preconditions are weak, then we must do more work in the function that does the actual copy operation.","Item class should be responsible to decide if the items are the same since the ""Item"" class has the necessary detail(_productId) to make this decision.This confirms to the Expert Pattern which states that the object that contains the necessary data to perform a task should be the object that manipulates the data.","We need to make sure that we implement the Cloneable interface and define the clone method suits the properties of a given class. The return type of clone is ""Object"" so we need to remember to cast to appropriate type. For cloning to happen correctly we need to have the whole class hierarchy to override object.Clone(). This is not always possible when we use third party class that doesn't do so. It would be better to use prototype pattern instead.","Advantage: Its best to use the place of birth in Location object. Also composing Location inside person means that ""A Person Has-a Location"" which is intuitively correct. Dis Advantage: Its difficult to compute the Persons per location. We need to iterate over each of the instance of Person class and identify their location and then categorize them.","Advantage: its easier to compute the function that identifies the people belonging to a particular location. We can easily iterate over the list of references and compute the result. Disadvantage: each Location may need to keep track of a Person object which is an overhead. This also deviates from the primary responsibility of the Location object which is to know the ""location"".","Advantage: Here we delegate the responsibility of mapping a Person to a Location to an external class(Array/Table). This way we ensure that each class does only one thing and does that well instead of knowing about various other classes. This reduces the coupling between the Person and Location Objects. Disadvantage: Here we need an additional class to maintain them which increases the overhead, increases the code footprint.",public final class USMoney{       private static final long amount = 100;        private static final Currency = USD;       private static instance = new USMoney();       private USMoney {}       public USMoney getInstance()       {               return Instance;       }},The additional variations can be contemplated since we know the value is constant. 1. We could represent in the form of 1 USD instead of cents since we know we are representing 1$ and so can ignore the cents part. 2. We could use 2 separate variables for Cents and Dollars. The downside of this approach is that arithmetic calculations on this approach becomes complex. 3. We could use a floating point number to represent the amount.,"we really dont need a getAmount method at all, since we are not dealing with a variable quantity of amount. Since the quantity that we are dealing with here is constant, we can keep the value as constant and make it public as coded in answer part (a).",We typically multiply or divide by primitive values like double or int. Thus it would suffice to multiply and divide by passing in a double to those methods. Since we are trying to capture the amount of money held by a person in USMoney class it would be unnecessary to provide an implementation that tries to divide the money of one person with money of another person.,We can define an interface that encapsulates the 3 different forms of displaying the output. We can compose the java.util.Currency object within the implmenting class.  Then 2 of the forms can be delegated to the existing currency class which is known to implement the 2 classes. The implementing class can provide the definition for the third form that uses comma or puts the symbol at the end. This way we have come up with a solution that is confirms to the OO design principles.,"If the client never uses a  Singleton class at all, it would be waste of memory and resources to initialize the object which is never used. With Lazy initialization we remove his wastage.","With lazy initialization, each time we create an instance we need to check if the object is initialized or not which cannot be avoided. Also at any given point of time an object will have some objects that are properly initialized and some that are not. If important class invariants must be satisfied by these instances, then the lazy initialization may not be the best approach.","Publicly available instance variables will initially hold some default value or even null. If the client code inadvertently tries to access the instance instead of using the proper initialization channel, then it could result in null pointer exception. Also if there are many instance variables that are lazily initialized, then it could overload the system when we try access them all in one particular routine where they are all initialized at once.","Iterator pattern allow clients to iterate over the elements of a collection without knowing how the collection is implemented. Also the iterator provides a common interface that all the implementing classes should use so that it make the code that performs the iterations to be uniform in the client side. The above method cannot work if we have a datastructure/collection that cannot be indexed by a integers.Eg: Tries where we need a specialized interface. Also if we later decide to change the way we implement the collection/ or change the way the individual object is accessed, then using this method will involve making changes in lot of places. If we had used iterator pattern, then this would only involve making changes in Iterator Implementation.","The publisher is the Executive because she would publish to the subscriber when she is free. The Observer is the ""Myself"" where I wait/listen for the subject to call me when she is free.","Third Choice:""Leave a message asking the executive to call you back when she is free. ""Here me being the subscriber, subscribes to the Subject by leaving a message to notify him when she is free. This also correctly depicts the scenario where a publisher (executive) can maintain a list of subscribers( people who want to talk to executive). When the executive becomes available, the Publisher/Broadcaster can notify all the subscriber ( in this case only me).","The ActionListener use the push model. This is because the whenever a button is pushed, the button can notify all this listeners by passing the actionPerformed() method (message) on each of the listeners. The listeners dont poll and check if the button was pushed in this case.","A push model will be best suited for event driven programming which uses a lot of callbacks. Especially any device driver program will need to register a lot of callbacks to invoke different handler depending on the event that occurred. For eg: when new data is available at the input buffer.Also, the push model works best when we have a hunderds/thousands of subscribers that subscribe to a subject. If a pull model is used instead of Push model, then we ll each of the 1000 listeners would try to poll the subject at regular intervals significantly hampering the performance of the system. Pull model may be used in small/simpler applications."
,,,106,2,1,2,2,2,2,0,2,2,2,2,2,2,0,2,3,4,2,4,2,2,5,4,3,3,3,2,4,2,2,7,3,3,3,6,2,4,4,4
,,,,"Strategy Pattern: This is because, define a family of algorithms,encapsulate each one, and make them interchangeable. The algorithm vary independently from clients that use it. Here since we need to calculate the area under curve for various functions, we can consider the functions as different algorithms.","Decorator Pattern. We can Attach additional responsibilities to an object dynamically. Provide a flexible alternative to sub-classing for extending functionality. Here we have two common classes for header and footer. So for tickets printed in US or any country we can decorate with header/ footer appropriately. This in turn can have languages classes for english, french and so on. These languages can be used either within the classes or used external encapsulation to change the language appropriately. For this example we can also use a template pattern, here in the template have 2 functions header and footer. And we can have a hook which decides the language as well as if the footer needs to be printed. The hook will be dynamically updated based on the country.",Composite pattern. Here Compose objects into tree structures to represent part-whole hierarchies. Lets clients treat individual objects and compositions of objects uniformly.Containers are leaves and also components with multiple containers can be composite objects.,Adapter pattern. Convert the interface of a class into another interface clients expect. Lets classes work together that couldn't otherwise because of incompatible interfaces.,Singleton pattern. Ensure a class only has one instance and provide a global point of access to it. Since we need to have the string represented in one place in memory.,Bridge Pattern. Decouple an abstraction from its implementation so that the two can vary independently. We can bridge between OS/VM's and time-sliced/pre-emptive threads.,"Prototype pattern. Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.",Template,"An adapter pattern is one where we a situation like Convert the interface of a class intoanother interface clients expect. Letsclasses work together that couldn't otherwise because of incompatible interfaces. Here we have a common template which implements sorting. The subclass implements the outoforder and swap. Here the outoforder and swap are subclass specific and the parent doesn't have to worry about it. So here we dont have a scenario of incompatible interfaces, just we are refactoring common functionality into abstractions.",Abstract Factory,"The prototype pattern is one where we have the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.But each of these are different products and hence derived from a simple abstract class like Letter or Resume of which the client is aware. Since the products are different the client code would get an appropriate instance of the DocumentCreator and call its factory methods. Each of the resulting objects would be created from the same DocumentCreator implementation and they just would share a common theme. The client would need to know how to handle only the abstract Letter or Resume class, not the specific version that it got from the concrete factory. Since there is no specific version it cannot be treated as Prototype.",State Pattern,"There are various states in here. On connection open, it gets a model, then uses a model to get an element finally the information. Since various states are used it can be of state pattern and whereas adapter is used for incompatible interfaces and here we dont have such situation. Also adapter is structural and we need behavioral.",Observer pattern,"The situation requires, action listeners where the word processor based on the action performed brings up the appropriate dialog box. So the application acts as a listener and the keyboard controls are triggers. Hence it is of observer pattern. But cant be abstarct factory since we dont have any factory classes which can be used in combinations to obtain respective dialog boxes. Also we cannot make a dialog box as a factory pattern since it is a structural type and we need a behavior pattern.","No. Because the specification requires, 24hr format and should be valid. So get and set might return vales which are not within the 24 hour format. Since those are public method calls, there are chances of  invalid data.",We can write few asserts to check before storing if the hours is between 0 and 23 and minutes are between 0 and 59. So just before setting or during testing we can run these asserts to verify.assert satisfiesInvariants() : <error message>,"Preconditions: A[] and B[] length should be same. I.e, only if A.length() = B.length(). Input should be of type int.",Yes there is ambiguity since we dont know except for the same order what else is the post conditions. Also we dont know the length of the array and the situation in which we use this method. Also the output should it just print copy successful? So post conditions are not well specified.,Values in A should be copied to B array in same order. Also B's previous values are deleted.,"In the implementation, we need to nullify all values in B,then need to iterate over A and B and copy the contents. If Either iteration on A or B reaches the last index we can stop and exit. So here if A[] is bigger then B[], then only a subset of A is copied into B. And if B[] is bigger than A[] then zero's will be appended at the end.","In this sample, the ShoppingCart class has the authority to check if the 2 items are same. This is because of Expert pattern which tells the data of an object must be manipulated by the same object. So since ShoppingCart class is the owner of the Arraylist, it has the full authority to search the list and decide if there is already one copy. Also the item class is just a data structure for each list node and for this we cannot add verification parameters since it will not have access to other nodes. Only the shopping cart class will have the full view of the ArrayList in which each node is an Item. So before an insertion, we can add a logic to verify the nodes and if present to throw an exception.","o1 is declared as an Myclass. We can't just call o1.clone() because Object.clone() is protected. If Cloneable defined a public clone() method, we could use ((Cloneable) x).clone(), but it doesn't. We either have to enumerate all the classes that you think o1 could be, or you have to resort to reflection. We are assuming that the clone() method of all member object variables also does deep copy; this is too risky of an assumption. We must control the code in all classes, or we must know that all classes involved in deep copy operation do such a copy in the right way. Solution is to clone using serialization.",Advantages: Creates a Has-A relationship. Each person will have his location associated. Good design since a person will have just one place of birth. Scalability is easy. Robust.DisAdvantages: If you want to obtain a list of people from one location then it would be difficult to parse.,"Advantages: Easy to track people of same location. Maintainability is easy.Disadvantages: Not a very good design, since OOP concepts tell a person has a location and this would be useful for a person having a location rather than a location having many people which is generally not required expect for few cases where we need a collection of people in a location. Increases Cohesion. Not robust.",Advantages: This would be the best design. Since it reduces the cohesion between the person and location. The 3rd object deals with maintaining the data of both. Robust.Disadvantage: maintainability and scalability is difficult since more memory is required.,"This can be done by adding an exception in the constructor. So for this we will have a Sorted ArrayList in USMoney. Once a object is created we will add the integer part for the list so here first time when $1 object is created we store 1 in ArrayList. Later when an object is created, we pass dollars in the constructor, so before exiting from the constructor we can check the arraylist if the dollar is present. If it is then throw an exception telling the object is already created so reuse. This will prevent from re creating already existing objects. This can be extended for cents.","No i guess we can have it as long but later I have explained that we can use a new class for that. Since the values returned will be generally consisting of dollars and cents (in case of US). If we have to create a new class then the class has to handle the formatting, retrieving, arithmetic operations. This will become cumbersome. Hence having long for an amount will help us in arithmetic operations. We initially discussed, by using integers, U.S. money is a single concept, but the user must keep track of two separatevariables to work with money, Whenever arithmetic is done with money (e.g., adding two amounts together), the cents and dollar values will need to be adjusted to keep the cents within therange of 0 to 99. When comparing two quantities of money, you need to compare two values instead of just one.If you are to allow negative quantities of money (to represent debt or negative balances in accounts), then you can easily become confused as to how to deal with positive dollars and negative cents or vice versa. Whereas floating point will increase complexity. If we use a new class then as given above, the complexity increases with respect to  arithmetic operations and modifications. So  This representation is advantageous in that (a) money is still represented by asingle value and (b) it allows very large monetary values but avoids most of the problems of round-off error that occur with floating point numbers. But we can use a separate class and advantage will be, we can add to the class representing the amount with the type of the amount say US dollars and so on. This will reduce the work of currency class. Also this will reduce the work on the client since this class takes care of valuating the money based on currency code and value. Also this will help in easy conversion of money between currencies. Disadvantage is the complexity and difficulty in arithmetic operations.","If we stay with long amount then we would need this getAmount method. The getAmount method returns the amount of money in cents. It can be positive or negative.Mainly used to retrieve the amount and fully utilized in mixed money class. Here we do ""return left.getAmount(currency) + right.getAmount(currency);"" to obtain the currencies which are stored in mixed format. Also getAmount is useful in convertTo function where we use to perform arithmetic operations on different currencies. Thereby it is very useful.","This is done to remove round of issues. Say if we multiply the result by 3 which is a simple money object, you get 99 cents. That is, a penny was lost from the original dollar when fi rst divided by 3 and then multiplied by 3, a very undesirable outcome for those who need to keep track of every cent.","Here since we are following expert pattern and the information is currency related, and therefore the information should be held by the currency class. In other words, the solution is to use a Currency class, each instance of which represents a different currency that knows the necessary information for that currency, including the ISO code, the number of fraction digits, and another other currency-specific information. In money class we implemented the toString which uses the java.util.currency to print the value appropriately. So in this case we can override the toString method since it is country specific in the respective country class and introduce the new format. Say if this happens for all countries, then we can have a default implementation in the base class and override in the child class.","The advantages from an application perspective of lazy initialization are that users don't have to pay the initialization time for features they will not use. Suppose you were to initialize every component of your application up front. This could create a potentially long start time - users would have to wait dozens of seconds or minutes before your application is ready to use. They're waiting on and paying for initialization of features they may never use or not use right away.if you defer initializing those components until use time, your application will start up much quicker. The user will still have to pay the startup cost when using other components, but that cost will be amortized across the run of the program and not condensed into the beginning, and the user may associate the initialization time of these objects with the features they are using.","The main disadvantage of lazy initialization is the time penalty associated with each access of the variable caused by the null test. Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.","Since the variables are initialized lazily, this might have null values and accessing these will give an exception. Hence if this is a distributed system and a client is trying to access such objects, the client will face exceptions for accessing null objects and at the same time debugging is difficult for remote objects. Also within the same system, due to public access anyone can use them and without proper documentation will lead the developer with tough test time. Hence lazy initialization should not be publicly available and should be made available once the state is defined and memory is allocated on the JVM.","Advantages: Several problems may appear when collections are added from different threads. First of all let's see which the basic steps when using an iterator are:Step one: the collection return a new iterator. Usually this step is not affected when it is used in multithreading environments because it returns a new iterator object.Step two: The iterator is used for iterating through the objects. Since the iterators are different objects this step is not a problematic one in multithreading environments.It seems that the iterator does not raise special problems when a collection is used from different threads. Of course here we are talking about an ""seems"". To reformulate the iterator does not raise special problems when the collection used from different threads as long the collection is not changed. Let's analyze each case:A new element is added to the collection (at the end). The iterator should be aware of the new size of the collection and to iterate till the end.A new element is added to the collection before the current element. In this case all the iterators of the collection should be aware of this.The same actions should occur when an element is removed from the collection. The iterators should be aware of the changes. The main task when creating a multithreading iterator is to create a robust iterator (that allows insertions and deletions without affection transversal). Then the blocks which are changing or accessing resources changed by another thread have to be synchronized. This design will break the concept of providing abstraction to the user about the internal structure of the data structure and hence doesn't serve the purpose. Also this will increase client's work to parse and retrieve for various kind of implementations.",Publisher is ExecutiveObserver is user/me,"Leave a message asking the executive to call you back when she is free. Since in observer pattern, the observer registers with the publisher and waits for him to send the message. Just like me leaving a message to the executive to call back.","ActionListener interface acts as push model because when we hit the button, it will raise an event and all the observers registered will be notified by calling their actionPerformed methods. In the methods the observer will do what he wants,","Program requirements require a system like client and server where a server sends his action and client listens and performs some validations. This is best in web frameworks, Most MVC frameworks follow a push-based architecture. These frameworks use actions that do the required processing, and then ""push"" the data to the view layer to render the results.Struts, Django, Ruby on Rails, Symfony, Yii and Spring MVC are good examples of this architecture. An alternative to this is pull-based architecture, sometimes also called ""component-based"". These frameworks start with the view layer, which can then ""pull"" results from multiple controllers as needed. In this architecture, multiple controllers can be involved with a single view. Play, Struts2, Lift, Tapestry, JBoss Seam, Wicket and Stripes are examples of pull-based architectures."
,,,94,2,2,2,2,1,0,1,2,2,2,1,0,1,0,1,3,4,2,4,2,2,2,3,3,3,3,2,4,2,3,4,3,3,3,6,2,4,4,4
,,,,Strategy pattern,Decorator pattern,Composite pattern,Adapter pattern,Singleton pattern,Bridge pattern,composite pattern,Iterator pattern,Here there is no interface that you are trying to adapt to any other interface. It is just that the bubble sort algorithm is called which calls the implementation for sorting and the sort method is completely unaware of the array and the kind of objects stored in the array. Here there is absolutely no hint of adapter to think upon.,Abstract factory pattern,Here always a corresponding new object is being created like the fancyLetter or modernResume and there are no cloning done for the objects existing. Hence cannot be prototype as each time a new implementation is derived rather than cloning the existing behavior.,Chain of responsibility.,"Here the client directly interacts with the database by opening the connection to the database, getting the model to retrieve the element and the required information. There is nothing given that the client is adapting to the database interface as it is not compatible because clearly it says that the client uses the database as it is.",State pattern,"This is not an abstract factory pattern as here, always the state of the object is considered along with the input that is given. The behavior of the word processor depends on the existing state and the input that is given to it using the objects. Whereas, in the abstract factory it involves in creating the family of factories depending on the behavior passed by the object. It does not take the state into consideration.","The class is not well formed. Though the class has setter and getter method for its variables, it has not made its variables as private. If it is not made private any class can access these variables and change their data. The encapsulation was implemented by the class but without making the variables private which is of no use.","The class invariant that could given to the class is hour and minutes variable should not be negative. It is invalid if the variables are negative.check for {hour>=0 and minutes>=0}If this class is in JAVA, then we cannot give class invariants but could get the same effect by giving preconditions and post conditions for all the functions existing in the class.",The precondition would be :{length of arrayB == length of arrayB} and{Array A and B are of the same numeric type(precisely integer type)},"The one ambiguity encountered here is that should the array be read from front or should it start from the back. Since, if we start from the front of arrayA, all the elements of the array would follow the same order as the array does when started from backwards.",The postconditions are;{arrayB after operation == length of arrayA}{are all values of arrayB are the same in order and value with the arrayA}for(i=0;i<a.length;i++) check for a[i]==b[i];,Check if the arrays A and B are existing namely:{ assert arrayA.exists and arrayB.exists}and the most strongest precondition would also be:{false},"In the AddItem function, we could check if the item being added is already existing or not by calling some function say, item.exists(pid);  where the pid is the product id. This function has to be placed in the Item class as it is the information that is related to the items. The whole responsibility of the items is given to the Item class. According to the principle of the Separation of Responsibility, different responsibility should be divided among different objects and the class that is given this responsibility should be solely be responsible for all the information related to that data. According to the Expert pattern, the class containing the data should be the one to perform the task using that data. Here, product Id, product name, quantity and price are taken care of the item class and hence the checking condition should also be written in Item class.","By using the clone() method, we are just creating a copy of the object containing all of the object's behavior and the values of the o2 will be the same as the values for object o1 But when it is made null, it does not effect the second object o2 as it is just made to use the values of the first object o1 and not related to pointing to same location or being different different objects.","Advantages:1. Whenever we create an object of the Person, we can easily refer to the   location also.2. Easy to represent one-to-one relationship between location and the person.3. All the details pertaining to person are in one class.Disadvantages:1. Though to retrieve the location of the person by creating the Person object seems to be simple, we have to maintain all the corresponding locations for the particular persons. 2. If the same place of birth is changed by any of the objects, this instance variable might be effected.3. Redundancy is possible where in more than one people have the chance of having same date of birth.",Advantages:1. This is advantageous as on a single hand we could get all the places of birth for different people as a whole.2. Reduces the overload by looking into less number of location objects.Disadvantages:1. Someone might change the list by changing the place of birth where the person might lead into exist in more than one places of birth which is false.,Advantages:1. You can contact with one object at a time by calling this third object.2. Several Objects can query this object simultaneously to get the required information about the person and their respective birth dates.,We can use the singleton pattern where we could restrict the class to create only one object with its default value being $1.m1=USMoney.getDollar()--- creates an instance with $1m2=USMoney.getDollar()--- returns the instance that was already created.,"The getAmount method should be able to return two values----- one for the number of dollars and the other for number of cents.Advantages: 1.Only one variable is maintained.2. If two variables are used, it would give a clear idea to the user about how many cents and dollars are exactly present in the money that has entered.Disadvantages:1.We have always maintain two variables one for the dollar representation and the other for the cents representation.2. The other disadvantage if we use long value is that whenever the cents become 99 then it should be changes to one dollar. Maintainin all this becomes complex.","Yes, we need a getAmount method always because it would give the total amount at any point of time. If the Money objects are SimpleMoney objects then it is not much issue if there is getAmount or not but we are also using MixedMoney objects later on which would definitely require the calculation to one currency where one of the currency of the two simpleMoney objects is to be converted to the other currency and then added to give the total amount actually evaluated in the MixedMoney where the use of getAmount() is very essential.","Multiply and dividing USMoney objects doesnot make any sense. How can we multiply or divide say $1 and $2 in reality.We add and subtract USMoney objects because if we add two USMoney objects it would be meaningful but if we try to add some floating point value it would result in error which is not desirable. Hence we add two USMoney objects. But we multiply and divide by plain doubles because in real conditions, we increment the money which is a floating point number by multiplying it with some fixed number and divide the money(number/floating point) by some fixed number. We try to change the complete money comprising of different currencies into one number to divide among.","In the Currency class, include the abstract methods say getPrefx(), getSeparator() and getSuffix() methods. The tostring() method in the currency sets the integral parts and the fractional part appropriately into the total amount value. In the money class, in the toString() method,return getPrefix + getSeparator() + getSuffix() + currency + symbol;symbol corresponds to whatever the third form wants it to be.","The advantages are a pretty obvious:1.If you never use the value, you don't pay for it.2.Initialization costs can be reduced by initializing one object only3.In some cases, startup appears to be faster.4.Ability to delay until needed information is available.5. Creating the object as and when only demanded.","The disadvantages are not always quite so obvious. In fact, they are often ignored:1.Code needed to check to see if it is time to initialize the value each time it is used.2.Time spent in the code each time the value is used.3.More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.","In lazy initialization, the constructor is made, the instance variable is made private and the instance method to create the one object is also made static. The instance variable is not made public because if it is made public then it will be accessed by outside the class and changed. It should be returned only by the static method which is used to create an instance variable if not available and that returns the instance if created once. And as it is the only instance that the class will be creating, the one copy of the object gets polluted as it is prone to many problems.","Using the above design, one could iterate over the different collections available. Any each collection is assumed to be the collection of objects. Using the iterator pattern it allows the clients to iterate over the elements of the collection without knowing how the collection is implemented, But here we are assuming it to be the collection of objects which is partly acceptable. But the disadvantage of this design is that only iterator can be created at a time for the collection. Also if we want to have more than one instances for the collections like the string collection and the integer collection of the same collection type(for example fixed stack in the lectures) for performing cross product over the collections is not possible. We can only deal with one instance of the collection. Whereas the iterator pattern allows to create more than one iterators at a time for the same instance of the collection.","Here, the executive is the Subject(Publisher)and the person waiting for the executive to be free is the Observer.","The third option i.e., ""Leave a message asking the executive to call you back when she is free. "" is closely to the observer pattern.","The Action Listener interface uses the push model of communication because, when the JButton is clicked(Subject), it notifies the listeners(observers) that are registered to the listener by calling their action performed methods. Thus clearly explaining that it is push model of communication.","Weather Report application is one application where in the superclass, Weatherdata maintains the information about the humidity, temperature and the pressure. And the display device is the observer which will be notified by the publisher class,Weather data in this scenario.Push model: This model is used when there is an event that is to be notified to all the event listeners when the event occurs. In such cases, the push model is used.Pull model: If suppose, we want to know the number of occurrences happened at any instance of time not just when the event has occurred, the event is polled constantly or at regular times by the Subject for the information. In cases where we want to find the number of occurrences of the even and the even was caused by whom, the pull model of communication is implemented."
,,,100,2,2,2,2,1,2,0,0,2,2,2,0,2,0,0,3,4,2,4,2,1,5,4,3,3,2,3,4,3,2,7,3,3,3,6,2,4,4,4
,,,,Strategy pattern,"Template pattern- printing ticket is common, header footer depends on the country.",Composite pattern,Adapter pattern,Singleton pattern,Bridge pattern,Prototype pattern,Template pattern,"This qualifies as a Template pattern as the steps of the algorithm is the same. Each array element is taken, passed to outOfOrder() to compare with its adjacent element and then swap() is called. The algorithm remains the same but if it is an integer or character, different types of outOfOrder() are called based on the type of the parameters.It is not an adapter as the client can pass an integer array. There is no difficulty in interface matching.",Factory pattern.,"Here, the class DocumentCreator is abstract and the subclasses are the FancyDocumentCreator or moderDocumentCreator, the ones that determine which class is to be initialized.Here, copies of existing templates are not made. if it were so, the above example would have been classified as Prototype",Decorator pattern.,The problem states that first a connection is opened. Then gets a model and gets an element through that.It classifies as decorator as you have one object and you keep adding to it to get to what is required.It does not qualify as wrapper as there is no problem of inteface mismatch in the above case.,command pattern,"Abstract factory is used to create family of related objects.It cant be used in this case as the different commands though for the same word processor, they have different functionalities and cannot be considered as the same family of objects.The above pattern more qualifies to be a command pattern as it has to generate different dialogs for different commands","In the above class, there are setters for minutes and hours provided. Such methods must not be made public.So, the class is not well formed.The guideline in Skrien says that public methods must always keep objects in a well formed state. With the above discrepancies of setters, it is easy to manipulate the values and hence the time returned may not always be accurate.",setHour(int hour) - invariant: preconditionhour >=0 && hour<=23postcondition- this.hour = hoursetMinutes(int minutes)precondition- invariant: minutes>=0 && minutes<=59postconditionthis.minutes = minutes,A.length = B.length,"1. If the values of A are copied into B in the same order, and their lengths are same, it is understood that the old values in B are lost.2. If length is to be same and the values in B are to be replaced with those of A, there is no need to pass the array B as specified.",//check if the values of B and A are same  and in the same orderint count =0;for (i=1; i<A.length; i++)     if(A[i] == B[i])     count++;if (count == A.length){   //successfully copied},Do not pass B array as a parameter. Let the method copyArray create a new array of the size of A and copy values to it and later return the new array or display it.,"The  class Item must have the function to check if there are two same items added to the cart. This is because, two items are same if the product_ids are same. Also, the quantity must be updated if there is more than one item of the smae kind. The Item class takes care of quantity too as it has the instance variable.Thus, according to expert pattern which states that the class which has the data must be the one to manipulate it, it must be done in Item class that has product_ids, quantity which are required for the update.","The above example is wrong because:The prototype pattern generates a copy of an exisitng instance using the clone() method. In the first case above where o2 =  o1, a copy of ""reference"" is created. So both point to null.In the second case, o2 = o1.clone();The clone() method generates a copy of the whole o1 object and returns to o2. Now, though they do not refernce same memory locations, o2 will be an object of its own and only o1 is set to point to a null reference.",If each person has Location that stores the place of birth his location can be easily accessed by using Person.getLocation() format. There is only one method required that saves the person and also his location and in the same object. It does not require us to update any other object as nothing gets affected by this addition.the disadvantage is that if you have millions of records a lot of people are from the same location. We are using a lot of memory to store the value of locations. This is a lot of redundancy.,"If the Location, keeps a collection of references to the Person objects, it is easy to access all the people belonging to a particular location. Disadv -The lists itself might become huge in case of large number of persons from the same location.However, the location is not storing just the name or unique identifier of the person but the reference to the entire objectWe can only obtain [persons by location but cannot find location of a particular person. .It is difficult to find the corresponding location of a person as we may have to traverse the lists to find the appropriate match.More importantly, whenever a new person is created, the corresponding location list must be appended with the reference to his location.","This is an efficient method to retrieve persons based on locations or the locaation of a particular person. We can use a hash on this table with the Person value or group all by the same location.The disadvantage may be that if the list iss enormous, disk access may be required. Also, whenever a person is created, the above table will have to be updated with his reference and his corresponding location.","public class USMoney{      private static USMoney USDollar = null;        protected USMoney()     {         USDollar = ""$1"";}static USMoney getInstance(){ if (USMoney == null)   USDollar = new USMoney(); return USdollar;}}","If there are variations to getAmount method when they are returned in some other form, offers flexibility.It is helpful in cases where the money from fixed set of countries is to be got, say 3 countries. We can write variants to get the money in different format.but it can lead to many problems where you have to write many different alternatives as currencies of different countries differ.In such a case, it is better to have a standard format where all currencies are converted to cents and returned.","getAmount method returns the money amount in US dollars.It can be used in cases where money additions will have to be made. It returns both negative and postive numbers as long, so the user can use the amount obtained by the getAmount() method for some manipulations.","It is better to use doubles for multiply and divide as :1. the numbers are already such that it has even positive negative information. If you multiply with another money object, the product or quotient may not consider the sign value.2. If the Money object value of multiplier or divisor is too big, there is a possibility that there might be of memory exception as both are of type 'long'.","public class Money implements Comparable<Money> { private long amount; private Currency currency; public Money(long amount, Currency currency) { this.amount = amount; this.currency = currency; } public long getAmount() { return amount; } public Currency getCurrency() {   return currency; } public String toString() { //uses currency to get symbol and fractional digits and returns the string format}}public class MoneyFormat extends Money{    public String convertToSymbolFront( String currency)    {        String symbol = currency.substr(0,1);        currency = currency.substr(1).append(symbol);        return currency;     }  public String ConvertToComma(String currency){//returns the currency string with comma at end instead of period.}}","Lazy initialization helps in conserving resourcesIt can make the program operation efficient on correct usage.Only on the first call to getInstance(), the singleton instance is created.When there are a lot of objects and not everything will be used, you can use lazy initialization to speed up the application.","In many cases, if the instance is not initialized and other functions are invoked using the instance, it returns a null object. So, many tests may fail.These tests may have a bad impact on the performance later even after the instance is initialized.It might fail the whole application if a careful background job does not keep initializing the instances. Also, the process of lazy initialization must be spread out. Otherwise if lot of variables are lazy initialized at one time, the application may go down.","The instance variables that are lazily initialized must be made private so that it is called only through another class method and modified. If it is public and hasnt been initialized , it returns null. Also, it should be taken care that it wont be modified or cloned outside. so, it should be ensured that it is made private.","The problem with the above design is that you can use C.size() for a collection when it is an arraylist. When the collection is an array, you have to write a whole new loop like this, which depends on length of array.:for(int i=0; i<C.length; i++){     Object data = (Object)c[i];}","The caller is the observer.  The subject is the executive. Whenver there is a change in her state, that is, whenever she becomes free, the caller can talk to her.","Leave a message asking the executive to call you back when free most closely corresponds to observer pattern as it emulates the mechanism that you have registered yourself as a observer. Whenever there is a change in the subject, that is when she gets free, she will immediately call you back. So, you will be notified about the change of state.","The ActionListener uses a push model.Here, the Listeners register to the JButton class objects. Whenever, there is a click on the object, the listeners are notified  by caling the actionPerformed method as explained in the problem above.If the listeners had polled themselves to ask for the latest click, it would be a pull model. But in the above case as the observers are immediately notified of the action, it is a push model.","The push model can be used in cases where:You have to show the speed on a speedometer so that the driver is constantly aware of the speed. Or in case of e-shopping where your cart is updated as soon as you add an item.Pull model can be used in cases where you want to check the RSS feed. You can manually check the weather on your app, there is no push notification sent to you when there is a change. But when the stock price changes, you will get a push notification."
,,,102,2,1,2,2,1,2,1,2,1,1,2,0,2,0,2,3,4,2,4,2,2,5,4,3,3,3,3,3,2,2,7,3,3,3,6,2,4,4,4
,,,,Strategy PatternIt calls the right algorithm based on the input parameters,Template MethodMost of the code to do this is similar which can be abstracted into a super class.,Composite Pattern,Facade PatternWe are designing an interface but the functionality is already present in someone else's code.,Singleton PatternOnly one reference and multiple variables can access the same value.,Bridge PatternAllows us to decouple the abstraction and implementation.,Memento PatternWe can return to another state by checking it as we have stored all different states.,Bridge Pattern - because decoupling of abstraction and implementation is occurring so that both can vary.,"There is no existing interface to work with. Also, we are not converting representations between two classes to have them communicate with each other. Here, the abstraction and implementation is being decoupled.",This is the abstract factory pattern. - The client does not know which concrete objects it gets from each of these internal factories since it uses only the generic interfaces of their product.,"It is not an example of prototype because prototype methods are created via delegation and does not require subclassing. Here, the methods are created via subclassing and hence, this is abstract factory pattern.",Law of Demeter - Long chains of method calls between classes.,Because there is chain of method calls where as adapter provides a ?wrapper? with the desired interface.,"Singleton Pattern - This is because only one instance of any dialog box can be active always. If it's already active, then that same box is used.","This is not abstract factory because families of related objects need to be instantiated from a single place. Here, that task is not being done. The main idea is to have one instance of ""Find box"" running at all times [if it's running].","This class is not well formed as the values of hour and minutes are not checked. For example, an object can have the minute value stored as 100 (i.e > 60). This is not reflective of a valid 24hr clock time. It's the same with hour as well. The number stored in an hour field could be more than 12 [assuming we display time with AM and PM appropriately]","A class invariant for this class is that the minute value of an object should be less than 60 and greater than or equal to 0. (0 <= minute < 60). Also., 0 < hour <= 12 -- This is the class invariant for hour.",- To check if the int[] A is not empty. - To check if length of B = length of A,"The method does not handle the case where length of B is not equal to length of A. If this were true, we can copy the elements of A into B [as long as B.length > A.length) and make the remaining elements 0 [or similar value].But given this scenario, the pre-condition fails [as per existing behaviour] and the method is not executed.",contents of B = contents of A,"Copy as many elements of A into B as possible. So if A.length < B.length, then the last elements in B will have some null value. If A.length > B.length, then B will have as many elements of A as it can. Also, if there are some previous values already stored in B, they get replaced as a result of copy from A.This should make the copy function to be called irrespective of any input parameter.","Class ShoppingCart should take the responsibility of checking if the Item being added already exists or not. If it does, then we need to increase the quantity of that Item. Design Principle used - Adapter Pattern because the interface already exists. The task of checking if the Item being added is the same is ""delegated"" to the implemented class, in this case ShoppingCart","The example is wrong because the parent class should implement the ""Cloneable"" interface. Then, the creation-initiating object (which in this case is o2) clones itself. The prototype pattern is accomplished through delegation.","The advantage of this method is that it's easier to implement and have an instance variable of type Location being stored in a Person object. This results in a 1-1 mapping between names and place of birth. The disadvantage is that this can lead to high coupling and this violates an important OO principle. Also, if's quite possible that code could be written which might lead to some breakage in one class. This needs to be avoided.",The advantage of this method is that it provides us a 1-to-many mapping between place of birth and Person objects. Accessing and storage of this information is easy can be accomplished through hashes. This is beneficial as it reduces access time in case the database of Person is too large.The disadvantage of this method is that it again leads to high coupling which should be avoided.,"Here, the responsibility of maintaining the mapping between Person and birth place is delegated to another class. This is advantageous as the classes need not know too much about each other and uniform interface for both can be provided. The disadvantage is complexity. Complexity increases with the number of objects being stored.",The object representing $1 USMoney can be implemented as a Singleton so that only one instance of $1 exists. The USMoney class can have a separate instance variable called dollarOne which can be initialized only once.,"Alternative 1 - Return getAmount() in dollars with fractional values being accepted. The advantage of it is that it makes it easier for application purpose i.e, to get the price value of an item in a drug store. Most amount values for commodities are represented in dollars and hence it makes sense to return the value as dollars (with fractional values being allowed).Disadvantage is that the design might get complex as we would have to implement the ""Visitor"" pattern in order to add integer and fractional numbers.","Suppose the USMoney class is being implemented at a billing counter in any supermarket. During billing, the value of the object being bought can be returned from the getAmount() method. This needs to be done for all objects and this helps in calculating the bill.","Addition and subtraction are operations that are performed between two USMoney objects. Since multiply and divide are basically an extension of arithmetic addition and subtraction, separate methods for multiplying and dividing two USMoney objects need not be provided. The multiply and divide method presented in the lecture multiplies / divides the value of one object with some integer value.","Here Money class is an instance of java.util.CurrencyIf a country likes to display currency in some other form, then it should implement their own version of Money class called ""NewMoneyRep"" and have it extend the Money class. For computation purpose [i.e, to add or subtract currency], it can use the methods given by the Money class. Two methods can be implemented.Method 1 - Take the input as per the specified representation and convert it into a representation understood by Money class. [for computation sake]Method 2 - Take the output from the Money class and present it in a new display style [by appending the symbol etc]These two methods can infact be delegated to another class (say convertMoney) and we can have NewMoneyRep have an instance of convertMoney.","- If you never use the value, you don't pay for it.- Initialization costs can be more spread out by not initializing everything at once.- In some cases, startup appears to be faster.- Ability to delay until needed information is available.",#NAME?,"Since publicly available instances can be accessed by every external object, the frequency of it being accessed is more. If the variables are created lazily, then there is an enormous overhead of having to create many variables at once. This could lead to a crash if multiple methods are accessing a variable that is public.","If the implementation of the collection changes, then the code for sequencing it will have to change too. In this case, the code for iterating will also have to change.Hence, we need to provide a standard interface for clients to iterate over the collection without knowing how they are implemented. Then even if the implementation of the collection changes, the clients can still call the code and iterate over. In this case a new instance variable could be added to Object which means that the code iterating over it has one other field to jump over. This is really messy and does not allow development of the Collection itself.",The Observer is the client/person who is calling the executive in a company.The Publisher is the executive in the company.,"The third option ""Leave a message asking the executive to call you back when she is free "" is closely related to the ""push model of the Observer Pattern"".Here the observer wants to check if the executive is free. This is the action of Interest under consideration. So when that even occurs [i.e, when the executive becomes free], the Observer is notified i.e, the executive will call the client.","This ActionListener interface is using the ""push"" model of communication. Here, the listeners are not polling for any specific information that is required by them. Rather, the JButton class notifies all listeners that a particular button has been selected. This invokes the right method to be invoked based on the type of button that has been selected.","A ""pull"" model would be better suited if a listener has interest in a certain kind of event that occurs. An example of this is saving the figure that has been drawn on the canvas. After the user completes the drawing and wishes to close the application, the ""save"" feature can be notified which then asks the user if he wishes to save this drawing. Note that this feature can also be implemented as a ""pull"" model by letting the user save his work frequently. However by implementing it as a ""push"" model, we account for human errors [where one forgets to save the picture]- A ""pull"" model would be better suited for coloring feature. If the user wishes to add some color to their figure, then a listener function can be implemented which invokes the addColor() method to be called."
,,,90,2,1,2,0,1,2,2,0,2,2,2,0,1,2,2,3,3,2,4,2,2,0,2,3,2,3,3,4,1,2,4,3,3,3,6,2,4,4,4
,,,,Strategy Pattern.,Template,Composite,Adapter,Flyweight Pattern,Abstract Factory Pattern,Builder,Template pattern.,It is not an adapter because there is no wrapping done and no incompatibility of interfaces.,It is an abstract Factory Pattern.,"It is not a prototype pattern cause the intent of prototype pattern is to  Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype. we have no prototypical instance here.",Chain of Responsibility.,It is not an adapter because for an adapter the intent is to Match an existing object to a particular interface.  A system has the right data and behavior but the wrong interface.  Typically used when you have to make something a derivative of an abstract class you already have or are defining.,Factory method Pattern,It is not an Abstract Factory because the intent of Abstract Factory is that  Families of related objects need to be instantiated from a single place in the code.,A good way is to specify whatmakes objects of a class well-formed is to list the class invariants. A class invariantis a statement about the state of objects of the class between public method calls.,the invariant that minutes mod 60 gives the hours.  This condition should not change even between method calls.,Length of array A is same as that of B.,There are an ambiguities. It does not mention that about  checking for negative lengths or the condition in which the elements of A are garbage.,"The elements of arrays A,B  are the same now,",The condition has to be checked inside the Copy method. It should compare the lengths of the 2 arrays and return an error message if the lengths are not equal and procede to copy only if the array lengths are equal.,The method/responsibility  to check for the equality of the items has to be present in the Item class as it is related to the items. Such a design of the Item class improves Cohesion(A class that whose variables and methods are directly related to the functionality the class is supposed to provide is said to be highly cohesive) .It also reduces the coupling  between shoppingcart and Item.,"object o2 = o1 ; now Both o1,o2 refer to the same memory location where the object is created. When o1 is assigned null,it no longer points to the object. But o2 points to the created object and hence there is no null pointer exception. Thus the conclusion that o2 is null when o1 is null is wrong.  Hence this example does not show the usefulness/improvement of cloning over normal assignment.",Adv: Person has all the  data related to Person. So cohesion improves. Person maintains all the data related to Person including the person's birth location.Disadv: Redundancy as the location object may be the same for several person classes. ie it is stored in several classes of persons whose birth places are the same. Hence there is wastage of memory.,Adv : We can know the details of the people born at a location.Easy to retrieve the list  people born at a particular location.Diadv: Has to store a lot of data. Memory is wasted. A class is responsible for just one thing . The name Location does not reflect that the class has this responsibility (of maintaining the list of persons),Adv: No cohesion problems. Easy to obtain the information by indexing through the table. Disadv: The same location  may  be present along with many persons. Hence data is redundant.,"A singleton pattern can be implemented to design the USMoney class so that only only one object is created. The class can have an instance variable say ' amount '. While creation of an object, The getInstance can take the parameter which denotes the amount ($1) in this case. This method compares the parameter with the 'amount'. If equal it returns the already existing instance. Else it returns a new instance created with that amount.","The other alternatives could be?	Two integers, one for dollars and one for cents   Adv: It is easier to undestand. But cannot return more than 1 value. So may have to use other ways like creating an object with the dollar,cent pair/ array etc which represent this value.?	Floating pt number:  Adv: high precision.Disadv: does not need  more than 2 decimal pts. ?	It can be returned as a one long integer, with an implied decimal point.  It is easier to understand and interpret.","getAmount is used  by the methods of the USMoney class for implementing their  operations like comparision, equals, plus ,minus etc. It need not be public as we don't need to access it outside the class.",Because the operations involving money in the real world are addition and subtraction only . We do not multiply or divide money with money. Hence the methods defined that way.,,"The advantages are :1) If you never use the value, no need to incur cost of initializing it.2)Initialization costs can be more spread out by not initializing everything at once.3)Ability to delay until needed information is available.",The disadvantages:)Code needed to check to see if it is time to initialize the value each time it is used. This may be an overhead if all the instance variables are initialized using the lazy process.Time spent in the above code each time the value is used.2)Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.3) complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.,,The collections should have the responsibility of managing the collection but not the iteration. It thus complicates the collection class. There is coupling between the representation and the functionality of the object. It should have only the responsibility of representing the collection but not iterating through it violating the principle that a class should have a single responsibility.,Observer is myself.Publisher is the executive,"The third option which is ""Leave a message asking the executive to call you back when she is free."" resembles the observer pattern as we have objects (Observers) that want to know when an event(executive is free) happens attach themselves to another object (Subject-Executive) that is watching for the event, or that triggers the event itself.",The ActionListener interface uses the pushmodel  of communication .It receivers information abt an event through ActionEvent object. This high-level event is generated by a component (such as a Button) when the component-specific action occurs (such as being pressed). The event is passed to every every ActionListener object that registered to receive such events using the component's addActionListener method.,"Pull model would be useful when the The subjects send detailed information about the change to the observer whether it uses it or not. Because the subject needs to send the detailed information to the observer this might be inefficient when a large amount of data needs to be sent and it is not used. Another aproach would be to send only the information required by the observer. In this case the subject should be able to distinguish between different types of observers and to know the required data of each of them, meaning that the subject layer is more coupled to observer layer.Pull model - The subject just notifies the observers when a change in his state appears and it's the responsibility of each observer to pull the required data from the subject. This can be inefficient because the communication is done in 2 steps and problems might appear in multithreading environments.Hence can be  Used in single Threaded environmentsPush model would be useful when"
,,,85,2,1,2,2,2,0,0,2,2,2,2,0,2,0,2,1,1,2,4,2,2,4,4,3,3,2,3,4,1,2,0,3,3,0,6,2,4,4,4
,,,,Singleton Design Pattern,Strategy Pattern,Composite Design Pattern,Template Method,Decorator Design Pattern,Bridge Design Pattern,Builder Design Pattern,Template Method,"This example intents to capture common parts of an algorithm in a single code sequence. And Template Method pattern is a way of abstracting similar behavior in various classes and duplicating only the code that differs, like in the example.",Facade Design Pattern,"Because Prototype is just copy the class itself. While Facade Pattern provides a unified interface to a set of interfaces in a subsystem and defines a higher-level interface that makes the subsystem easier to use, just like the example.",Model View Controller (MVC) pattern,"Model View Controller (MVC) pattern creates applications that separate the different aspects of the application, while providing a loose coupling between these elements. While, Adapter just matches an existing object to a particular interface.",Flyweight Pattern,"The example uses Flyweight to implement for many objects to share (most of) their representation. But, Abstract Factory just coordinates the creation of families of objects.","It caches values instead of computing them when they are needed.While, at the end of every modifier method, there could just add the statementassert satisfiesInvariants() : <error message>",the value of the return minutes should be no more than 60,The array B must have the same length as array A.,"Yes, every time when we copied one element of array B, the element will be deleted from B, and then the size of array B will be not as the same as array A any more. This will violate the precondition.",The old values in B should be deleted.The copied values of array A should be in the same order as into array B.,"public static copyArray(int[] A, int[] B) { ... }","public class Singleton {public static final Singleton instance= new Singleton();private Singleton() { }//...any other methods...}Singleton uses a private or protected constructor, and provides a public instance variable or method that creates the object exactly once to prevent the instantiation of multiple objects of this class.","This allows the MyClass referred to act as a prototype for the new class to be created.Each class that is going to create an object must have a prototypical object. The parent class implements the Cloneable interface. Then the creation-initiating object should clones itself, producing an object of the correct class.","Advantages: easy to initiate and reference to, any object referenced directly from an instance variable of a strongly reachable object is strongly reachable. Disadvantages: a new instance variable is created and initialized to a default value as part of each newly created object of class or of any class that is a subclass of the class, the instance variable effectively ceases to exist when the object of which it is a field is no longer referenced, after any necessary finalization of the object has been completed.","Advantages: this reduces the space taken by each object and can also reduce the number of objects created if each instance creates a separate object to populate that instance variable.Disadvantages: once the Location object of which it is referenced to by Person objects is deleted or changed, the information of birth location of all these persons will be deleted or changed together. It always make us losing some information.","Advantages: it is well-stored for all information, convenient to edit or delete for one record and won't disturb other records.Disadvantages: it will cost more space and time to manage the table. We have to relate to the table every time we want to access certain information.",Singleton Pattern,No.,Yes.,,"Use ?double-dispatching?. When we want the classes of the arguments to be used todetermine which method to call, the method called should depend both on the class of the receiver and the class of the argument.","If you never use the value, you don't pay for it.Initialization costs can be more spread out by not initializing everything at once.In some cases, startup appears to be faster.Ability to delay until needed information is available.",Code needed to check to see if it is time to initialize the value each time it is used.Time spent in the above code each time the value is used.Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.,"The public instance variables may be often accessed, so it will cost many of code and time to check if it is time to initialize the value each time it is used. And also, it will cost much more time for initialization.","Because of the difference of size of different collections, we have to write one more loop each time for a new collection. So there is no advantage of iterators that it provides a consistent way to handle navigation within collections regardless of the underlying structure, and then callers can simply call them to iterate over the collection.Also, it exposes our internal implementation. So there is no advantage of iterators that to encapsulate the internal implementation.",Observer: the clients who are trying to reach an executivePublisher: the executive in the company,"The third choice corresponds most closely.Because the Observer pattern is to have objects (Observers) that want to know when an event happens attach themselves to another object (Subject) that is watching for the event, and when the event occurs, the Subject tells the list of Observers that it has occurred. As the implementation that the executive calls back when she is free.","It uses the push model. The listener is Observer. The useful information is passed by the Subject to the Observer when the button is clicked, and the Observer is notified by the calling of actionPerformed methods no matter whether they need to be notified or not.","For example, a news agency gather news and publish them to different subscribers. We need to create a framework for agency to be able to inform immediately, when event occurs, its subscribers about the event."
,,,68,0,0,2,0,0,2,0,2,0,1,1,0,1,0,0,3,1,2,4,2,1,2,2,3,3,3,3,2,0,0,1,3,3,3,6,2,4,4,2
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy Pattern.,Template Pattern.,Composite Pattern.,Adapter Pattern.,Singleton Pattern.,Abstract Factory Pattern.,Memento Pattern.,"Command pattern.For the reason that the sort method give command to the outOfOrder, and the outOfOrder will return whether those indices should be swapped or not.","Because in adapter pattern we should make some incompatible classes by add a new classes to make they can be compatible. In the case above the sort method does not care what kind of objects are stored in the array it does not change the interface and outOfOrder class does not change the interface too, so it is not Adapter.",Abstract Factory pattern.,"Prototype pattern specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.In the example above we do not copy any instance from the prototype, so it is not prototype pattern.",Visitor pattern.,"Because in adapter pattern we need to change the interface to make the classes work together, in this example from client to Database, Database to Model, Model to Element, Model do not change the types from the database input, so it is not adapter in this example.",Singleton Pattern and Factory Pattern.,Abstract Factory create families of related or dependent objects without specifying their concrete classes. In this example the dialog boxes class does not create a families classes of dialog and the subclass decide which class to instantiate. So it is Factory Pattern not Abstract Factory pattern.,No. Because this class does not include any invariant to make sure the time value should be equal in the internal class.,"We should define an invariant in the class that which defines the current time, for example we can use a current time class to save the time.class Current_Time(int hour, int min){      this.hour= hour;      this.min = min;}We add the class to Time class, and make sure that when Time class change the hour and minutes, the value in Current_Time should be the same.",A.length = B.length,"Yes. copyArray We should provide the direction from A to B, like naming copyArrayA_to_B to make the name more clear to use the function.",The value of each in A should be equal to the value those in B.,We should set the precondition to null and add the the array B must have the same length as array A into the postconditions.,"Item class should have the responsibility of deciding whether two Items are the same.With the basic guideline of class design is,Every class should be responsible for doing one thing only anddoing it well.Since ""if two Items are the same"" relates to the Item class and it should have the responsible two items if they are the same.","o2 is clone from o1. In the clone, o2's instance variable's value should be the same with o1.And o2 is totally a new subject which is build from o1, which means that o2 is not a reference refers to o1.So o2 has his own memory location, when we set o1's value to null, it won't affect the clone value of o2, so o2.anymethod() method will work whether o1 set to null or not.","Advantages: Define Location as the instance variable for the Person object, it is easy to get the Location information for the Person, we can simple search the Person ID and get the location easily.Disadvantages: This design will waste a lot of space that if a lot of persons birth in the same place.","Advantages: This design will be easy to find the Persons who are birth in the same place, and easy to calculate the total numbers of the person birth in the same place.Disadvantages: If we want to search one person's information by name or by id that will be difficult, since we need to know where the person birth location first.","Advantages: This will help relate the Person and their place-of-birth Location very clear. Make the program easy to read and we can both search the person by name and from the birth location to find the persons easily.Disadvantages: It needs extra space to store the information of the relation between the Person and Location, the design of the whole program will be more complex.","Use the singleton pattern in the UsMoney object.1.Make the object static and private, set it is original value to $1.2.Provide a public method to get such instance.3.Judge the object if it is exited, do not create any more.","We can change the cents into how much dollars we have,like 1.34 which means that we have $1.34, and change the return as a float value.Advantages: The value should be smaller than the value express in cents of a long value and very simple and easy to read.Disadvantages: It needs other function to change the value from long value cents to the float value dollar, sometimes it is not as accurate as the value display in cents.","No always. Like the SimpleMoney example in class, it does not have the getAmount() method. It will be use for changing the different kinds of the money like Euro and Dollars into same format and return the value.",Because in addition and subtraction if the input value one of them is float the result will be change to float. But like in divide two integer numbers can make float but the value will change to integer which will make some data lost.,We can use the java.util.Currency class as the super class and defines our currency-specific classes inherit from it. And we can redefine toString method to make the method can display the currency in the format we like to.,"We do not need to care about the variable which we do not use, that will save much time and much more easy to do the initialization work, we can put more time to what we focus.","It may be make more variables to save the states of some variable whether it is initialize.  And more important, sometimes we forget that the variables do not initialize, and we use the uninitialized variable in our work, that may cause some problems.","Because publicly available instance maybe share with other class or program, the classes and programs may not know if the variable is initialize, or maybe several classes detect the variable that share together do not use and initialize several times make the data not consistent that will make some troubles.","I guess the problem is with the iteration of for (int i = 0; i < C.size(); i++), it exposes the design of the iterators like array. So if we use the for (int i = 0; i < C.size() to iterate the link-list it will change the code a lot. More common for the iteration we can use:Iterator it =...;while (it.hasNext()){    Object data = it.next();    ...  do something with data...}",Observer: Me.Subject : Executive.,"Leave a message asking the executive to call you back when she is free. Most closely to the observer pattern.Leave a message likes I subscribe from the Subject executive, when he is free, he call me back like the Subject notifies something change and tells the Observer.","It uses the Pull model. Because the addActionListener  method likes the Observer subscribe the information they want, they register themselves to the Subject JButton. And the JButton use the actionPerformed  method to notify all the Observers.","In some programs, the Observers are only interested with the information they care. They do not like the Observer to notify the information that they don't care. So we should modify the pull model that make some conditions the Observer only register register the information that like, and modify the pull model that only give back the information to the Observers they are interested."
,,,92,2,1,2,2,1,0,2,0,2,2,2,0,2,2,2,2,1,2,4,2,2,3,4,3,3,3,3,4,2,3,5,3,3,3,6,2,4,1,2
,,,,Strategy Pattern,Decorator Pattern,Composite Pattern,Adapter Pattern,Memento Pattern,Prototype Pattern,AbstractFactory Pattern,TEMPLATE METHOD pattern,"The TEMPLATE METHOD pattern shows one of the classic forms of reuse in object oriented programming. Generic algorithms are placed in the base class and inherited into different detailed contexts. But this technique is not without its costs. Inheritance is a very strong relationship. Derivatives are inextricably bound to their base classes.For example, the outOfOrder and swap functions of IntBubbleSorter are exactly what are needed for other kinds of sort algorithms. And yet, there is no way to reuse outOfOrder and swap in those other sort algorithms. By inheriting BubbleSorter we have doomed IntBubbleSorter to forever be bound to BubbleSorter. On the other hand, Adapter pattern is a design pattern that translates one interface for a class into a compatible interface.An adapter allows classes to work together that normally could not because of incompatible interfaces, by providing its interface to clients while using the original interface, which is totally different from the working style of the two functions swap() and compareAndSwap().",abstract factory pattern,"1) The abstract factory pattern is a software design pattern that provides a way to encapsulate a group of individual factories that have a common theme. In normal usage, the client software creates a concrete implementation of the abstract factory and then uses the generic interfaces to create the concrete objects that are part of the theme.  In the above example, the client code would get an appropriate instance of the DocumentCreator and call its factory methods. Each of the resulting objects would be created from the same DocumentCreator implementation and would share a common theme (they would all be fancy or modern objects). The client would need to know how to handle only the abstract Letter or Resume class, not the specific version that it got from the concrete factory.On the other hand, the prototype pattern is a creational design pattern used in software development when the type of objects to create is determined by a prototypical instance, which is cloned to produce new objects. Thus, the above example is not Prototype.",Facade pattern.,"Facade pattern provide a unified interface to a set of interfaces in asubsystem. Facade defines a higher-level interface that makesthe subsystem easier to use.In the above example, Client doesn't really need to know aboutDatabase, Model or Element. It only needs to retrieve information from Element. Thus, we can adopt a Facade pattern.The Facade pattern should be used when 1) you want to provide a simple interface to a complex subsystem. 2) there are many dependencies between clients and the implementation classes of an abstraction. 3) you want to layer your subsystems.On the other hand, the intent of Adapter is to convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces. The Adapter pattern should be used when 1)you want to use an existing class, and its interface does notmatch the one you need. 2) you want to create a reusable class that cooperates with unrelated or unforeseen classes, that is, classes that don't necessarily have compatible interfaces.3) you need to use several existing subclasses, but it's impractical to adapt their interface by subclassing every one.",state pattern,"The state pattern, which closely resembles Strategy Pattern, is a behavioral software design pattern, also known as the objects for states pattern. This pattern is used in computer programming to represent the state of an object.The state pattern, which closely resembles Strategy Pattern, is a behavioral software design pattern, also known as the objects for states pattern. This pattern is used in computer programming to represent the state of an object.When user type in different keys, different behaviors happened, which conform to the definition of state pattern very well..On the other hand, the abstract factory pattern is a software design pattern that provides a way to encapsulate a group of individual factories that have a common theme. In the above example, each state and behavior hardly has common theme.","No. It is not.We can only getMinutes() not both of getHour() and getMinutes(). Although two methods can increase the efficiency of the code, caching values instead of computing them when they are needed can also increase the complexity and number of invariants of your class.","you could just add the statement assert satisfiesInvariants(): <error message>This statement invokes satisfiesInvariants. If it returns true, then nothing happens and execution moves on to the next statement in the program. otherwise, the assertionException is thrown with the error msg passed a",The array B must have the same length as array A.,Yes.The old values in B are lost.,"After copying, 1) the order of the values in B is same as the order of the values in A. 2)The old values in B are replaced by the copied values, ie., they are gone.","change the container, not use Array, use LinkedList",,,Advantage: You can have the information of the place of birth for each person when you instantiate the object of Person.Disadvantage: It limits polymorphism and multiple inheritance. It has tight coupling of classes.,"Advantage: When you instantiate the object of Locatio, you will get all the person who were born at this location. It is very convenient for people to query or search.Disadvantage: It is unnecessary and waste of time and space. One big city may be many people's birth location, the return information will be overwhelming to users.  It limits polymorphism and multiple inheritance. It has tight coupling of classes.","Advantage: It is good. less coupling of information.In general, a good way is to ?	create a third class that has the common functionality, and?	make sure that both of the classes have-an attribute that is an element of the third class.Instead of invoking a method of the superclass, we send a message to an instance of the third class.  This is called delegation.",Use a static variable whose type is HashMap to store the created objects.,"No. 1) The advantages are to keep the USMoney to represent one currency at a time. To represent the amounts in cents, you can create another USMoney object whose currency is set to cents. 2) The disadvantage is you may have several objects representing same amount of money. For example, 100 cents for one USMoney object and 1 dollar for another USMoney object, these two objects representing the same amount of money.","Yes. We need the getAmount() method. Explanation:The USMoney class have two fields, amount and currency. The method getAmount() is used to express the amount of the currency.",Multiply or divide by USMoney objects do not make sense. We generally do not say one dollar is divided by one cents.,We can define a currency format class and use that to format the output. The currency format class is as follows:interface CurrencyFormat{          String formatOutput(USMoney money)   },"In general computing terms, 'lazy evaluation' means to defer the processing on something until you actually need it. The main idea being that you can sometimes avoid costly operations if you turn out to not need it, or if the value would change before you use it.The advantages are pretty obvious:--If you never use the value, you don't pay for it.--Initialization costs can be more spread out by not initializing everything at once.--In some cases, startup appears to be faster.--Ability to delay until needed information is available.The advantages from an application perspective of lazy initialization are that users don't have to pay the initialization time for features they will not use. Suppose you were to initialize every component of your application up front. This could create a potentially long start time - users would have to wait dozens of seconds or minutes before your application is ready to use. They're waiting on and paying for initialization of features they may never use or not use right away.Instead, if you defer initializing those components until use time, your application will start up much quicker. The user will still have to pay the startup cost when using other components, but that cost will be amortized across the run of the program and not condensed into the beginning, and the user may associate the initialization time of these objects with the features they are using.",The disadvantages are not always quite obvious:--Code needed to check to see if it is time to initialize the value each time it is used.--Time spent in the above code each time the value is used.--Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.---More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.,"If you access an uninitialized instance variable, it will return a null object.",,1) You are the Observer2) The executive is the Subject(Publisher).,"The case 3 ""Leave a msg asking the executive to call you back when she is free"" corresponds most closely to the Observer pattern.Explanation:In this scenario, You (the Observer) subscribe to the executive (the Subject). When the executive' state changes, i.e., when she is free, she will call you back, i.e., notify the Observer. Case 1 is not the Observer pattern. The Observer is put on hold for the Subject to notify, i.e., the Observer does not wait for the Subject to notify him/her. Case 2 is also not the Observer pattern. The Observer keep calling back every few mins, i.e., the Observer does not subscribe to the Subject (Publisher).","It uses the PUSH model for communication.Explanation:The listeners registered with the button so that they can be notified when the button state is changed (i.e., the button is clicked). When the state change occurs, the ActionListener's actionPerformed(ActionEvent e) method PUSHes the information of ActionEvent e to the Listeners. Thus, we say it adopts the Push model.","The pull/push note is more about how information about what happened is transferred once the notification need arises. Pull/push model differ in different sorts of coupling associated with each approach.1) Pull model eliminates that coupling on Subject's part but it forces  the Observer to ask explicitly for the Subject state data that it needs. This model avoids the Observer to be overwhelmed by a lot of unnecessary information. Presumably the Observer will never need anything that is not a public responsibility of Subject, so the Pull model tends to be fairly benigh and is commonly used when the relevant state data is nontrivial. The downside is that one needs to deal with the synchronization problem.2) Push Model requires that the Subject know what information the various Observers may need. So to avoid Subject knowing about individual Observers, one needs to provide a superset of information that includes everything observer might need. The push model is more effective when a lot of information update is passed to the Observer from the Publisher. Therefore, the Observer does not need to frequently call back to the Subject (Publisher)."
,,,79,2,2,2,2,0,0,0,2,2,2,1,2,1,0,1,3,1,2,4,2,2,0,0,2,2,2,3,3,2,2,7,3,3,3,0,2,4,4,4
,,,,Template method pattern,Factory method pattern,Composite pattern,Adapter pattern,Builder pattern,Facade pattern,Memento pattern,This is the bridge pattern. Here the intent is to decouple the abstraction from implementation so that the two can vary independently. It avoids permanent binding between the two.,"In case of the adapter, there is an existing interface of a class which does something related but not exactly what the client needs. So that interface is converted into another interface so that the two incompatible interfaces can work together. However, that is not the case here. It is not that we have an incompatible interface of the class, but that we are separating the abstraction and the implementation, since the abstract class has no clue about the implementation.",This is the template method pattern. The base class provides a set of interfaces that the derived classes are needed to implement. Each derived class has to specify its own version of these interfaces but use everything else from the base class as it is.,"Here, cloning is not being used to create a new object. We are not copying an object using a prototypical instance, but just defining different version of specific methods in the derived classes for those methods provided by the base class.","This is the decorator pattern. Here, the object's responsibilities are changed during runtime. From the given problem, this is evident. Client class is used to open a connection to database. Then the database gets a model, which in turn gets the element. And finally we retrieve the necessary information. So each object's functionality is being extended dynamically.","An adapter changes an object's interface while the decorator changes the object's responsibilities. Here, we do not have an existing interface that is incompatible. So it is not the adapter pattern.","This is the command pattern. Here, we encapsulate a request as an object. It lets you parameterize clients with different requests,","In AbstractFactory, a framework is defined which produces objects that follow a general pattern and at runtime this factory is paired with a concrete factory. It does not encapsulate a command request as an object.",No this class is not well formed. Internal consistency is not maintained if there is something wrong with the value of minutes or hour.,The class invariant is that the time displayed by the class should be the same as the hour value returned by getHour and the minutes value returned by getMinutes.,The array B must have the same length as array A.,"Yes there is ambiguity. If the pre-condition is not satisfied, i.e. if the array B is not of the same length as array A, then the behavior is not known. Anything could happen.",The old values in B are lost. The array B contains the same values as array A.,We could write our code so that preconditions and postconditions can be checked.  This is done with the Java assert statement.The assert statement has the formassert expression1;It simply raises an AssertionError if the assertion is not true.,"The ShoppingCart Item should have the responsibility of deciding whether two Items are the same or not. It follows from the ""Expert pattern"", which says that the object that contains the necessary data to perform a function should be the object that manipulates the data. The ShoppingCart class has information about the product id through the get_productID() method. Also, it is the ShoppingCart class that is adding the items to the shopping cart and has information about what items have already been added to the shopping cart.","This example is wrong because it is comparing cloning with initializing an object to another one. Cloning is actually necessary when creating new objects is expensive, not because making two objects point to the same memory location could lead to such errors. Cloning is used when an object is present and you need another one of that type. You can clone the original object to reduce the cost of creating a new object. Hence this example is wrong.","Advantage is that the instance variable of type Location can only be accessed by using a Person object. An object outside of the Person class will not be able to access the instance variable and modify it.Disadvantage is that a lot of objects are being created. For each Person an object of Person and Location are created, which increases the overhead.","Advantage is that the number of objects needed here is very less. A Location object is created only for a new location. If multiple people have the same location as their birth place, then only one location object is created and it maintains a collection of references to all those Person objects.Disadvantage is that every time we need to find out the location of a Person, we need to traverse each Location object's collection to find the required Person object. This could take a significant time. Also, if each Person object has a different location, then it does not help to implement this design.",Advantage is that all the required information is in one place. By using this third object we can directly fetch information about the Person and his Location from a single place. Disadvantage is that a third object is needed. It is an overhead.,"Since a string is used to represent the amount and strings are immutable, a new object is created everytime the value is used. To avoid this, we can have a mapping of the integer value $1 with a string say ""1USD"". Then we use the integer representation of the amount because integers are mutable and hence only one object is ever created.","The getAmount method can be modified to return the amount in different ways. We could make it a floating point number that represents the amount. Advantage is that all the necessary information is in a single object and we need to compute anything. Disadvantage is that it can cause round off errors.We could use two integers, one for dollars and the other for cents. Advantage is that it provides a good separation between dollars and cents. Disadvantage is that extra computation is needed to calculate the total amount.",Yes the getAmount method is need to retrieve the total money. The getAmount method returns the amount of money in cents. It can be positive or negative.,The multiply and dividedBy methods use plain doubles because if they used USMoney objects they would have round off issues. This is not the case in add and subtract methods.,"A template can be defined for what needs to be displayed. e.g. the amount, a symbol etc. But the way this is displayed can be left to each currency class itself. Each currency class follows the template of including the amount (which could use a period or a comma), and including the symbol for the currency (which could be at the start or at the end). So we can solve this problem by using the template method and creating currency classes for each currency and have them derive the template and implement their own way of displaying the amount.","If you never use the value, you don't pay for it.Initialization costs can be more spread out by not initializing everything at once.In some cases, startup appears to be faster.Ability to delay until needed information is available.",Code needed to check to see if it is time to initialize the value each time it is used.Time spent in the above code each time the value is used.Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.,"If publicly available instance variables are used, then if some change has to be made, then a change has to be made at every occurrence of that variable in the class. On the other hand, if a getter method is used, the change needs to be made in only one place.","The flaw with this design is that it exposes the internal structure of the collection. This is highly undesirable. On the other hand, by creating iterator objects we would provide a way to access a collection's elements without exposing its internal structure.",The observer is the person who is calling.The subject is the executive.,"The third scenario where you leave a message asking the executive to call you back when she is free is the one that is closest to the observer pattern. The reason is that the observer registers interest with the subject and attaches itself. When something changes in our Subject that the Observer may be interested in, a notify message is sent, which calls the update method in each Observer. So here, the observer has registered his interest by leaving a message. The executive who is the subject has to now notify the observer when she becomes free.",ActionListener interface uses the push model of communication. This is because the JButton notifies all the listeners that have registered. It is likely that some of those listeners do not need that information.,"If the requirement is for a change to take effect immediately after it happens, then the push model is desirable, since all listeners are informed and one of them can act.If the change need not take effect immediately, then we can use the pull model where the listener becomes aware of the change only after it polls the subject after the change happened."
,,,87,2,0,2,2,0,0,2,0,2,0,2,0,2,0,2,2,0,2,4,2,2,2,4,3,3,3,1,4,2,1,7,3,3,3,6,2,4,4,4
,,,,Strategy pattern,Decorator pattern,Composite pattern,Adapter pattern,Flyweight pattern,Bridge Pattern,Prototype pattern,"Template pattern - the same steps are carried out, the only code that needs to be modified is the method of comparison.","The class is not functioning as a wrapper class, it is providing the interface, not translating access to it for another class.",Abstract Factory Pattern,"Prototype clones the existing object to create the new object.  In this case, the implementations of the class internals are different.",Facade pattern,"The adapter pattern adapts existing code to a specific interface, in this case we are just ""simplifying"" the steps to access the underlying elements in the database.",Singleton pattern,"Only one object of each type is created, abstract factory would create a new object each time it was invoked","No, while the class provides getters and setters for each variable, it neglects to make the internal variables private.  By default, they have package level visibility.",0 <= hour < 240 <= minute < 60,There are two arrays (integer arrays) and they are the same length,"The top description does not explicitly state the the method operates on integer arrays, it is stated in the parameter description only.",Array B will contain all elements of array A in the same order.  All of B's old values will be lost,"Parameter conditions should not specifically name integer arrays as inputs, but just any object of type Array.To do this we would want to use polymorphism.","Shopping cart.  We do not want to expose the underlying implementation details to the Item class, so we can have the AddItem method in ShoppingCart search the array list of items for the selected item and perform the ArrayList insertion or, if the item already exists, to increment the quantity.  This would allow the functionality without breaking encapsulation.","All references in o1 are only shallow copied, so unless the clone() method has been implemented correctly, there will still be issues.","Advantage -- The information is stored with the person, the design is simpleDisadvantage -- The locations would not be tied to an underlying identifier, which would increase the possibility of data entry and make comparison, sorting, querying, and other functions among locations more complex.","Advantage -- Easy to compare locations, query based on locations, etc...Disadvantage -- Unless Person also holds a reference, it would mean brute force searching all locations to find what location is tied to a particular person.","Advantage -- Persons and Locations are now tied to each other in a two-way fashion, it is possible to go from a location to a person and vice versa.  Disadvantage -- More space used to represent the relationship","The flyweight design pattern could be used so that each ""instance"" of $1 actually jsut referenced the immutable $1 object.","I don't see the need for additional methods to return alternate representations, especially since the class contains a formatted output option.",This would return the underlying long integer which represented the value of the money.  This could be used in equality testing.,"The underlying representation is a long integer, which would introduce multiplication and division errors when dealing with fractional amounts of money. For example, $1 / 3 would yield $0.33, but what happens to that extra cent?  Depending on the context (or the size) of the calculation, this could be very significant.",In this case we could use inheritance to inherit all other money behaviors and override the display behavior to produce the desired output.,Saves time that may be used to initialize many complex objects that would not be used immediately.  Also can save memory space if each object is very large.,"The main disadvantage is that first time each object is used, it will need to be initialized, which incurs the execution penalty that was originally deferred.","It would be possible to modify objects that are in an invaild state, which would break the O-O contract that requires all objects to start and end in a valid state.","It would be inefficient for collections based on large lists (or any collection that lacked an index for random access), as the list would have to be traversed to the i-th element in order to return it.   Also, the iterator hides more of the implementation.  In the above case, we could assume that all collections were ""array-like"" because of the use of indicies, which would lead to assumptions about space usage, data access times, etc...  All these assumptions could lead to very inefficient designs.",Subject is the caller trying to contact the executiveObserver is the executive,Leave a message.  The subject's responsibility in the observer pattern is simply to notify the Observers by sending a message.  The Observer is free to take an action or not based on the message.,"Push, the ActionListeners are informed when the button is pushed, they do not check the state of the Jbutton.","Push - In an alarm monitoring system, each sensor would push events to a central controller, which would then determine whether to sound the alarm or not.Pull - Email clients on cell phones usually use a pull model so they can control how often they activate the radio, which can save battery."
,,,100,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,4,2,3,2,1,2,2,2,3,3,3,4,2,3,4,3,3,3,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy,Template,Composite,Adapter,Singleton,Bridge,Builder,Template Method -,We don't have an incompatible interface.We are abstracting similar behavior in various classes and duplicating,Abstract Factory,"With a prototype we specify the kinds of objects to create using a prototype instance, and then copying this prototype.We want to create a number of documents without specifying their concrete class.",Chain of Responsibility,"The Adapter pattern is used to wrap around a class with a desired interface.  Here we are simply passing a request from one handler to the next.  Each handler can modify the request, by processing what it can, and then pass the request to the next handler.",Singleton Pattern,An abstract factory is suppose to coordinate the creation of families of objects. While all of these dialogs might be of the same family it doesn't prevent more than one of the from being created.  The Singleton pattern is used to ensure that only one object of a particular class is instantiated.,"There is no public constructor.  public Time(int hour, int minutes) { // constructor        this.hour = hour;       this.minutes = minutes;    }","/*@invariant 0 <= hour && hour < 24; @*/ //class invariant/*@invariant 0 <= minutes && hour < 60; @*/ //class invariantonly class invariants given, no method invariants",/*@precondition 0 < A.length; @*/ //precondition /*@precondition A.length == B.length; @*/ //precondition No need to check the length of B if we check that A is > 0 and that they have the same length,"The name of the method is called copyArray which seems like it would copy any array, but it will only copy Int arrays.  It should be renamed copyIntArray or similar.  It's also not clear how the objects are going to be copied.  They could be copied or cloned depending on weather or not we want each array will now have its own object reference.",/*@postcondition A.length == B.length; @*/ //postcondition /*@postcondition foreach(int i in A) A[i] == B[i]; @*/ //postcondition,I will assume we are still passing Arrays since the method is called copyArray().  We must change the parameter type from int[] to Object,It is the ShoppingCart responsibility to determine if an item is already in the cart. It should not rely the Item class to determine information about its own items.  Items only responsibility should be to track itself and not other items.This follows the Expert pattern:  The object that contains the necessary data to perform a task should be the object that manipulates the data.,"One disadvantage with the design of the clone() method is that the return type of clone() is Object, and needs to be explicitly cast back into the appropriate type.o2 = (MyClass)o1.clone();Also, the default implementation of Object.clone() performs a shallow copy. When a class desires a deep copy or some other custom behavior, they must perform that in their own clone() method.",Potentially generates the greatest amount of objects.  Provides high cohesion and low coupling.  Difficult to find people born in location without searching all people.,"Less intuitive to think about, because you would think of locations and people as a one to many relationship.  Fewer objects and faster lookup to find locations total births.","Poor cohesion, demonstrates the god class:  it knows too much or and can do too much.No real association between the objects.","Make all instance variables private.Declare the class, or all its methods, final.Don?t provide any setter methods.Add singleton methodprivate static final USMoney = new USMoney(1);         // Private constructor prevents instantiation from other classes        private USMoney() { }         public static USMoney getInstance() {                return oneDollar;        }","If we used Int, this limits the possible return values to (2^31)-1 which may not be large enough.  If we used something like double, it would be too large and waste memory.","Yes, if we need to work in different currencies it is needed.",We need to be able to handle factions of dollars and cents.,Override the current ToString() method to display the third form.,"It is very easy to implement.If you never use the value, you don't pay for it.Initialization costs can be more spread out by not initializing everything at once.Ability to delay until needed information is available.",Code needed to check to see if it is time to initialize the value each time it is used.Time spent in the above code each time the value is used.If null is a legitimate return value it is possible to initialize several values.  You could use a placeholder object to signal that it has not been initialized to circumvent this.,An instance variable is a variable defined in a class for which each object of the class has a separate copy.  This would completely violate the Singleton pattern by creating more than one copy of the variable.,An Iterator provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.The main disadvantage here is that the iterator will have to access internal members of the aggregate.This violates the encapsulation principle.,Subject - ExecutiveObserver - you/caller,"Leave a message asking the executive to call you back when she is free.Publishers produce information that is of interest to other objects in the system.  The executive has information that we are calling to receive.  An object that is interested in a piece of this information subscribes to this publisher.  We subscribe by leaving a message.  Then when an event of interest happens in the system, a publisher sends it to its subscribers.  This is when the executive calls us back.","It uses the push model.  An observer that is interested in a piece of information subscribes to this Subject. Then when an event of interest happens in the system (button press), a publisher(aka Subject) sends it to its subscribers (aka Observer), or in our case the ActionListener.","We need a system where Observers delegate the responsibility for monitoring for an event to a central object, the Subject.  An example would be email on mobile phones.  The phone can use the Pull model and query the mail server every so often asking if there have been any updates.  Or you can use the push method and have the Subject tell the list of Observers (phones) that it has occurred"
,,,94,2,1,2,2,1,2,0,2,2,2,1,0,2,2,2,3,4,2,3,2,1,2,3,3,3,2,3,4,2,2,4,3,3,2,6,2,4,4,4
,,,,bridge,decorator,composite,adapter,flyweight,proxy,builder,"This is an example of the Bridge pattern. It abstracts the implementation of outOfOrder and swap, so that the BubbleSorter doesn't have to know anything about the internals of the array that is being sorted.","This is not an Adapter class, since Adapter classes are used to allow a program to work with an existing, incompatible interface without modifying it. In this case there is no such existing, incompatible interface.",This is an example of the Abstract Factory pattern,This is not an example of a prototype bacause it does not involve cloning a prototype object every time a new object of a particular class  is instantiated.,"This is an example of the Proxy pattern. The Database, Models, and Elements classes are all proxies that are implemented so that the application doesn't have to be concerned with the low-level details of interacting with the database, and can instead interact locally at a high level with the Proxy classes.","This is not an Adapter since at the lowest level, the database (lower case d) is not a class with an incompatible interface, but an external entity that must be interacted with.",This is an example of the Singleton pattern. Each type of dialog box can only be instantiated once.,"This is not an example of the Abstract Factory pattern because the client both knows and cares what type of object is produced, where as in Abstract Factory, the client does not.","No. According to Skrien, public methods should always keep objects in a well-formed state. It is possible to use the setMinutes or setHour function to set an invalid minute or hour, since hour must always be between 0-23 ad minute must always be between 0-59.",hour &gt;= 0 &amp;&amp; hour &lt;= 23 &amp;&amp; minutes &gt;= 0 &amp;&amp; minutes &lt;= 59,A.length() == B.length(),"The ambiguity about the behavior is what will happen when the precondition is violated, in other words, when it is passed two arrays of unequal length. Will it throw an exception? Will it do nothing and return? Will it partially copy the array? This should be included in the specification.","A.length() == B.length() ANDFor an array were A.length() == x and B.length() == x, then for all values of i in  0 &lt;= i &lt; x, that A[a] == B[i]",The change will have to be made so that array B is truncated or lengthened so that it is the same length as array A.,"This is the Expert Pattern from this year's Lecture 19: ""The object that contains the necessary data to perform a task should be the object that manipulates the data.""The class ShoppingCart should do this. The reason is that the ShoppingCart is the class that knows whether it already has another Item of the same _productID or not, whereas the Item itself is oblivious as to whether it is in a shopping cart or not or what shopping cart it is in and what other items are in the shopping cart with it.","This is wrong because o1 and o2 are just references to objects. The line o1 = null only sets the reference o1 to be null, leaving the object itself (which o2 also references) intact.You cannot explicitly destroy an object in Java, this is handled by the garbage collector, which will destroy an object once there are no longer any active references to it.","This is advantageous because it makes determining a particular person's birthplace very easy. The disadvantage is that every person object contains a location object, which depending on its size might be large and therefore an inefficient use of resources.","This is advantageous because it will make creating a ""census"" of the people born in a particular location very easy by simply enumerating each element in the collection. However, it makes finding the birthplace of a particular person very difficult, since it would involve implementing a ""wasPersonBornHere"" method and using it to query every Location object to find if the person being sought was born there, which would be a slow process.","This makes lookups where you know the person and need to find the birthplace and vice versa where you know the birthplace and need to find a list of people very easy since one object is aware of all people and all birthplaces. However, this is disadvantageous because it could be viewed as a violation of encapsulation, and any new instantiation of a Person or a Location must then be registered with the outside object.","This is an example of the Flyweight design pattern. The USMoney class could contain a static class variable oneDollar. Every calculation that returns a USMoney object, eg. plus, minus, times, dividedBy, negate, could use the following for its return statement:if (result.equalTo (oneDollar)) return oneDollar;else return result;","There is already one variation, that is the toString method, which returns the amount in a string format that can be used for printing.Other alternatives might be to have a getAmountDouble() which returns the amount in the format of a double. The problem with this is that doubles, being binary, cannot represent every fraction of a dollar exactly. They can represent a half dollar ($.50) or a quarter dollar ($.25) but not $.43 for example.Another alternative might be to have a method that returns the amount as an array containing an integer of dollars and an integer of cents, or to have two separate methods getDollars() and getCents(). This provides the same precision as the standard getAmount() method, however it makes computations more complicated.","Yes, it is necessary. this is a matter of encapsulation. The getAmount method is used in each of the methods compareTo, plus, minus, in order to get the amount to be compared with, added, and subtracted.Not only that, but only the truly rich would have money but never be concerned with how much, since they always know they have ""enough."" We want a money class that doesn't only apply to the upper class &lt;--- (joke)","There's no situation where you would ever have to multiply money by itself. The resulting units would be ""square money"" which makes no sense.However, it WOULD make sense to have:public double dividedBy(USMoney) to determine how many times a particular amount of money goes into another particular amount, with the result being just a plain number (double.) I consider this an omission of Skrien's USMoney class.","This could be done using the Interpreter design pattern. You could define a grammar for how to display currencies, and include it in a class that extends Currency. The interpreter pattern would be used to parse the grammar and display the currency as required. This allows you to define whatever currency display method you want, any display method will be supported as long as it can be expressed in the grammar.","This can make execution faster, or require less resources, in the case where an object is initialized but some of its instance variables are never accessed.","The disadvantages are that it may be desirable for all the work associated with initializing instance variables be done in advance, so as to not delay processing when the variables are actually accessed.Lazy initialization also introduces overhead, since the interpreter (or code added by the compiler, if a compiled language) must keep track of which instance variables have been initialized and which have not, and what needs to be done in order to initialize them.",You would not want them to be publicly available since they are not always valid.,The problem with this design is that it allows a user to attempt to access an invalid element in the collection.This can cause problems if the program tries to retrieve an element of an invalid index without first checking whether the invalid element exists. What would get(10) return when there are only 5 elements in the collection? How do we handle this?,The observer: MeThe subject: The executive,"The third option, ""Leave a message asking the executive to call me back when she is free"" more closely matches the Observer pattern. Leaving a message is akin to ""subscribing."" When the executive is free, she will call me, which is akin to the ""notification"" that takes place in the Observer pattern.","This is the Push model. In this case, the Observer is the listener, and the subject is the JButton. The JButton pushes every event to every listener that is subscribed when it happens, regardless of whether the listener will do anything with it or not.","A pull method might make sense where the information being passed from the Subject to the Observer is very large, so that the listeners only gather the information they need, when they need it.A push method would be better suited to a situation where all of the observers are likely to be concerned with most of the events that the observer notifies them of. This is also better suited to a situation where there are a large number of observers, in that thousands of individual observers polling the subject thousands of times per second might be a drain on resources."
,,,99,0,2,2,2,2,0,0,0,2,2,2,1,2,2,2,3,4,2,4,2,2,2,3,3,3,3,3,4,2,3,7,2,3,3,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Command Pattern.,Abstract Factory Pattern.,Composite Pattern.,Adapter Pattern.,Singleton Pattern.,Facade Pattern.,Memento Pattern,Prototype Pattern.,This does not have the typical properties of an Adapter viz. an interface for plugging in one implementation to another.,Abstract Factory Pattern.,"If this were a Prototype, one would not need to create a set of factory classes. Also there is no prototype here that needs to be cloneable.",Prototype Pattern.,This does not have the typical properties of an Adapter viz. an interface for plugging in one implementation to another.,Command Pattern.,Here executable code for different actions is encapsulated in the different methods. Abstract Factory is a creational pattern and this is clearly not in that category.,"This class is not well formed, because the Time state is a composite of hour and minutes properties. Suppose another object wishes to change the Time (and most likely wishes to update both hour and minutes). Between a call to setHour and setMinutes, the object is not in a well formed state.","Time timeObj;timeObj.setHour(10);assert satisfiesInvariants(): print ""class invariant not satisfied"".timeObj.setMinutes(30);",1. Arrays A and B must have the same length.2. Arrays A and B are integer arrays.,"Yes, it does not mention what happens when arrays A and B are both  null. As B is going to be overwritten in any case, sending this as an input to the method does not make much sense.",1. Array B will have a copy of data in array A.2. The order of elements in B is maintained the same as in A.,"Copies the values of array A into array B in the same order. Regardless of array B being passed, an array B of the same length as A will be created and then an order wise copy of A will be done. In case A is null, a message will be returned indicating the same.",This uses principle of locality of reference. I would get the ShoppingCart to decide whether two Item objects are the same. This is because the ShoppingCart would maintain a reference to the Item and it can query the Item using the get_productID method for the same.,"The primary participants of the Prototype Pattern are not present here. Although there is a Client (not shown in the example, but assumed here) which calls the prototype.clone method, there is no interface or abstract class (Prototype). Moreover, a ConcretePrototype that implements the clone method is missing as well.","Advantages:1. Logically, this makes most sense as Location is a property of Person.2. It helps keeps the Person and his Location objects in sync. Moreover, Location can be made a property that is initialized only with the constructor. Thus, it should not be set by any other method.3. From an Interface point of view, this is much better, as Person only uses the methods from Location that are essential.Disadvantage:1. Not much achieved with dynamic changeability here, since there is limited logical potential for a Location object to have a subclass.","Advantages:1. This can be a better design when one wants to collect information pertaining to a location more. Eg. Count of people, list of people born in a specific location. Compared to the first design, if these methods are required, this second design is better equipped.2. Dynamic changeability: Location can also use subclasses of Person and forward requests to these.","Advantage:1. Person and Location are loosely coupled.Disadvantages:1. All maintenance of Person and Location objects needs to be handled by this third object. Pointers between Person and Location objects can lead to significant overhead and inefficiency.2. If Location is updated, the third object needs to make sure that 3. More code is needed with this approach.","This can be achieved with the use of the Singleton Pattern. By creating a Singleton class with an instance method, only one object of USMoney can be returned when the instance method is called, even if repeatedly.","There could be a method that returns amount in terms of USMoney object i.e. $1. This would still need a decimal form of representation, with two digits after the decimal point being valid.Advantages:1. Gives a more readable format in terms of US Dollar amount.Disadvantages:1. Due to the roundoff errors with different primitive types, there could be different implementations possible with varying levels of accuracy.","This method need not be public, but it can be used for querying the underlying value of the currency.","While multiplying and dividing by USMoney objects, the integer representation can result in roundoff errors. As a result, even though a fractional value would be appropriate in some cases, we dont get the right answer if we simply use USMoney objects instead of using plain doubles, that can maintain the fractional information.","We can use a Decorator Pattern for this kind of situation. In this case, there is a Decorator abstract class or interface that has a toString method. This can be overridden by the country specific class that is derived from the Decorator abstract class/interface. Internally, the concrete class is free to implement the currency display in the format it chooses.","1. Is a more object oriented approach of creation and initialization, where these tasks are deferred till when needed.2. Can lead to more efficient object oriented code.",1. There is a time penalty associated with lazy initialization to access the variables being initialized.2. The init code could be spread over the class and occurs at an unspecified time.,"With a public access, any object that has a reference to this class instance can potentially use an uninitialized variable. This can result in unexpected behavior.","This design requires that the collections implement a get method. There could be varying levels of complexity in the get method implementation of these objects. Also, it is assumed that there is an ordered collection of variables in the object. Moreover, an iterator object is more suited for having different forms of traversal.",Publisher: ExecutiveObserver: Me,"Option 3: Leave a message asking the executive to call you back when she is free.This is because the observer is free to do other tasks while the publisher does his. When the publisher is ready, he signals to the observer that he is free.","The Push model for communication is used by the ActionListener interface. This is because the actionPerformed and notify methods are used to inform the observer that the mouse clicked action was performed. Moreover, the mouseClicked method when called, use the getX, getY calls to find out where the mouse was clicked.","For a push model: All possibly useful information is passed as a parameter to update, whether the Observer needs that information or not. This is when the Observer is doing some important activity and the data from the publisher goes and sits in the observer queue to perform an action when it is free.Pull Model: The Observer is only dealing with a single Publisher and so is interested in observing only a single subject's events."
,,,84,0,0,2,2,1,0,2,0,2,2,2,0,2,0,2,3,0,2,4,2,2,0,3,2,3,3,3,3,1,3,7,2,3,3,6,2,4,4,2
,,,,Strategy,Decorator,Composite,Adapter,Singleton,Bridge(possibly Mediator depending on if there are communications involved),Template Method,Template Method(PS > Description is quite confusing.  It seems like base class and subclass have same name.),"Adapter is where you write a ""wrapper"" to connect to and existing interface.  Here we are creating an abstract base class.",Abstract Factory,Prototype clones prototypical instances existing objects instead of creating new ones.,Chain of Responsibility(Could use Proxy pattern for connection to Database),Adapter is to connect to a single existing interface.  This requires multiple objects to receive request and pass it along.,Observer Pattern,Abstract Factory is used to create families or sets of objects when you don't know what kind of object you are going to create.  Here you know what kind of objects you are creating.,"No.  There is no check on the data that is being set.  You could send a value of 134 for the hour (or minutes).  According to Skrein, public methods should always keep objects in a well-formed state meaning that they should maintain ""internal consistency"".",The class invariant is that the class will always contain a valid 24hr clock time which means there are invalid values for both hour and minutes.,Stated Precondition:Arrays A & B (parameters) must be integer arraysArray B must have the same length as APreconditions not stated:Arrays A & B must exist (not be null)method copyArray() must have access to Arrays A & B,"There is no indication what happens if the arrays don't exist, are null or declared outside the scope of the method.  There is not indication of what happens if the two arrays do not have the same length or are both int arrays.",Array B will contain the values of Array A in the same orderArray A will remain unchanged,"If you are simply dropping the requirement that A & B be the same length then the postcondition would need to be changed to state what would happen if they are of different length.If the change is that you can pass anything (array, object, primitives), then there would have to be a host of new postconditions and additional code.","Item class should decide if two items are equal. (In this case it could easily be done in the ShoppingCart class since it has access to all the data, but what if there was a more rigorous test for equality?)Expert Pattern - the object that contains the necessary data to perform a task should be the object that manipulates the data.","First there seems to be a typo in line 4. I am assuming it should be o2 = o1;In the first group, there are two separate instances of MyClass created with the statement MyClass o1, o2. Therefore o2 will continue to exist after o1 is set to null.",Advantages - Seems the most logical. Each person can have only one birth place.  Easier to maintain.Disadvantages - If Person can modify Location this would cause a problem to any other Person that is using it.,Advantages - Can easily iterate through all the people born in a certain location.Disadvantages - Similar to above if Location can edit Person.,Advantages - One place to find relational informationDisadvantages - Violates DRY principle for data,"Singleton pattern.Add a USDollar object to the Money class.  Then when either constructor is used it can check if the USDollar is null, is so create, if not, return error.","It depends on the uses of the USMoney object.  If it is to be used as for display purposes where you might want xx.xx in numbers, then yes.  If just for calculations, maybe not.  Advantages are flexibility and other methods not needing to know how it is stored only what they need.  Disadvantages are additional code and maintenance.  If you try and please everyone, the code could get rather out of control.","Yes it is needed since USMoney is immutable and the variables are private.  It might be needed if you want to display the amount in any way other than that provided by the toString method.  Although calculations are provided for you and you want to keep the objects as USMoney objects, there might be an instance where you want to do calculations with the value.",The result would not be a USMoney object then - it would be a fraction or percentage.  Those methods could be provided if necessary (or could be performed outside the USMoney class with values from getAmount()).,"The book provides code you could use to build a string representing the currency differences (p. 181).  You could also the Interpreter Pattern to ""interpret"" the currency and know what needs to be done for that particular locale.",You can save time and possibly memory waiting to do until later.  You also may need to wait until you have some additional information.,You may forget or have some sequence that is not covered and then you are left with uninitialized variables.It also may interrupt other programming efforts if you have to stop and wait for the variables to be initialized.,The client would have to check to make sure they had been initialized and would then also have to know what valid values are.  This would require all users of the variables to do this violating several principles.,Every method accessing the collection would have to write this code violating the DRY principle.  You may also have synchronization issues if more than method is trying to access the code at a time.  It would also require the additional C.size() method.  It also may require the calling method to know more about the collection than it needs to.,You are the Observer; the executive is the PublisherYou are waiting for the executive's state to change from busy to free.,Call and being put on hold until the executive is free.  You have attached yourself to the executive's (phone).  When the executive is free you are notified that it has happened (and can now talk to her.),Push.  The listeners are notified when the button is pushed  - they are not polling the button to see if it has been pushed.,A pull method might be better if you have multiple threads running.  The thread that is currently active could poll for information instead of a controller trying to push to a thread that is not available.
,,,94.5,2,2,2,2,1,2,0,2,2,2,1,1,2,0,2,3,1,2,4,2,2,5,4,2,2,3,3,4,2,2,7,3,2.5,3,6,2,1,4,2
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,"Facade, by providing a unified interface to the numerical integration package to a set of interfaces that are used to pass in trig functions, poly functions, or exp functions.","You can use a decorator design pattern, where it has a basic class call Tickets, that you can add another functionality on top that adds footers, TicketsWithFooters, which is useful for Austrialia.  We can take Australia's TicketsWithFooters and add Headers, TicketsWithHeadersAndFooters, for the US, then add another functionality to TicketsWithHeadersAndFooters to have them in french and english, TIcketsWithHeadersAndFootersEngAndFren, for Canada.","The Circle-Ellipse Anti-Pattern where there exists a ""is-a"" relationship between containers and compenents, i.e. ""Container is a Component""",You can use the design pattern to provide a wrapper around the existing class to provide a usable interface and add functionality.,You can use the Singleton pattern which prevents the instantiation of multiple objects of the class guaranteeing one instance.,"You can use the Strategy pattern, by making the interface uniform for any user, and by defining a family of algorithms and enacapsulating each algorithm to make them interchangeable, where the algorithm used will be depend on the environment (Java VM and Linux or Java VM and Windows) in which the user is using it.","Momento, because it allows you to the ability to restore an object to its previous state.",Template,"Becuase it is not converting the interface of the class, but instead, it is subclassing and allowing subclasses to redefine certain steps of an algorithm without changing the algorithm's structure.",Decorator,"It is not the prototype pattern, since it is not utilizing a prototype, which only return an object of the same type of the original object.  Insteaad, it is using the decorator pattern by taking the basic DocumentCreator and adding functionality that would change it to a Fancy document or a Modern Document, where both would still contain the original functionality within the DocumentCreator class.",Chain of responsibility.,"Because it's not creating a wrapper class to augment an interface of some sort.  Instead, it is avoiding coupling by passing a request down the chain of objects until an object handles it and returns the necessary information.",Observer pattern,"It's not providing an interface to create collections of related or dependent objects.  Instead, it has defined a one-to-many dependence between keystrokes and objects, so that the observers listening for a particular keystroke combination can be notified.","IYes, it has a consistent interface, where the methods that do similar things are laid out similarly.",1<= hour && hour <= 120<= minutes && minutes <= 59,array B must have the same length as array A.,"I think the statement ""the old values in B are lost"" seems inconclusive, and should be restated as maybe ""the old values in array B will be overwritten with the values of array A.",the values copied into array B must be the same order as they are in array A.,"We must pass the length of both arrays to know when to stop copying values into array B, because if array A has a longer length than array B, then we may incur memory access errors.","The Shopping cart should do a check by going through it's list to check to see whether an item with the productId of the item being added already exists, and if so, it should call the get_quantity to get the current quantity and set quanity to store the incrememnted value.  The Item class does not have access to the list stored in the ShoppingCart, which also does not have methods to access the list.","The clone method returns the type Object, so in order for o2 to call the anymethod(), which is most likely defined in MyClass, it must be explicitly cast back into the appropriate type, which is MyClass.",Advantage: Easy access to a Person's location of birth.Disadvantage: We will have duplicate Location objects due to the possibility that more than one person can be born in a single location.,"Advantage:  We are able to associate one location to a collection of people, thus they can be easiliy identified if you are trying to locate everyone born at a particular location.  It also stores references insteaad of objects, which cuts down on memory usage.Disadvantage:  Hmm.",Advantage:  You only need need one object for each Location instead of a Location object for each Person object like the first option.Disadvantage: Requires a look-up table to be maintained.,Using the singleton design pattern by making the constructor private or protected and providing a public instance variable or method that creates the object exactly once.,"You could have it return the dollar and cents by adding public int getDollarAmount() and public long getCentsAmount(), which would be easier for the user get that information, but it would require either storing the dollar amount and cent amount and knowing when to increment or decrement the dollar amount when cents gets over 99 or under 0.","Yes, we can use it as a sanity check after we've done operations like add,subtract, multiply, or divide.",no idea,"You can create a class that derives from java.util.Currency that takes the fractional digits provided through its getDefaultFractionDigits class that also has methods that allow you to set the PreFix, PostFix, and delimiter for the currency to be displayed and concatenates the information with the fractional digits in string form.","- If you never use the value, you don't have to endure the cost of initialization.- Spreads out the cost of initialization by not initializing everything at once, which can put high demands on memory access.- Speeds up initialization in some instances.- Allows you to wait for information that may not be available at the moment.",#NAME?,"Because external objects accessing the instance variables may not know to do a validity check to see whether it has been initialized and may not have or know the information necessary for initialization, thus causing errors.",It violates the DRY principle by requiring the same method be duplicated within all collections.,The Observer is the caller and the Executive is the Subject.,"The third choice corresponds most closely to the Observer pattern, because the caller is delegating the responsibility of monitoring for an event, in this case, whether the Executive is free, to the Executive.  Thus, when the event occurs, the Executive is free, the Executive, the Subject, then tells the observer(s) that he is free by returning the call.","It uses the pull model, because the listeners are not polling the subject, in this case JButton, to see whether it has been clicked.  Instead,  when the button is clicked, it notifies the subscribers that the action as occurred, thereby, ""pushing"" the information from the Subject, JButton, to the Observers, the listeners.","A pull model would be suited for say a Power Supply GUI, where the GUI is the listener and the Power Supply would be the observer, and the GUI would consistently poll the Power Supply for it's voltage and current so that it can update it's display for the user."
,,,80,0,2,0,0,1,0,2,2,2,0,2,0,2,0,2,1,2,2,4,2,2,0,2,3,2,3,3,4,2,0,7,3,3,3,6,2,4,3,2
,,,,Strategy Pattern,Template Pattern for the Ticket,Composition Pattern,Adapter Pattern,Singleton Pattern,Abstract Factory Pattern,Builder Pattern,This is the template pattern because it has to follow the same steps to do the sorting. and it need someone to implement different OutOfOrder methods in order for it to swap different objects.,"Adapter pattern is used when there are incompatible interfaces, which does not apply to this case.",It is the Factory pattern because it create subclasses and have subclasses to implement the DocumentCreator; Subclass decide if it is modernDocumentCreator or FancyDocumentCreator .,It is not Prototype pattern because it does not require to create new objects for copying the prototype object.,"It uses Builder pattern because takes step to construct information. From Database, to Model, to Element, then finally get information.","Adapter pattern is used when there are incompatible interfaces, which does not apply to this case.",The observer pattern because each key press event notify the application to perform certain function. Each key press event must be subscribed to the main application for this to work.,"Abstract Factory pattern is used when you dont know what kind of objects you are going to create. But in this case, the list of objects such as Find Dialog box are already defined.","The class invariants can determine if a class is well formed. In this case it is not well-formed. Because:First, hour must satisfy condition where 0<=h<24Second Minute must satisfy condition where 0<=m<60.But in this class, hour and minutes can be any integer, therefore, this class is not well-formed.",0<= hour && hour < 240<= minute && minute < 60,Array B has no value and is used to store Array A's valuesArray A should be good for copying.All Array A's values are copied to Array B.,"The length of array B must be equal or greater than Array A in order for it to copy, otherwise array B cannot store all the values in Array A, which will fail.",Values in array A should be in the same order as Array B.The array B must have the same length as array A.,"We can change to ""Array A's values doesnt all necessary need to copy to Array B""","ShoppingCart class should be responsible for deciding whether two items are the same. In the expert pattern, the object that contains the necessary data to perform a task should be the object that manipulate the data. Therefore,  since the ShoppingCart has all the items information that we need to compare items with, we should let ShoppingCart class to do this comparing work.","First, this example is wrong because of a typo. I think the line object 2 = o1 should really be object o2 = o1. Then in order for o1.clone() to work properly, the MyClass class must implement the Cloneable interface, which in this case it doesnt show it did. Also, clone() does not apply to any methods. when we make a shallow copy of o1 using o1.clone(), it creates a new object and then copy the non-static fields of the current object to the new object. Therefore, any static methods will not be cloned. o2.anymethod() will not always work.","advantage: A person can get the location information qucikly, less code to write.disadvantage: Hard to implement functions to find all the people within a certain location.","advantage: can apply statistic on all the persons in a certain location easily since it has all the information it needs.disadvantage:too much information to manage. If given a Person object, it can be hard to find the location depending on how the collection of reference is implemented.","advantage:can access Person and Location information fasterdisadvantage:need to create a third data structure to store these information, Hard to design because you have to get a way to distinguish the different persons, you cannot really distinguish by name because people may have the same names.","When we want to make sure only one object is ever created, we can use the Singleton design pattern. First, we make the USMoney constructor takes an value argument representing the value of the money, such as $1. Then we can have a hashmap storing all the objects that we ever created. After that we use the Singleton pattern to make sure that only one object with that certain value is created. Basically every time it tries to create an object, it go through the hashmap and find out if an object with that dollar value is ever created. If so, return that object. If not, create a new object with that money value and save it to the hashmap.","Nope. Each method should do one thing only to achieve high cohesion. The way I understand the problem, the reasons why to return the amount in some form other than the number of cents returned as a long value is for money displaying or converting purposes. We should create a new method called Display or Convert to handle this change. Or create a new method for whatever that purpose is. Advantage:if we do this, we can have high cohesion and methods dont depend on each other. Easy to modify, easy to debug, easy to add new methods.Disadvantage:But with this approach, it requires us to write more codes. And there will be more methods created for that class.","Yes. First I am assuming that we will create money object for whole number only based on question a. like $1, $10, $100 dollars. I dont think it makes sense to create money object for like $10.03 dollar because we are going to have a huge amount of objects to maintain, which is a big issue. So because of that, we need to have the getAmount method to figure out what the exact values of the object in order to compare and convert money to different currencies. We also need it to do money addition, subtraction, etc.","Because when we do addition and subtraction, it will not lead to addition decimal digits. for example, when we do $ 10.05 + $10.99 = $ 21.04.However, when we do multiple and divide, in order to capture a more accurate result, we need to use double to capture the additional decimal places that it generates. for example, 1.01 * 1.01 = 1.0201. where it has 4 decimal places instead of 2.","In the Currency class in JAVA, we use country code to decide how to display the currency. So in this case, we can just specify the country code to display the currency in certain form. In addition, if we are focusing our Money class, we can also create subclasses of Money to represent different currencies. We can create a Money abstract class and have other money-form class extends to it. So if a new form is added, you can just create a new subclass of Money, which can override the toString() method and display the form that you need.",1. you can avoid creating the object completely if you never need it.2. the instance is not initialized until it is first neededIt will save memory.,"1. objects are created at any given time during the program, which has no control.2. it has time penalty associated with each access of the variable caused by the number of isNil test.","Because instance will be only initialized when it is first needed for lazy initialization. Any other classes may be depending on these public variables in order for them to perform properly, and timing is important for some of the methods. If we do lazy initialization, it will take time for them to initialize the public variables when they are needed, especially for variable that takes a long time to initialize, which will cause the other methods to under-perform, or even fail. So for these public variable, we should initial them at the very beginning so that they will be ready whenever they are needed.","since we are getting an Object object, we dont know what this object really is. It can be a String object, or Integer object, different objects have their own function, so we need to first distinguish what object it is before we can do stuff with the data. This will cause another data structure issue.",Observer is executive.Publisher is me.,"Call and be put on hold until the executive is free. is mostly closely to Observer pattern.First, observer pattern only subscribe once, therefore, the 2nd scenario is eliminated.Second, observer pattern waits until the processor process its request. For example, when you press a button in the UI created in JAVA Swing, it will wait until that work is completed before coming back out. If the work takes a long time, the window will freeze until the work is done","The ActionListener avoiding observer-specific update protocols: the push and pull models. Therefore, it uses neither one. It broadcasts instead.",when there is a one to one relationship
,,,85,2,1,2,2,1,0,0,2,2,1,2,0,2,0,2,3,4,1,4,2,1,5,4,3,3,3,3,4,1,3,7,3,3,2,6,0,1,0,0
,,,,"Strategy: If I am just playing around with points and want to use different algorithms to see which is ""best,"" then Strategy is the way to go.public interface AreaCalculator {  public abstract int calculate(Point[] points);}could be implemented by TrigonometricAreaCalculator, PolynomialAreaCalculator, and ExponentialAreaCalcuator.Template: It could also be Template depending on how the functions are defined... i.e. if I know ahead of time that the points are a polynomial, then I may choose to generate specific classes for polynomial, etc.","Template.I can create an AbstractTicketPrinter class which writes the header, body and footer. The body is a fixed method in the class, whereas the header and footer are hooks (empty but override-able, or they could be abstract but that would mess up Australia).",Composite.A leaf is a node is a leaf.,Adapter.I just need to change the look and feel of someone else's interface.,Flyweight.The flyweight can determine the values for all.,Proxy.Use a stub for me (the client) and a skeleton for the native OS.,"Prototype.I can leave the definition of how to build (put the wheel back on) somewhere else (the one still intact), and the clone it.",Template Pattern.,"An adapter just changes the way an interface is represented. BubbleSorter isn't being changed into another interface at all, it is defining a process.",AbstractFactory Pattern,"it does not have a ""clone"" feature, also the *Creator(s) are generating classes internally.",Proxy,"An adapter just changes the way an interface is represented, but this is providing access to another object (the database) from the Client.",State Pattern,"An AbstractFactory creates things, but this is opening existing features because the Find, Font and Replace windows are concrete classes.","No, because there is no check that hour and minutes are constrained to valid 24 hour time.Furthermore, the constraints are not mentioned in the method descriptions.",/*@invariant 0&lt;=minute &amp;&amp; minute &lt; 60; *//*@invariant 0&lt;=hour &amp;&amp; hour &lt; 24; */ --&gt; less than 24 because 24 == 0,Arrays A and B cannot be null.Arrays A and B must be instanciated.Arrays A and B must be the same size.,"int[] A, int[] BThe copyArray method is expecting an Array of integers, but this is not specified in the header.",Array B will not retain previous values.Array B will contain Array A's values in Array A's order,you'd probably want to use the Iterator interface rather than int[] A and int[] B,"Iterator Pattern: The shopping cart should determine whether or not _items already contains the Item, and likewise should increase the quantity of that Item. If the responsibility were on each Item, it wouldn't necessarily save any work for the ShoppingCart because it would still need to determine which Item to increment or if an Item was incremented.","The example implies that cloning is to be used to create a copy of an instance, whereas cloning is really used to generate a new instance of an unknown Type o1. Other benefits of the prototype pattern are that it hides the complexity instanciation and it can sometimes be quicker to copy than to instanciate (for example data needs to be read from a database during instanciation, but in a copy, it's not that difficult).","Disadvantage: I want to find everyone who was born in Wheaton, IL, but now I have to iterate over every person to determine if they were born there.Disadvantage: Each person is holding an instance variable of type Location =&gt; this can be expensive, and also confusing because there could be multiple instances of Wheaton, IL.Advantage: I don't necessarily want everyone to have access to my place of birth and this provides some privacy protection.","Disadvantage: It is difficult to determine where an individual was born because I would need to iterate over all the locations and then iterate over all the people born in those locations.Advantage: It is only storing a reference, and references are cheap.","Advantage: This can be used as a registry, where each Person and Location can look up where they were born or whom was born there, respectively.Advantage: Again, this appears to just be storing references, and references are cheep.Advantage: The third object could have a LocationFactoryMethod such that only one instance of a given location exists.Disadvantage: Potentially privacy?Disadvantage: Introduces a third object that would required an interface from the Location and Person objects.","Using the Flyweight Pattern. Any time a $1 is needed, the Flyweight creates one within it's Factory.","Yes, we should be able to get the amount in dollars as well... or possibly larger amounts ($1k, $1M).could use the strategy pattern to do this... the disadvantage would be the added complexity of determining which method is being used.","Yes, to ascertain how much money can be spent.","$ * $ = $^2 (dollars squared has no meaning).Furthermore, multiplying by a constant is really implying cost per unit, ($5/gal milk) * 2 gal = $10. but we leave off the gal milk part.","Using the Decorator Pattern.Then when I create an instance of Currency, I can wrap it in CurrencyDisplayDecorator, which will display the currency however the country pleases.Now... I think that java.util.Currency actually uses Template or Strategy based on the Locale supplied during intialization.","Memory allocation: If only section A is needed from objects [A-ZZZ], I can avoid using unnecessary amounts of memory by only initializing A when it is called.Time/Performance: If every object creation requires a database retrieval, this can be a strain on performance.",In multi-thread situations you need to be very careful.Lazy initialization adds some potentially unnecessarily complicated code.,"If the instance variable is available publicly, I do not have control over when it can or cannot be called. Therefore, a user could attempt to grab an uninitialized instance variable and get an exception all over their face.","It is tightly coupled to the implementation making it difficult to reuse.Also, if C is modified (added or removed) this would cause problems.Violates the D.R.Y. principle, ``with the *same* control structure.''","I am the Observer, and the executive is the Subject.",Leave a message asking the executive to call me back when she is free.Leaving a message ... executive.register(me)she calls me back ... executive.notify() { //calls me and I answer me.update(); },"ActionListener uses the push model.It was stated that when a click occurs (to the JButton object), the JButton object notifies (pushes) the information (that it was clicked) to the Observers.","A pull might be better if I have a text field (for example), after my user pushes ""submit"", I need to pull the text field for its data.A push is typically simple data (a button click, keyboard event) whereas a pull may require a more complex type (string, tabular, etc.)."
,,,94,2,0,2,2,2,0,1,2,2,2,2,1,2,0,2,3,4,2,4,2,1,0,3,3,3,3,3,3,1,2,7,3,2,3,6,2,4,4,4
,,,,Strategy,Template,Composite,Adapter,Singleton,Bridge,Memento,Facade,An Adapter lets one class use another. This is only abstracting out the implementation of a couple classes to a higher-level interface.,Decorator,"We know this isn't Prototype because we are not cloning the same object over and over, we are creating different versions (fancy, modern) of the base class (letter/resume).",Chain of Responsibility,This is not Adapter because there is obviously a flow of control going from the Client down to the information in the Element.,Builder,"Abstract Factory only deals with the creation of a single object. There are many types of objects described here, each complex and different from each other.","No. There are no checks within any of the public methods to determine if the values of the hour and minutes variables are valid and hence, well-formed.","If someone calls setHour(27), there is nothing to prevent this from happening. Since 27 > 24, the class would be in an invalid state since 27 is not a valid hour for a 24hr clock.",Each array provided by the client must be arrays of integers. The length of array A must be the same as array B.,"There is a lot of ambiguity around what will happen if something in the method goes wrong (ex: preconditions aren't met). Because of this, the client must guess what might happen and try to plan for it.",Array B will have the same contents as array A and they will be in the same order as they were in array A.,"If we removed the precondition that the arrays have to be the same size, we could remove the array B parameter and simply create an array in the method of the same size, copy array A into it, and then return the new array.If we removed the precondition that the parameters have to be an array of integers, we would need to change their type to Object arrays to ensure that the method will work on any type of array.","In this instance, the ShoppingCart class should perform the check to determine whether or not the item exists in _items ArrayList. This is an example of the Expert pattern where the ShoppingCart is the expert since it holds the current list of items in the cart and is passed the information for the item being added. Since it already has all the information needed, it should execute the check.",Setting o1=null in the first part of the post does not make the o2.anymethod() call return a NullPointerException. Setting o1=null only removes that particular reference to the memory location and does not disrupt the o2 reference.,"This implementation would make things simple because the Location is always stored with the Person. However, this would create a large amount of overhead in storage since two people born in the same Location would each have a copy of it.",This eliminates the memory overhead from the first example since references are fairly insignificant compared to duplicating an entire class. Unfortunately this would make it a little more complex to get at the birth location of a particular person given an instance of a Person object. Each Location object would have to be searched until the Person object was found within its collection.,This linkage table is good for having a central location where the birth Location for each Person is stored. This as well creates a little overhead when you want to find the location for a particular Person since you have to find the Person within the table.,The Singleton pattern could be used to ensure that only one object is created that represents a particular value of US Money.,"A getAmount method that returned dollars could be implemented. This would be useful if the application using the class only cared about dollars and not cents. This would probably end up introducing a rounding issue though. If an instance had 2 dollars and 99 cents and the getAmount method that returned dollars returns 2, then any calculation that uses this value would be way off of what that instance actually held.","The getAmount method would be good to have since it would allow the variables that hold the number of cents in an instance to be private. This provides us with information hiding and immutability, ensuring that the values aren't going to be manipulated and that the values will always be returned in the manner specified in getAmount.","When you add and subtract money, you are only going to add or subtract a value that can be represented by money. But the money value can be multiplied and divided by values that may not be representable by the USMoney class. For example, when calculating interest for a savings account, you may only want to multiply the amount in the account by 1/10th of a percent, which would be .001. This cannot be represented by a USMoney class and therefore must be represented by a plain double value.","You could implement the Decorator pattern in order to build the money display. Each step of the way, a different piece to the display would be added (whole dollars, cents, delimiter, code/symbol, etc).",It could save memory usage and processing time since the application may not need all instance variables in a class or may not need a class at all. This would cause an increase in execution performance.,"Some features may have slightly higher latency since they have to wait on the initialization. Also, this can add a level of complexity to the code and possibly make it harder to debug if an error occurs (was the object/instance variable initialized or not?).","Since they are public, they could be written to before initialization and therefore could cause race conditions on which value gets stored in the instance variable.","An object may not store its elements by a numerical integer; an example of this is a hash. Its key is an arbitrary value that could be an int, string or other value. Also, a programmer may try to iterate over an object that cannot be iterated over. Giving the class an iterator method ensures that can be iterated and that it will be iterated in the correct manner.",The Observer is me since I am trying to identify when the event occurs that the executive is free. The Subject is the executive since only she knows when she is free.,"The third choice (leaving a message) is the one that is the closest. The Observer attaches itself to the Subject by leaving a message. Once the event of being free occurs, the Subject notifies the Observer by calling them back.","This is an example of the Push model. The Observer registers itself to say that it wants to be notified when the event occurs. It does not constantly poll the Subject to see if it has been clicked or not. When the JButton is clicked, it pushes the information about the click to the listeners. It is up to them to decide whether they want to use any, all or none of the information provided.","An example of a good Pull implementation is a stock ticker. The information about the stocks changes very frequently, sometimes multiple times per second. Pulling the information every so often is much better on performance than having information pushed to you very frequently and it is most of the time not necessary to have the exact value at every point in time, only when it is required.The Push model is useful for events that happen infrequently and possibly not even at all. This prevents an application from making unneeded polls to the Subject constantly and just lets it wait for the event to happen."
,,,91,2,1,2,2,1,2,2,0,2,0,2,0,1,0,2,3,0,2,4,2,2,2,2,3,3,3,3,4,2,2,6,3,3,3,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy Pattern,Decorator,Composite Pattern,Adapter Pattern,Flyweight,Template Method,Momento Pattern,Strategy,"This is not an Adapter pattern because you are not creating a common interface to let client talk to another system which was not previously possible due to different interface. Instead in the above example you are creating a new abstract class bubblesorter and putting the sorting logic into it. Moreover, the Adapter pattern never changes the main functionality it just provides the way for two incompatible systems to communicate with each other with making huge modifications in each of them.",Abstract Factory Pattern.,This is not an example of Prototype because we are not merely cloning the letter or resume but also providing a way to create new and different kinds of letters and resumes. We can implement the DocumentCreator interface and produce a new kind of letter and resume whenever we want.,Chain of Responsibility,"This is not an Adapter pattern because you are not creating a common interface to let client talk to another system which was not previously possible due to different interface. Instead in the above example you are creating an application from scratch which is not adapter pattern. Moreover, the Adapter pattern never changes the main functionality it just provides the way for two incompatible systems to communicate with each other with making huge modifications in each of them.",State Pattern,This is not an abstract factory because an abstract factory in normal usage creates a concrete implementation of the abstract factory and then uses the generic interfaces to create the concrete objects that are part of the theme. But over here the creation of the objects depend on the input from the keyboard.,No the above class is not well formed because the variable hour and minutes can be modified outside of the getter and setter methods as they are not declared private. Also both the set methods should be private or protected so that no one from outside can change the value and the time display is always valid 24hr clock time.,hour should be greater than equal to 0 and less than 24minutes should be greater than equal to 0 and less than 60,1) Check to make sure the arrays sent are of type integer.2) Additionally the length of array B should be greater than equal to array A,Yes if instead of integer array an object array is passed of different kind the method parameters will try to cast the object array to int causing problems.,1) Length of array B should be equal to array A2) Array A should be entirely copied over to array B,Instead of passing an explicit integer array we can pass object array. And for the copyArray method we can change the type of the array from integer to object. That way we don't have to check to see it the array is an int array. This will let us pass anything and the method will still work.,"ShoppingCart method should have the responsibility of deciding whether two items are the same. The addItem and DeleteItem methods should check to see if the item is same or not. If it is then update the quantity of the already existing item. Additionally, as the items are stored in an ArrayList which implements the iterator interface we can use the iterator pattern to identify the items by going through the _items arraylist.",In the nonclone case MyClass o2 is never initialized or does not even point to the same location as o1. So calling a 02.anymethod() will surely throw a null pointer exception. Additionally in o2 = o1.clone(); we intialize the o2 variable and so after initializing o2 we can call the method on it. If instead of calling o2.anymethod() in first case if we had said 2.andmethod() than it would have worked. or if we had put o2 = o1 statement before o1 = null; o2.anymethod() it would have not thrown any errors.,The advantage of using this design is that you don't have to keep track of the location and can always query the person to find the place of birth. The disadvantage of using this that if you want to find out how many people have their birth place as a particular place than you have to query each person in the DB to find that out which can be expensive.,The advantage of using this design is that as said earlier it would be easier to compute queries like total number of people at a location. The disadvantage of this is that if you want to find a particular person than you have to go through the collection of references of a particular location which can be expensive but not like the first option.,This is a bad way to do it because for every query you have to go through the entire list to find things which is quite inefficient. On the other hand it gives you freedom from not carrying instance variables inside person or refrences to person.,Changing the toString Method to represent the money in $1 format.,Yes it should be changed so that it returns the value other than cents. The advantage of this is that you don't have to worry about conversion of cents to dollars. The disadvantage of using this is that you have to deal with fraction error or floating number errors when adding two numbers.,Yes we need the getAmount method. It will be used for getting the exact amount of money.,Because if we don't do that than it will produce errors and the final amount will be either less or little more than what is should be.,One way to solve this problem is to create a new class that extends from the currency class. Override the currency toString() method in the new class to display the currency in required form.,"The main advantage of using lazy initialization is to avoid long delays at the start of application to create and load the singleton classes. The other advantage is that if your objects uses lots of memory than it's better not to create the objects until really needed or sometimes its not needed at all. Additionally, if the object is expensive to create, you can defer its creation until after other expensive operations have been completed.","One of the disadvantage is initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion. Additionally, if you are running test to test this class than there is always a fixed amount of time penalty that is associated with the initialization every time you run a new test.",One reason is if we have a multi threaded system and have publicly available instance variables that are initialized lazily then we might end up with more copies of instance variables than needed. Also threads can overwrite the previous initialized instance unknowingly.,The main disadvantage of using the above style is that collection items like ArrayList already have get method and this can be confused with the those methods. Additionally when the entire code is written it will be hard to change the collection type if we use the above listed method.,The Subject (Publisher) in this case is the executiveThe Observer or in our case the concrete observer is the person calling the executive.,Leave a message asking the executive to call you back when she is free choice corresponds most closely to the Observer pattern. The reason for this is that once you register you call with the executive you just have to wait until the state of executive changes. ie. she goes from busy to free and then she will let you know that the state has changed.,ActionListener interface use push model. When a button is pressed an action event occurs and an actionPerformed message is sent to all action listeners that are registered on the relevant component. So the action listener that are registered with the component never pulls for the action events and always receive the message instead,The program requirements for a push model is that if you have many systems that are interested in getting notified of a change or if you want to avoid constant polling of the status. If you have limited resources and you don't want other system to use it much than its better to broadcast the status instead of other systems to pull it.The pull model is better suited when you have applications were timely notification is not required for the process to complete. For example in banking the bank don't have to sent out transaction complete or check cleared info. the customer themselves have to go check it.
,,,93,2,2,2,2,2,0,2,2,2,2,2,0,2,0,1,3,4,2,4,2,1,0,4,3,3,3,1,4,2,1,4,3,3,3,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,template method with the different steps to numerical integration abstracted,strategy,composite,adapter,flyweight,bridge,prototype?,template method,it's not an adapter,abstract factory,There methods are not built using clone,bridge,I'm not convinced it isn't,memento,abstract factory can't keep track of multiple commands it is,"Yes, there is a consistent interface, the similar format of getHour and getMinutes and setHour and setMinutes make it predictable. It might be a little better if they were both plural or both singular",minutes &gt; 0 &amp;&amp; minutes &lt; 60,arrays A and B must have the same length,no,the B array is identical to the A array,"the B array should not be provided as a parameter, rather it should be a locally created parameter within the method that is built based on A and then returned  public int[] copyArray(int[] A) { ... }","Item should have an equals method. in OO programming, the methods pertaining to a class should be encapsulated in that class .",The return type of clone is object. To use it as MyClass you have to first typecast it.,"This is convenient for accessing the location from a person object. However, there are many people with the same place of birth, so many location objects will be the same. Also, if you are trying to create a list of people born in a particular place you have iterate through all the people.","This uses less memory because if all the location data is stored like this, every person and location is used onceHowever, this makes it a little more complicated to find a particular person's place of birth. You have to look through each location's list of person references just to find the right person.","Assuming the table uses a hash or tree for both columns, this table would make it easy to find both the list of people for a city or the birthplace of a particular person. It also would use minimal memory compared to the first design. However, it is not as intuitive as the first method in terms of object-oriented design. It adds a little design complexity, for example, how do you update a person's date of birth if it is incorrect? There are a couple ways, but both add complexity of some form. You could have a lot of under the covers helper methods for foreign keys like those used in rails, which simulate the first design while using the third, or you make the user have to keep track of the table themselves as well as the persons and locations","using the singleton pattern,","No, one is sufficient. There are other alternatives such as keeping track of dollars and cents as two separate integers for dollars and cents with calculations done on them separately. This keeps accuracy, but you can't deal with fractions of a cent. Floating point numbers",it would only be used for calculations like for interest which need multiplication.,"because multiplication of money doesn't make sense. adding and subtracting represent actual values, but you multiplication and division are unitless factors.","using the strategy pattern, you can create a few classes that getMoney(Strategy) where format is some string. the symbol and the number of fractional digits and",saves resources until the object is needed,you always have to check if the object is nil whenever you want to use it,"they may be called before they are initialized, which would create errors. If that's the case this means the user of the class has to know the implementation, which is bad design","It doesn't have all the advantages of iterators. For example for lists and other structures that don't use random memory access using get(i) is more costly than an iteratorThis requires the collection to keep track of or compute its size which isn't necessary using iterators.Also, in this case the ""data"" variable may be troublesome because when you declare it as object, it will still not have the functionality you probably want unless it is typecast.",observer is the executiveyou are the subject,the third option because the subject in the observer pattern notifies the observer and continues its work regardless of what the observer is doing,It uses the push model because the JButton is the subject and sends out information to the observers when something happens,"If the listeners need to react to all information about the subject the push model should be used, For example, in expertiza, when a score (subject) is changed or created, the score updates a scorecache (observer), this uses the push model because whenever the score is changed it sends information to the scorecache.If the listeners don't need to react instantly to changes, they can use the pull model. For example, programs predicting weather  (observer) may use sensors (subject), but rather than the sensor using the push model and sending information whenever they change and flooding the weather program with insignificant data, the weather program will poll the sensors on fixed intervals."
,,,75,0,0,2,2,2,2,1,2,0,2,2,0,0,0,0,1,1,2,2,2,1,2,1,3,3,3,3,3,1,3,4,2,2,3,6,0,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy,Decorator or Template Method if printing the tickets involves different steps that are common among locales.,Composite,Adapter,Singleton,Bridge,Builder,Template method,There's no conversion of an interface into another interface.,Abstract Factory,There's no prototypical instance to create new objects by copying this prototype,Model View Controller,There's no conversion of an interface into another interface.,Command,Because there are no families of related objects that need to be instantiated from a single place in the code.,No because nothing prevents this class to return to a client an amount of hours that either negative or larger than 24 and an amount of minutes that is either negative or larger than 60,hour <= 23 && hour >=0 && minutes <= 59 && minutes >=0,A and B must be integer arrays.Array B must have the same length as array A.,It does not say what happens if the preconditions are not met.,Copies the values of array A into array B in the same order.The old values in B are lost.,If we want the method to work with any type of array we could generalize the signature to accept arrays of Objects.,The class Item has the data we need to check therefore according to the expert pattern the Item class should could provide a method to check if its productID matched the productID of another Item object.,"o2 is an instance of Object not an instance of MyClass.The anymethod() method could not be defined in Object.When calling methods, Java uses the actual type of the recipient obiect (o2 that in an Object)",Advantage: Person uses Location. Location and Person can change independently from each other.Disadvantage: if you want to know all the people born in a particular location you need to check all the Person objects,Advantage: it would be easy to know all the people born in a particular location.Disadvantage: tight coupling between Location and Person objects,"Advantage: flexibility, you can add/remove Person and Location objects easily in the system.Disadvantage: there's an additional class (the third) object to maintain",The USMoney class could be made a singleton,There could be a public int[] getAmount()where the first element in the array is the integer part of the amount and the second element of the array is the decimal portion of the amount,To return the amount for a particular currency.It would be used in both SimpleMoney and in MixedMoney classes.,There's no need to multiply and divide by USMoney objects.On the other hand you want to make sure that only USMoney objects get added or subtracted to USMoney objects (you do not want to add an Apple to a USMoney object). The compiler can detect such violations.,the Currency class could be 'decorated' to return the wanted values.,You create the instance only when it's needed. Can save load time if the instance being created is not trivial.,"if a resource needed for the initialization is not available, with lazy intialization you can only realize that the rsource is not available late in the program life cycle.",because they could be set from the outside before the lazy initialization occurs.,"You need to know some internals of the Collection, e.g the fact that Collection has a size. Also concurrency. Depending on how the get method is implemented,  two or more threads that need to iterate over the same collection might need need to lock the collection before using it and then unlock it when they have done with the collection.","you are the observer, the executive is the subject",Leave a message asking the executive to call you back when she is free. Because you register yourself as somebody interested in knowing when something happens and you get notified when that event happens.,Push,"Chat messages and sometimes files are pushed to the user as soon as they are received by the messaging service. So that you do not have to keep explicitly asking if there are new messages.Pull requests form the foundation of network computing, where many clients request data from centralised servers. Pull is used extensively on the Internet for HTTP page requests from websites. You pull information only if you are interested in that information and you do not get automatically notified only because some information is available."
,,,97,2,2,2,2,1,2,0,2,2,2,2,0,2,0,2,3,4,2,4,2,1,2,3,3,3,3,3,4,2,2,4,3,3,3,6,2,4,4,4
,,,,Strategy,Abstract factory,Composite,Adapter,Flyweight,BridgeInterpreter,Momento,Factory MethodCommand Pattern,Wrapper and one more class should exists which have no interface in common.,Abstract Factory,In Prototype pattern we do not know about class or any details of how to create required objects.,Mediator PatternChain of Responsibility,Because there is nothing incompatible between classes. All are related to each other(next one) to which it is delegated to.,State PatternCommand Pattern,"Since Abstract Factory, state is not maintained.","Yes the class is well formed since according to Skrien, an important property of methods is that they should be as self-contained as much as possible. In the above example each function justifies its name and does just that what its name says. All functions are to the point, short and do only one thing.",assert(1 <= hour && hour <= 24);assert(0 <= minutes && minutes < 60);,assert(lengthA == lengthB)assert(lengthA > 0 && lengthB > 0),"The function should be like this unlike givenpublic void copyArray(int A[], int B[]) { ... }The function should have  a return value 1 if the copy is been done successful and 0 if it has failed. Void doesn't give any idea if the copy was performed successfully.",assert (ArrayB equals ArrayA) != null;assert (lengthA != lengthB) returns null,There would be no check for length in the program. Irrespective of the length of both the arrays the ArrayA will be copied onto ArrayB.,"Item class should have the responsibility of deciding whether two Items are the same. Since according to the Expert Pattern ""The object that contains the necessary data to perform a task should be the object that manipulates the data."" Item class has productID required to compare if two items are same.","The above example is wrong because the purpose of cloning o2 was to produce same object but now since o1 is null, they are not same thought its not wrong and hence no exception.","Adv - Location is easily accessible.Dis -  If a person doesn't remember or know his place of birth, he will have to initialize the variable as null.","Adv - Easy access, can directly know for a particular place, which person was born there.Dis - Can be misused and its confusing if two people have the same location.",Adv -  Easy mapping.Dis - Unnecessary complexity.,public class USMoney implements Singleton{public static final USMoney instance = new USMoney();private USMoney() { }//...any other methods...},public long getAmount(Currency currency) Advantage - If you might like to know how much money of each currency is included.Disadvantage - not very good representation.public Float getAmount()Advantage - Floating point numbers have the advantage that you can represent far larger numbers and you can represent fractional parts of dollars conveniently.Disadvantage - adds complexity to the design.,"Yes getAmount is essential, by the very name of the class it seems so. When the class is about money the most important thing one would like to know is the amount.","1. Since we don't multiply or divide money in real world, we add or subtract them. As in Skrien - if you divide $1 by 3, the dividedBy method will return an array of 3 USMoney objects, the first one corresponding to 34 cents and the last two corresponding to 33 cents.2. multiply and dividedBy methods use floating point calculations and, as a result, have round-off issues to deal with so double works best.","public Money convertTo(Currency to, MoneyConverter moneyConverter, String symbol, int SymbolLocation){long amount = left.convertTo(to, moneyConverter).getAmount(to);amount += right.convertTo(to, moneyConverter).getAmount(to);symbol = "","";location = 10;return new SimpleMoney(amount, to, symbol, location);}We can have extra parameters to take symbol and its location. Another method can be to have SimpleMoney constructors, which have all these parameters, by default all null or zero. Individual currencies can pass values or leave it blank according to their requirements.",1. Lazy initialization support thread-safety. 2. Lazy Initialization is a performance optimization where you defer potentially expensive object creation until just before you actually need it.3. You can avoid creating the object completely if you never need it.,"1.  Time penalty associated with each access of the variable caused.2. Initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.3. Code needed to check to see if it is time to initialize the value each time it is used.4. Variables that are not frequently used are referenced and updated and could waste storage or give the garbage collector more work.","To ensure thread safety, save time and avoid confusion.","For the above example, the public Object get(int i) function is same for all the collections which have different internal structures. Since their structure is different all the collections need to implement the method differently and hence its underlying representation will be exposed.",Observer - ExecutivePublisher - Person,Leave a message asking the executive to call you back when she is free - By leaving a message you are sending the response to the executive saying that he needs to get back to you. In other methods thought the motive is same person is not actually able to send his response to the Executive.,ActionListener interface uses the Push Model because only when the observers register them with the buttons they can be notified of the Subject.,1. When it is required that we have to chose one model to perform an action according to that.2. When the mode of communication for each action needs to be known before performing it.
,,,88.5,2,0,2,2,2,2,2,0,2,2,2,1,2,0,0,1,3,2,4,2,2,5,2,2,2,2,3,3,2,3,7,3,3,1.5,6,0,4,4,1
,,,,Template Pattern,Decorator Pattern,Composite Pattern,Adapter Pattern,Singleton Pattern,Strategy Pattern,Template Method,"This is an example of the Template Pattern.  It defines the outline of an algorithm but allows subclasses and methods to do the work, that way different implementations of the individual steps (such as how to compare int or how to compare a string) and the corresponding methods for how to swap an int and how to swap a string are independent of the BubbleSorter class.",The adapter pattern converts the interface of a class into another interface a client expects.  The BubbleSort class is not expecting any specific object to be converted into another object for comparison and sorting purposes.,This is an example of the Builder Pattern.  The creation of a document is encapsulated in an object and the client ask the object to create the specific type of document needed.,"The prototype pattern allows you to create new instances of an object by copying existing instances of an object.  In this example, we're not wanting to create a copy of something that exists, but create a new derivation of something based on something else.",This is an example of the Command Pattern.  A request gets encapsulated as an object and the execution of the steps necessary to complete the request are issued sequentially to retrieve the data requested.,"The adapter pattern implements an interface its caller knows about encapsulating an interface its caller doesn't know about and providing the ""conversion"" or ""translation"" necessary.  The application above knows about each of the interfaces necessary to implement the application and the adapter pattern isn't necessary.","This appears to be an example of the Factory Pattern.  Each press of a specific button causes the appropriate dialog to be either created and displayed or if it already exists, to be displayed..","When you use an Abstract Factory, you pass code to the class that is used to create the the new class of objects you want to create.  Abstract factory is also used to create multiple instances of a new object, instead of the one object necessary for each of the key functions described above.","The class is well formed.  First, the class functions do not modify or affect objects of the class other than the object currently being referenced, i.e. there are no side affects on other objects that belong to this class when an object of this class is modified or used.  Second, the class has no invariants that can ""get out of whack"".  For example, the components and of hours and minutes are set and extracted separately and not from a combined variable ""time"".","The composite value ""time"" created by some combination of hours and minutes is a class invariant.  It has to be calculated every time Time() is executed since there is no code in the setMinutes() or setHour() functions to compute the composite time (which could save computing cycles).  However, creating the composite time each time Time() is referenced is the best approach because you don't risk getting the composite time out of sync with the set minutes and hours.","A and B must exist.  They must both be int[] objects, and the length of B must be the length of A.","Yes, there is ambiguity in the number of dimensions for each array.  A and B can be of the same length (memory allocation) but of different dimensions, for example, A may be int[5,10] while B may be int[10,5].  They are the same physical length but of different multidimensional size. This should be checked as part of the method.",B contains a copy of the contents of A,"The class could implement a method that allows it to create and return a pointer to a new object (such as a clone method).  Since the object knows about itself, it should theoretically be able to clone itself.","The ShoppingCart class is responsible for determining if an item is already in the shopping cart.  A shopping cart has many items.  An object of the item class is only one item, there is no method or paradigm that makes sense for an item to know if it is one or one of many items in the cart.  The variable for keeping track of how many items that go in the cart should be part of the cart, not part of the item.  Putting an item count in the items count could be an example of the Circular Dependency anti pattern.  While having the item count in the cart class creates low coupling and high cohesion.  Additionally, putting the item count in the item class violates the principle of Least Knowledge, in other words, the item doesn't need to interact with the cart, the cart needs to interact with the item.","Object 2 should clone object one.  The way the code is presented, object one appears to be cloning itself.  Object 2 should invoke the clone method with object 1 as the parameter.","When accessing data by Person, you have a direct access to the Location information regarding the person's place of birth.  That is an advantage.  A disadvantage is that each Person has their own instance of Location.  If there are 15,000 people who were born at the same location, then you'll have 15,000 instances of the same Location.  This isn't efficient in terms of memory utilization so can result in an issue with application scalability.","The advantage to this method is that each Location is only created once.  A potential disadvantage is the possible unlimited size of the collection depending on how granular the location is.  For example, if your location is by City (such as New York) rather than by Hospital and City, you'll have many more people in your collection for City than for City & Hospital. The other disadvantage of this organization is iterating through the collection of people to find someone specifically. Is the list stored such that you can search it quickly?  Another disadvantage is how do you find a person if you don't know their location?  Do you iterate through all locations to find the person?  This could be an issue, especially with application scalability.",This is probably the best design.  The table gives you the ability to index off of person or location.  The locations are only created once.  You can search either side of the table quickly/efficiently if the lists are maintained in a defined ordered.  A disadvantage would be the disk/memory/resources required to maintain the 3rd object/table.  This disadvantage seems negligible compared with the disadvantages of the other two methods.,The USMoney class could be designed as a Singleton.,"Yes there should be variations.  First there are occurrences of fractional cents in business, specifically with the stock and mutual funds markets and with fuel.  Stocks and mutual funds can be bought and sold in fractions.  When their price changes this can result in fractional cents if the security is sold.  Gasoline in the United States is priced to 3 decimal digits.","Yes.  It can be used to retrieve an amount for an object that has a value tied to another currency.  Or to a security who's value changes, such as stock, precious metals, mutual funds, etc.",Because we can lose precision.,You could use a Decorator Pattern and define a subclass and methods for changing the order or components.,You save time by not putting in explicit code in the application and potentially in CPU resources by not creating code that doesn't yet need to be executed.,You may forget to do the actual initialization later.  You're relying on run time specifics for the application that may be different from machine to machine.  Your code may not be easy to read if you expect others to follow the logic.,Some method may try to use the public instance prior to initialization if it is publicly available.  This can result in unexpected errors.,This design requires that each collection have a unique integer that identifies each object in the collection to that it can be iterated over.  What happens if you have a collection of tuples that strings?  You won't be able to iterate over that collection using this method.  This creates a coupling problem since the alternative to the iterator pattern is forcing a design consideration on the collection.,"the executive is the subject/publisher.  you, the caller, are the observer.","Leaving a message and asking for a call back most closely fits the pattern.  First, you're making the executive the subject.  Second when you call and leave your message, you're registering yourself to the subject. Your callback happens asynchronously so that you (the observer) are left to do other things until the subject calls you back.  The first choice looks more like a first in first out queue, and the second choice looks like polling.  This makes the third choice the best candidate for the observer pattern.",This is the push model.  Each listener waits for the button click to activate the method that calls each listener's actionPerformed method.,"A push model is a better implementation because the notifications only occur when the button is clicked.  If a pull method was being used and the observer was observing the button, then it would have to periodically check the state of the button to see if it is being pressed.  If the check wasn't often enough, or long enough, it would be possible to miss a button click.  Using a pull model is not only inefficient because of the polling necessary, it is also less reliable so it is subject to error."
,,,83,0,2,2,2,1,0,0,2,2,0,2,0,2,0,2,1,0,2,4,2,1,0,2,3,3,3,3,4,2,3,4,3,3,3,6,2,4,4,4
,,,,Template Method,Strategy,Composite,Adapter,Flyweight,Bridge,Memento,Template Method,"With Adapter, the intent is to change a single object's interface, while with the Template Method, the intent is to provide a common interface that many different types of objects can share in order to be able to delegate an algorithm to those objects.",Abstract Factory,"DocumentCreator provides an interface to create an object, rather than providing a ready-made object to be cloned as is normally done in Prototype.",Builder,"The intent of Adapter is to provide a new interface to an object. Instead, we're specifying how to navigate through a complex structure of objects to find a particular piece of information.",Command,"The intent of the word processor is to provide a separate behavior for each keystroke. Nothing is necessarily being created, as it would be with the Abstract Factory pattern.","Yes, the getters and setters have a consistent format between the two instance variables. The only thing I might change would be to use ""hours"" everywhere instead of ""hour"", so that it matches the plurality of ""minutes"".",/*@invariant 0<=hour && hour < 24; @*/,"A is an integer array, B is an integer array, A is the same length as B.","The method does not describe what happens to array A. So while we might assume that A does not change, the method does not guarantee that this will happen.",array B will have the same values that array A had.,"We would need a post condition saying either that B would be the same size as A, or that B would only include as many values of A as it could hold without resizing.",Item should have the responsibility since this promotes a more loosely coupled design.,"Setting o2 equal to o1 does not mean that o2 points to o1, but rather points o2 to the same location as o1. When you set o1 to something else, again, you're pointing o1 to a new location, rather than changing the object that o1 points to. So o2 will still point to the original MyClass object even though o1 is now pointing to null.","This makes it easy to look up a particular person's birthplace, but finding all people who were born in a particular place will be a time-consuming search. It doesn't make it clear that a single location could have many persons, or whether or not each person references the same location object or different location objects if they were born in the same place.","This makes it easy to find out all the Persons born at a particular location, and makes the one-to-many relationship more clear. Finding a particular Person's birthplace, however, will require a search.","This makes it easier to store Person and Location relationships in a database. However, both types of a searches, finding the birthplace of a particular person and finding all the people born at a particular location, will take some time, but conceivably this will be optimized to some extent in the database.",You could have USMoney provide a singleton for $1. The constructor of USMoney would then check whenever its initialized and return the $1 singleton instead of creating a new instance whenever the amount parameter in the constructor is 1.,"The number could be a double, which would make magnitude of the amount more obvious, but could lead inaccuracies in certain calculations. We could also return an object that has separate methods for getting dollars and cents. This has both magnitude and accuracy, but makes calculations more cumbersome.","If we have a need to do calculations using USMoney and other objects, then getAmount is needed. If, however, all calculations will be between USMoney objects, then it might not be necessary to have getAmount.","When multiplying and dividing money, the result doesn't represent money anymore. For division, the dollar units cancel out and you're left with a simple ratio. For multiplication, you basically have dollarsign^2 units, which, if they do make sense, still can no longer be considered normal money as represented by USMoney objects.","Using the Strategy method, you can create a CurrencyFormat interface and delegate the formatting of the money to objects that implement CurrencyFormat. Since currency formatting can be done easily enough with String.format, a CurrencyFormat object could take  a number, symbol, and number of fractional digits, or provide a properly formatted string.","You may be able to avoid the expense of creating the object altogether if it's never needed. If creation of the object causes a delay, that delay is moved from the initialization of the program to when it's first requested, when a delay may be more understandable.","If an object is referenced frequently, lazy initialization can cause additional overhead. You also have to make sure that it's thread-safe, which can be both difficult and expensive.","Someone might access the variables before they are initialized, which could result in null pointer errors.","The size method may not be defined for C, or may not be defined as expected. This also implies some type of ordering or the elements of C when an order may not be well defined. It's also much harder to standardize traversing multiple collections. This also isn't thread-safe; the collection could change while we're traversing it without notice, where an iterator would likely throw an exception.","You are the observer, the executive is the subject.","Leaving a message most closely corresponds to the observer pattern. You are basically subscribing to the executive so that the executive will notify you when the available event has occurred. This leaves you free to do other things until that happens, which is not the case if you're put on hold, or if you have to keep calling back.","ActionListener uses the pull method because when it gets triggered, it receives a reference to the event (instead of being passed useful information) and can then get whatever information it needs from that event.","Pull is best when you either don't necessarily know what you're going to need at the time of the subject event, or when it's likely that something will change and you'll need different information. Push is best when it's very clear that only the specific set of information is needed, or you want to have greater control over what information the observers actually get. Push may also be necessary in order to avoid reworking legacy systems."
,,,95,0,0,2,2,2,2,2,2,2,2,2,0,2,0,2,1,2,2,4,2,2,2,4,3,3,3,3,4,2,3,7,3,3,3,6,2,4,4,1
,,,,Strategy,Decorator,Composite,Adapter,Singleton,Bridge,Prototype,Template Method Pattern. This is very similar to the example on page 300 of Head First Design Patterns,"The Adapter pattern is used to convert the interface of one class into another expected interface, but here each class is using the exact same interface.",Abstract Factory Pattern,We are not cloning some existing object but rather creating new ones and each one could be a different concrete implementation of a particulcar interface.,Facade,"We are not trying to make database access meet some specified interface, but rather just simplify it.",Singleton (only one instance of a given dialog box exists),Because we only want one dialog box to exist (of each type).,"Not necessarily. In the way that the class is defined, the hour and the minutes can be set to any integer. So, for example, I could set the hour to 492 and the minutes to -998.",minutes >= 0minutes <= 59hour >= 0hour <= 23,B must have the same length as A.,"Yes, nothing is specified for the case where one or both of the arrays are null.",B must contain the same values as A in the same order.,"Change the signature of the method so that B is not passed in, and the return type is int[]. If A is null, return null. Otherwise, create a new array of the same size as A, copy all of A's values to the new array, and return it.","Item should have the responsibility of deciding whether two items are equal, because it contains the necessary data (ProductID) to do so. This is the expert pattern.","This example is wrong because setting o1 to point to null does not affect the object to which it previously pointed to. That object is still alive, and o2 still points to it. So calling o2.anymethod() will not throw a NullPointerException.","Advantages: This makes the most sense to me, because typically a Person knows the place of his/her birth, but a Location doesn't ""know"" all the people born there. It's easy to get the birth place of a given person. If we found that our records were incorrect and the person was actually born elsewhere, we'd just simply set the instance variable to a new Location object.Disadvantages: We'd have to loop through all the persons to find those who were born at a particular location.","Advantages: One could very easily get the list of all people born at a particular location. If the Location class had an address field, for example, and the address changed, all the people born there would have the update without any kind of looping.Disadvantages: If we found our records were incorrect and a person in the collection actually was born elsewhere, we'd have to loop through to find that person and move him/her to another location.",Advantages: We can perform fast lookups by Person or LocationDisadvantages: It doesn't show the has-a relationship between a Person and a place of birth.,Use the singleton pattern.,We could have a getDollarAmount method that returns the amount as a double (e.g. 4.50).,"I could see an argument for not needing it. What it would be used for is to convert the USMoney into a long and then, say, add it to another long. But the better alternative would be to convert an existing long into a USMoney and add the two USMoney objects.However, it does make sense for serialization, that is, if we are going to save the USMoney object in xml, for example, and then later reconstruct it.",Because it makes no sense to multply by a USMoney. Multiplying is inherently a floating point operation.,Use the decorator pattern. We could subclass the java.util.Currency class (or alternatively use delegation) and implement some interface that we will create. We will also create decorator objects that implement that interface. Different decorators could be made to display the currency in any form we'd like.,You can avoid performing computationally expensive operations if you never need them. Also you can delay performing some work at a time when the computer is busy to a later time when the computer might not be as busy.,"Everytime you access the object, you must do a check for the default value. Also, initialization code is spread around the class rather than centralized in the constructor.",Because then it would be possible to bypass initialization altogether and access the variable while still in the default state. This would undoubtedly lead to errors.,"In order to implement the ""get"" method for a linked list, one would have to loop through each node until the desired element is found. So ""get"" would be O(n), and so visiting each node in the list via a for loop (as shown above) would be O(n^2) This is far from efficient. An iterator object, on the other hand, can visit each node in O(n) time.",The executive is the Subject (or Publisher). I am the Observer.,"The third choice (leave a message and ask for the executive to call me back) most closely corresponds to the Observer pattern. When I call and leave a message, that is like me subscribing to the event. I'm saying that I want to be notified when the executive is free. Then when the executive changes state (he is free) he calls me back.","Push, because the the JButton (Subject) notifies all of its listeners and passes them information in the ActionEvent argument of the actionPerformed method.","If the change is small (such as simply, the button was pushed) or all the observers need the same info, then a push would be sufficient.If there are different kinds of observers that all need different information, then a pull would be better because each observer would only pull the info. it needs. Also if the Subject changes later and adds more state, then you don't have to go around and change all the methods (or ActionEvent arguments) that update the observers."
,,,111,2,2,2,2,1,2,1,2,2,2,2,2,2,2,2,3,4,2,4,2,2,4,4,3,3,3,3,4,3,3,7,3,3,3,6,2,4,4,4
,,,,Strategy,Decrator,Composite,Adapter,Singleton,Bridge.,Prototype,It is Façade.,Here we separate an interface that is simpler to use.  Adapter creates a new interface that make the old interface fit in with the new code.,Template Method.,Prototype creates new instance by copying the prototype. Here we have subclass implement the abstract methods. Two of the creators perform similar steps only altered by a little.,Chain of command.,"Here each handler can modify the request, by processing what it can, and then pass the request to the next handler. Adapter makes a new interface for existing code to fit with new code.",Interpreter.,Abstract factory deals with families of product that need to work together to produce a sensible output. Here we perform some kind of action by following different commands.,"The hour and minutes has no initial value. Also there is no condition check for setMinutes and setHour (minuntes should between 0 to 59, hours should between 0 to 23).",0&lt; hour &lt;230 &lt; minutes &lt;59,A and B must be integer array and A.length == B.length.,"No behavior specified if precondition is not satisfied, ex. A.length != B.length.",B has the same value of A.,"If A.length &lt; B.length copy A into B, only modify the first A.length of B, the rest is unchanged.If A.length &gt; B.length only copy first B.length of A into B.","ShoppingCart should keep track of number items. Item should not know what's in a shoppingCart. The Expert pattern applies, the object that contains the necessary data to perform a functionshould be the object that manipulates the data.","object 2 = o1; the code here doesn't make sense. I suppose it meant o2 = o1.It depends on how clone() of MyClass is defined, by default Object.clone() performs a shallow copy. Unless MyClass has override the clone() method to do deep copy, o2.anymethod() will still get NullPointerException.","Adv: Simple implementation, seach on Person would be easy.Dis: When two different Person have the same birth Location, mutiple copy of Location need to stored. This take additional memory spaces. List Person by location could be complicated.","Adv: No code/memory duplication. List person by location is easy.Dis: The reference list could get very large, location will need to handle complicated search functions to find the person.",Adv: Searches are easy.Dis: Additional maintenance needed when adding new Person.,Use Singleton pattern to create object to represent $1.,"If the method is used to run report for US Treasury, in cents would be really hard to read. We want it report in the unit of million dollars.The adventage of having different variations will make the result easier to ready by users under different circumstances. The disavantage is that if we pick the wrong variation by accident the result could cause fatal problems.","We need the getAmount method, because the amount is a private variable of Money class, we don't want to make this variable public. It's also more convenient to have the method, we can also report the unit and format in the output along with the value of the amount.","It makes sense to have two USMoney objects to add and subtract from each other, we can get a result of quatified USMoney object. ex. $100+$100=$200. It doesn't make sense to mutiply and divide a USMoney object by another USMoney object. For example, $100 * $100, ($100)^2 doesn't make sense, the unit cann't be mutiplied. Same reason we cannot add or subtract USMoney with double, because they don't have same units.","User Flyweight pattern. Make other currencies share the representation, make the country want to use third form an exception.","Only initialize instance if it is used, some time the cost of initializing instance can be high. Can start up faster. Can wait until needed information is available.","Code need to check to see if it is time to initialize the value each time it is used, the check could be time consuming.Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.","Because you can potentially modify the instance variable before the instance is initialized. By the time we need to initialize the instance, the variable might have been altered unwantedly.","With this implementation we need to know how the collection is implemented. For example, the implementation of get(int i) is different for a List and a Tree. Now we need to define get(int i) for each collection.","The executive is the Subject (Publisher), I am the Observer (Subsriber)","Leave a message asking the executive to call you back when she is free. This choise corespones most closely to Observer pattern, because executive will inform the subscriber when she/he is available.","ActionListener uses pull model. Because ActionListener is the Observer it needs to pull information from the Subject, JButton.","For example, if implement a drawing board add shape, the canvas implements ActionListener, the shape icon implements JButton. When a JButton is clicked, push model should be used to push information to the ActionListener.When a ActionListener needs to refresh the view it need to use pull model to query information from the JButton."
,,,92,2,2,2,2,1,2,1,0,2,0,2,0,2,0,1,3,3,2,4,2,2,2,2,3,3,3,3,3,3,2,7,3,3,3,6,2,4,1,4
,,,,Strategy,Template,Composite,Adapter,Flyweight,Bridge,Prototype,The pattern used is a template.,"The pattern used in the above example, removes the common functionality from the class and creates an abstract class with those functions. These functions can now be overridden by the base classes to implement independently according to their specific requirements. The Above pattern is not an adapter pattern . In an adapter pattern , an abstract class is created which helps another class to use an already existing functionality which might not be compatible as it is.",This is a Template Pattern.,A prototype pattern is used to create a clone of an already existing type. The above example does not create clones but creates concrete versions of a base class and its own implementations to the functions in each case. The base class(DocumentCreator) acts as a template to the child classes (FancyDocumentCreator or modernDocumentCreator),The above pattern is chain of responsibility.,"An adapter pattern creates an adapter class that helps a class to use already existing functionality in another class, even though it does not have any compatibility to the other class. In the above pattern , each request of a class is assigned to a new class based on the responsibilities of the classes. Thus the client class moves up in an hierarchy to fetch an element. Everywhere , the client class is interacting with all the other classes unlike in the Adapter pattern, where the interaction is done via the Adapter class.",This is an Observer Pattern.,"An abstract factory pattern is used to create a family of related objects for a client. In the above case, the font,replace,find etc dialogue boxes are already present. They need to be brought to the screen when an event such as CTRL+D, CTRL + F, etc occurs. Thus the word processor acts as the observer for the events and brings up the required dialog box.","The above class is not well formed as it does not test for the class invariants after every public method. Since the objects of the above class have to always display a valid time, it is necessary to check for the state of the objects between public method calls. This will help maintain the consistency of the objects of this class.",assert hasValidState(): this;,The preconditions should be as follows:1) The length of Array A should be equal to the length of Array B2)The data type of Array A and Array B should be the same.,There are the following ambiguities in the behavior of this method:1) The name of the method does not specify the types of arrays being copied. A client class could receive an error when two arrays of different types are passed.2)Does not mention what happens when two arrays of different types are copied.,"The postconditions can be as follows:1) The values in Array B should be same as the values in Array A after the function is called.2) The values in Array B should be in the same order as Array A.3) The values in Array A should remain as they were, before the function was called.",1)The object type of the parameters passed should be decided dynamically at run time. 2)The length of the values to be copied should be decided dynamically at run time.,"The Item class should have the responsibility for deciding whether the two items are same , since the Item class holds the values of the product Id of all the items. The class that holds all the information should perform the operation as well.This design is based on the Expert Pattern, which says that the responsibility should be assigned to the class that holds the information.","1)While cloning, the object has to be recast to the correct type:For example: Object O2 = (Object)o1.cone()2) In Java cloning is not supported by default.A CloneNotSupportedException is thrown. The clone() method implementation should be overridden.The following code should be added:class Object implements Cloneable  {   ...      public Object clone()      {          try      {              return super.clone();          }      catch( CloneNotSupportedException e )      {              return null;          }      }  ...  }","Advantage:1) The location of the person can be derived easily by calling Person.getLocation()Disadvantage:1)Every person has to initialize and store an instance variable of the type Location, even though all of them could belong to the same location.2)The person object should be responsible to store only the details of Person and not details of the Location. This is against the principle of cohesion.","Advantage:Advantage:1) The persons belonging to a location can easily be derived from the location objectDisadvantage:1) If a large number of persons belong to the same location , then all the person objects references need to be stored.2) The location class should be responsible for storing the details of the location and not the person objects.",Advantage:1) The values for the person and his location can be derived all from one place.Disadvantage:1)The data has to be copied from all Person and Location objects.2)The third object has to keep track of changes made in both objects: Person and Location and update its tables accordingly.,This can be done using the singleton pattern as follows.public class USMoney{private amount;private static final USMoney instance = new USMoney();private setAmount(){//Set amount to $1}public static USMoney getInstance(){return instance;}...}USMoney = USMoney.getInstance();,"Alternative variations could be:1) Return the amount as a Floating Point Number-Adv: Arithmetic is easier.-Dis:Might return fractional cents2)Return as two integers, one for dollar and one for cent.-Adv:No fractional values-Dis: Arithmetic becomes more complicated.",We need the getAmount method.The getAmount method will be used to return the value of the USMoney object in case of calculations and conversions without having to access the private instance variable amount.,"We avoid multiplication and division between objects , to avoid creation of fractional parts and rounding off. The multiplication and division of money objects could result in a scale that could exceed the expected scale of that currency.","We could create another class called displayCurrency which could be responsible to represent the different currencies in different format, based on the country and currency.This class could hold references to the Money class and the Currency.Each time a currency is to be displayed, the displayAmount() function of the displayCurrency class can be called .","The advantage of lazy initialization:1) Some objects may be expensive to initialize and thus their initialization can be deferred until they are required in the program2) In cases where we are dealing with a large collection of objects, all the objects do not need to be initialized instantly. They can be initialized as and when required. This results in a significant performance gain.3)Lazy initialization can avoid initialization of objects that you do not need.",1) The initialization occurs at an unspecified time. Thus the other objects are not aware of the state of the variable at a particular time.2) The variable will return varied values at different times.,"In case of lazy initialization, the time of initialization is not known for sure. By making this variable public, we are allowing it to be accessed at any point of time by the external code. Accessing the variable before it is initialized could lead to an error. Thus at different times in the code a different result will be obtained from that variable.","1) Multiple iterators cannot be created to iterate over a stack multiple times.2) When new collections are added, new code needs to be added to iterate through the collection.3)The caller of the function needs to know the datatype and the internal structure of the collection while calling the get function.",Observer: MyselfSubject: Executive,"The third choice:Leave a message asking the executive to call you back when she is free. The observer pattern defines a dependency between objects, such that, when the state of one object changes , all the dependent objects are notified. In the third case, when the state of the executive changes, you receive a call. Thus, you have subscribed to the executive.","Push Model.In this case, the subject is the Button, and the observer is the actionPerformed method.The method is called whenever the a button is clicked. Thus implementing a push model of observer pattern where the subject informs the observer whenever an event occurs for which the observer has subscribed.","1) Push Model:In a case where a UI has to be reloaded, whenever a refresh button is clicked, a push model is more suitable. This is better than the UI continuously checking whether the button has been clicked, it can wait for the button clicked action to notify it.2)Pull Model:For an application which requires the status of its inventory only during select times of the day, the pull model can be used. In this case the application will poll the inventory for its status only when required, instead of the inventory sending updates whenever there is a change in the inventory."
,,,96,2,1,2,2,2,2,1,2,2,0,2,0,2,0,2,3,0,2,4,2,2,5,4,3,3,2,3,4,2,3,3,3,3,3,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy,Decorator,Composite,Adapter,Flyweight,Bridge,Memento,Factory Method,No common interface exist. Wrapper and one more class should exists which have no common interface,Factory method.,Each document is derived from the simple abstract letter or resume and not cloned or copied.,Mediator,We are not converting or trying to match different interfaces. responsibilities are getting added to the objects dynamically.,State,"We are not creating families of classes. We have to encapsulate the command request(find, font, replace) as an object.",The class is not well formed as the functions will affect or modify the state of any existing objects as minutes might keep changing.,"A class invariant is a statement about the state of objects of the class between public method calls.  This can be done by making all constructors for the class need to return a well-formed object.   public Time(int hour, int minutes){      hour = this.hour;      minutes = this.minutes  }","1) length of array A should be equal to length of array B.2) B should be empty before copyArray is calledFunctions (that return a value) should not modify any existing object's state and modifier methods (that do modify one or more objects' state) should have ""void"" as the return type..",No check to the preconditions is made.,"1) Array A and array B should have the same values and in the same order.A=B; (""i.(0<=i<=A.length-1 => B[i]=A[i]);",B is empty should be removed.,"The class ShoppingCart should have the isEquals method that should be called immediately after calling AddItem(Item item). if the item is not present, AddItem should be done, else updateItem should be called to increament the number. The arrayList is maintained in the ShoppingCart class so it would be easier to iterate the arrayList in the same class instead of passing it around to the item class(single responsibility principle).",Because the o1.clone() performs a shallow copy. thus only the object reference is made null and not the method reference inside the object. to get a deep clone we have to implement our own clone() method and not rely on java's clone(),"--> advantage:- straightforward, every person instance will have its own location(place of birth)--> disadvantage- to get the place of birth, we will have to check with person object i.e. we need to return the instance    if(person.name.isEquals(""abc"")     return (person.location)","--> Disadvantage:- To modify any of the location details of a person, we need to iterate the whole collection and change the references for the Person- tedious.",Advantage:- simple to use. loose coupling.disadvantage-,"1)Make all init variables private,2)declare the classes and its methods final and3)do not provide any getter/setter methods.",May be we can have getAmount take two different currencies as parameters. the advantage would be to be able to add 2 different currencies but the disadvantage would be to implement such a method.,We do need a getAmount() method to return the total amount. we make sure that both the amounts that are added belong to the same currency. It can be seen that the mixedMoney class does not have the getAmount method.,"We multiply and divide while converting one currency to another. The multiplication and division is generally done with the exchange rate that is not a money object. Hence we use plain doubles for exchange rates. Also  for :-public Money times(double factor)	public Money dividedBy(double divisor)these two methods money class holds an instance variable representing the amount of money, then the times, dividedBy the methods can be implemented in the Money class with the factor in double.","In the java.util.Currency class we can use the static.getInstance() Singleton method . With this Currency class, we can easily display the money using currency symbol or the currency?s ISO 4217 code. We add the currency object from the Currency class to the Money class.the code below displays the money usthe currency code and a decimal point: public String toString() {String sign = (amount < 0 ? ""-"" : """");Long absAmount = (amount < 0 ? -amount : amount);String code =currency.getCurrencyCode();int fractDigits =currency.getDefaultFractionalDigits();int unit = tenToPower(fractDigits);if (fractDigits > 0) } return sign + absAmount/unit + "".""+ fill(fractDigits, absAmount % unit) + code; elsereturn sign + absAmount + code; where tenToPower and fill are auxiliary methods.(or) new implementation:- public class Money implements Comparable<Money> { private long amount;private Currency currency;public Money(long amount, Currency currency) { this.amount = amount;this.currency = currency; }public long getAmount() { return amount; } public Currency getCurrency() {  return currency; }public String toString() { ...above... }public int compareTo(Money o) { ... }public boolean equals(Object o) { ... }public int hashCode() { ... }public Money plus(Money) { ... }public Money minus(Money) { ... }public Money times(double factor) { ... }public Money dividedBy(double divisor) { ... }public Money negate() { ... } }",--> We can avoid creating the object if we do not really need it.--> No initialization time for features that are not used.--> application start up is quicker,"--> time penalty associated with each access of the variable caused by the ==null test.-->Lazy initialization should only be used if the initialization of the instance variable would take a long time, or  consume a significant amount of resources and there is a good chance the variable will not be used.","--> abuse of singleton pattern, we cannot make sure only one instance is created and available at any given point of time.",We need to know the implementation details of the collection and have to iterate each collection accordingly. Multiple navigation would be tedious as we cant allow multiple instances for computing cross products.,"Subject(Publisher)- executiveObserver- client, the person who is calling the executive.","Leaving the voice mail. This is similar to registering with the publisher. Once the executive becomes free, he will notify the person who is calling.",Push model since the information is passed from the subject to the observers(actionListensers()).,"According to the push model, user actions should be interpreted by the Controller which will generate the data and push it on to the View- example, user clicks on a  button anticipating a specific action.the pull model assumes that the user requires some kind of of output-examples:- when we need to update the changes in database to the views, we use controllers that pull the data and update the views."
,,,85,2,2,2,2,2,2,2,0,2,1,2,1,2,0,1,1,1,2,4,2,1,0,2,2,2,1,3,3,2,3,4,3,3,3,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy,Abstract Factory,Composite,Adapter,Flyweight,Bridge,Prototype,Strategy,I know it is not the Adapter pattern because the description doesn't say that the client needs to match existing objects to particular interfaces t.,Factory Method because we know what kind of object is going to be created i.e derived concrete versions.,"It is not the Prototype Pattern because the description states ..."" the system would have any number of derived concrete version of the DocumentCreator class""... which violates the Prototype Pattern solves the problem of needing to create objects but ""not"" knowing their class or detail of how to create them.",Chain of Responsibility,I know it is not the Adapter pattern because the description doesn't say that the client needs to match existing objects to particular interfaces that weren't originally compatible.,Singleton,I know it is the Singleton pattern because only one object can be mapped to the interface i.e. the dialog boxes at time. If it was the Abstract Factory many instances of the object i.e.  (dialog boxes) could be created.,"Yes, because the public objects are kept in a well-formed state. There is clear because each object is returned to a good predictable state at the end of each method.",when the class returns the time we can use an assertions to ensure that returned minutes object is not greater than 59 and hour returned object isn't greater than 23.,Array B must have the same length as array A.,"Yes. We don't know if B must have the same length as ""array A"" before or after the method is executed. It is possible","The values copied in to ""array B"" must be in the same order they were in ""array A"". The old values in B have to be lost.","We would not need to check to see if the length of ""Array B"" is the same as ""Array A"". Therefore we could just pass the contents ""of array A"" into ""array B"" without knowing if ""array B"" is large enough.",I think this is a Singleton Design Pattern because we are using a single shopping cart and each item will only have a single representation and only it's quantity will be changed. I think deciding whether two items are the same should be left up to the Item class because the Shopping Cart doesn't have access to the item ID.,"This example is wrong because of the reason provided for prototyping, and the bad example. This explanation should have stated that when a new object is created it must have a prototypical object. Then the example should have shown the parent class implementing the Clonable interface. Then the creation-initiating object should have cloned itself, producing an object of the correct class.",An advantage is the instance variable is always associated with the person and can be manipulated easily. The disadvantage is that a location instance variable doesn't clearly relate to a Person class.,An advantage is that locations relate to Person objects very well and  the connection make sense. The disadvantage is the amount of Locations can grow and drastically and the client would to know the locations in order to use the information.,This advantage of this implementation is that the type of information stored is already know and the fields are known. The disadvantage is that you don't know how to many elements will be need and based on the size of the table it can be computationally slow to find information.,"We could use to Singleton Design pattern to only allow the ""$1 object"" to be created.","Yes there should be, so that different forms forms of money and the types between classes can be used. The disadvantage of this is that the type of money you are converting too would have to be known and this is a very inelegant solution i.e. it would violate the Expert Pattern. The only advantage I can think of is that we could possibly have a higher level of accuracy based on the types chosen and precision chosen.","Yes, maybe with this $1 object we would like represent it in different currencies. Therefore we could create a getAmount method where we passed the currency that we wanted to convert the $1 object into different representation.  i.e. getAmount (int YEN).","Because when we are adding and substracting money we need to know the types of numbers we are producing. (float to int, int to int, etc). We we multiply we don't need to know the types because of the type of operation it is better to represent the values as plain doubles.","We could create an abstract class that held the money's numeric value (digital) that is related to some conversion factor. This conversion factor would be handled separately but continuously updated. Now we could develop a sub-class that contains all of the known representations of money and uses the conversion factor in conjunction with to countries  ""separating symbol"" to represent the money in the appropriate manner.","By putting off initialization until a object is used memory can be saved and in turn the program can run faster, especially if working with a language that employs garbage collection. By not initialization a object until its use the garbage collector can bypass that object therefore reducing computational time.","We have to be careful on machines with mult-threaded because there can be read/write hazards, etc.","To make sure that objects are not created in other way, the constructor is defined as protected or private.","By using a this ""for loop"" in such a specific manner the design does not hide the details of the implementation of the collection. Therefore to improve this design a common iteration technique that could function for any class would need to be developed where the client could traverse any collection, regardless of the actual class of the collection.",I am the Observer and the Executive is the Publisher.,"Leave a message asking the executive to call you back when she is free. ""I chose this answer because in the Observer Patterns, the Observer (me) delegates the responsibility for monitor for an event (executive becoming available) to a central object (Publisher i.e. the Executive)""","Push model because the Observer pattern is used, therefore when the button is clicked every register listener is notified.",The Push model is better suited for programs that contain many objects that can a large/diverse variance of information that is being produced by the Publisher. It is good to use this design pattern this way because it reduces coupling between objects.The Pull Model is better when many object are listening to a small set of information/actions yet they use the information from the event differently.
,,,94.5,2,0,2,2,2,2,1,2,2,1,1,0,2,2,2,1,2,2,4,2,2,5,4,2,3,3,3,4,2,2,5,3,1,1.5,6,2,4,4,4
,,,,Strategy,Template,Composite,Adapter,Flyweight,Bridge,Memento,Command,As we do not have an existing interface that we can design to.Here the outOfOrder  is called blindly by the sort method and does not bother on internals of the outOfOrder method. Here the adapter pattern is not used to adapt two incompatible interfaces.,Factory Method,"Prototype is used to create a prototypical instance, and then create new objects by copying this prototype.Here we cannot copy the prototype as we have different types of Documents like FancyDocumentCreator , modernDocumentCreator and they cannot be obtained from same prototype.",Builder,As we do  not adapt to any incompatible interface. Here we get Database then using this we get a Model and using this we get an Element. This is not possible through an adapter as there is no wrapper functionality involved here.,Builder,"Abstract Factory deals with creating a single object, while here we need to create a composite of objects like Font box, Replace Box and these are not related.",No the class is not well formed as the range values of hour and minutes is not checked.hour should be between 0 and 23 and minute is between 0 and 59.,The state of the variables hour and minutes between public method calls should be such that hour is always between 0 and 23 and minute is between 0 and 59.0<= hour <=23 and0 <= minute <= 59,Neither array A nor array B should be null. (null pointer)and The length of array A should be equal to that of B,Yes there is ambiguitysourceArray and destinationArray could be of incompatible types.If beginning of array B overlaps with end of array A then the values  towards the end of A gets garbled as it is overwritten. Hence we need to be careful while copying data for two arrays which have some overlap.,values of integer array A is copied into integer array B in the same order.,The copyArray should check if either array A or array B is null and return ArgumentNullException error message to user.,"The ShoppingCart  is responsible for deciding whether two Items are the same, because only it can look if item with same id has already been added to arraylist.The expert pattern and principle of least astonishment is used as only the ShoppingCart  knows the already added items.","Example is wrong as object 2 = o1 ;// ... Do some more processing.o1 = null;o2.anymethod()does not give NullPointerException as in equating objects only the reference gets copied. Even if o1 is made null, o2 still points to original object instance and thus o2.anymethod() will succeed.","Adv:Can quickly determine the birth location for a given person, by looking up Person.Disadv:Cannot list all person for a given location.",Adv:Can quickly list all the persons born at that location.Disadv:To find the location of a person we need to search each and every location to see if the person exists.,Adv:To find a person's location we can lookup this table which can be done quickly.Disadv:More space used in storing the information in this way.,"We can use a singleton patternpublic class USMoney implements Comparable<USMoney>{private static final USMoney instance 		= new USMoney ();	private USMoney () { }	public static USMoney getInstance() 		{ return instance; }}","The alternatives could be to have a) Two integers, one for dollars and one for cents  Adv:It is easy to implement and easy to read. One change does not interfere with one anotherDisadv:Difficult to interpret the actual amount.Convertions and calculations can also be difficult.b) Floating-point number  Adv:Manipulation is easier. If we have to add two forms of money, we dont explicitly need a new method that adds say cents and dollars separately. Is more accurate.Disadv:Don't need more than 2 dp to represent number. Therefore floating point not needed as wate of space.",getAmount  is needed for returning the amount in cents when we want to perform operations on USMoney Object like add two USMoney objects.,We cannot multiply and divide by USMoney objects as there would no longer be correct representation of USMoney object as we can have fractional cents and cents correct to more than 2 decimal places.By multiplying and divide by plain doubles we maintain accuracy.,"We extend Currency and create a new classpublic class CustomCurrency extends Currency{}Within this class we override the internal representation by having a choice of our separator, and where the  symbol should be placed (at beginning or end)We then pass the separator and position of symbol which   would be parameters for our new CustomCurrency class","Performance increases due to avoiding unnecessary object creation. We initialize the object only when it is needed.Reduction in memory usage, since objects are created when needed.This saves the overhead of calling the object  until it is needed.",Time penalty associated with each access of the variable caused by the isNil testThe initialization code is spread around the class and occurs at an unspecified time.,So as to ensure that nobody changes the single instance of the lazily initialized variable. This ensures object object creation happens exactly once.,"By using simple get method we are exposing the underlying collection. The task of the traversal is now on the collection which complicates the design of the collection , rather than having a separate iterator for it.By using get method, we do not know for which target class we will access elements from.Additionally if we want to have multiple gets eg) for computing cross product of elements then this design is not easily extendible.",Observer - callerSubject - executive,"Leave a message asking the executive to call you back when she is free. The observer - caller registers/subscribes  with the subscriber by leaving a message. The execute  - Publishers returns the call which is like producing information that is of interest to the observer.Then when an event of interest happens in the system, a publisher sends it to its subscribers.",ActionListener interface uses the push model as the Observer in this case the users of the JButton class all get notified only on the occurence of the event click. The Subject JButton  notifies all listeners via actionPerformed  whether they need it or not.Here the users of JButton are not polling for a click event therefore not pull model,Push model is used when a program needs to handle interrupts. It registers for interrupts and whenever an interrupt occurs program is notified.Pull model is used in driver code  where we poll until the I/O device is  ready (eg polling polling a parallel printer port to check whether it is ready for another character )
,,,94,2,1,2,2,2,2,2,0,2,1,2,0,2,0,0,3,4,2,4,2,2,2,2,3,3,3,3,4,2,3,4,3,3,2,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy,Builder,Composite,Adapter,Singleton,Bridge,Memento,State,"In the sorter class, whether the swap method to be invoked dependents on the result of outOfOrder method. So they can be treated as two states, out of order state and in order state. Within different state, we have different operations. It is not an adapter pattern because we are not hoping for combining two classes.",Decorator,"With the description, we can know that DocumentCreator can provide various objects such as fancyLetter or modernResume. These objects are not identical to Letter or Resume objects. While in Prototype pattern, we use clone() to copy the object but don't care its details. So it is clear that this is not an example of Prototype.",Chain of Responsibility,"Because every class has its successor class to deal with the appreciated methods. When a request comes, all of these classes deal with what they can do and then pass the request to the next class. It is not just like wrap a method in one interface to meet the requirement of another method in another interface for Adapter pattern.",Command,"In the example, one key combination related to one action. And according to keyboard enter, the processor knows which dialog box need to be showed up. While for Abstract Factory pattern, multiple objects are created without knowing the specification.","No, because the value of time has restriction. For example, the hour value so correspond to the range of 24-hour clock format. And the minutes value should have particular limitation.",0<=hour<=23; 0<=minutes<=59,A.length <= B.length;,"the length of A and B at the beginning may not be the same. If B.length > A.length, the B array has to be truncated. Else if  B.length < A.length. B array has to be extended.",B.length= A.length,B.length > 0;,,"Because MyClass doesn't implements the Cloneable interface, so o1 is not a prototytical object. So o2 is created correctly when we invoke o1.clone().","Advantage: Since the each Person object has its own Location variable, it is easy to manipulate the mapping. And the logic of the code is relative simple.Disadvantages: It may waste memory if the number of Person objects instance is large. And the duplicated code will be huge. Also, it is hard to sort with location if sorting is required in the future.",Advantage: It is easy to find which person belongs to the location through the collection in Location. Disadvantages: It may be problem if the number of person become huge. And it is hard to find the corresponding location in the Person class.,"Advantage: Reduce the number of object instances at the runtime which may save memory. And it can centralizes states for many ""virtual"" objects into a single location. And both person and location value can be evaluated if we need.Disadvantages: After applying the third object to keeps the table, all the single , logical instances of the Person class will not be independently from others.","We can use Singleton pattern to make sure $1 is created only once. To achieve this, we simply declare the constructor of oneDollar to be private. And add another method to initiate the oneDollar only if it has not been initiated.","Yes, the getAmount method should be able to accept different currencies and different format. The advantage of this is that we can use the same method no matter what currency is using. However, the disadvantages is increase the complexity of the code since the format of the factors for getAmount must covert to the same.","Yes, getAmount is used to get the sum of the same currency. No matter what currency is applied, this method should be remained. Therefore, we can either get the sum of only one currency or get the sum of all currencies after covert them to be the same.",we cannot divided by zero,"According to the situation, we can use the Strategy design pattern to solve the format problem. First of all, we will design the default format for the system, for example, $3.14. And therefore, any other format will be covert to the default one based on detecting the format used. And the Strategy pattern can help to covert the different format to default one by evaluating amount value, the currency type and the currency symbols. Different algorithms will operate their corresponding formats.","Can save memory because the object is created when it is required. In sometimes, objects are not used even thought they have been created which may waste time and memory. Another point is that the object may change before you use it. So lazy initialization can avoid this to happen.","One of the disadvantages of lazy initialization it may be time consuming for variables to do the object existing test. Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.","It is hard to control when the variables to be initialized at first. And if the instance variables will definitely be used later, I prefer to initialize at the beginning so that I don't need to worry about when to get it initialized.","We can not know the exact type of the the element we collect. So now it is hard to traversing different collection with one interface. Also, with this design, we violate the purpose of accessing contents of a collection without exposing its internal structure.",Observer: meSubject: executive,"The third one. In observer pattern, the subject add the observer into list and forward information to the observer when something happen. In the choice three, I will get the call when executive can call me. Meanwhile, there can be many other observers like me waiting for the call or update() in the observer pattern.","In the pull model. Because ActionListener is the role to receive the mouse click action. Only after it detect the action, can it perform relative methods",For any generic program
,,,78.5,2,1,2,2,1,2,2,0,1,0,1,0,0,0,2,3,4,2,4,1,2,0,2,3,3,2,3,3,2,1,7,3,3,2.5,6,2,4,0,0
,,,,strategy pattern,template,composite,adapter,flyweight,bridge,prototype,"Template.  The abstract class just creates a skeleton of what the bubble sort algorithm is suppose to do.  Other classes can subclass it to get more specialized results.  For instance, sorting integers in an array object.","With adapter, there is already an existing class.  With adapter, one would create a separate class to allow for the original class to work with another class.  In this example, we do not keep the old implementation and write adapter classes for every variation of the old class.",Abstract Factory.  The type of the object is not known before hand so we need to use abstract factories.,"If the prototype pattern was used, the Client wold not be aware of the different types of documents.  The new object would just be a clone of a typical object with the type of the object unknown.  This is not the case here.  The Client is aware of the different types of documents and uses the particular abstract factory for the object it wants.",Chain of Responsibility.  The responsibility is passed from one class to another.,The Database object is not an adapter between the model and the client.  The Database object merely delegates work to the model which in turn delegates work to the element.  The classes pass on the responsibility to another class.  Adapter pattern is only used when two classes need to talk to each other but are incompatible.  A third class is created to mediate between the two.  Here there is no adapter class.,This can use the singleton pattern.  There can be only one of each type of dialog box.,"Abstract Factories create new objects.  If an Abstract Factory was used, every time ctrl-F was pressed, a new window would appear.  We do not want that.  We want only one window of each type to appear.","No, this class is mainly made up of getter and setter methods.  If this is the desired outcome, a class should not be used.",hour is an integer number between 0 and 24,1. A.size == B.size2. A and B must be of type int[],"Yes, the method specifies that array A will be copied to array B but the actual implementation of this is not described.",1. An element at a given position in A must equal the element at the same position in B.  for instance:for(i = 0;i &lt; A.size;i++)    assert(A[i] == B[i]);,"A and B should be of type object in order to allow any object to be passed in, getting rid of the second post condition.  How the code is written, the first precondition is not checked so it will not break the code written.","The item class should have this responsibility.  The Shopping cart should not know about the exact implementation of an item and should not be able to access the item's variables.  This could violate the expert pattern.  Also, if the shopping cart were to test if the objects were equal, this would cause high coupling between the two classes.  If the Item class changed, it could break the Shopping cart class.","The prototype pattern uses a prototypical instance to clone new instances.  In the above example, a prototypical instance is not use but merely an instance that was created before.  Since both object are being changed at different stages, neither are prototypical.  The above situation just solves the problem of two pointers pointing to the same object.  The prototype pattern is to be used when an object is needed, a typical object can be cloned and returned.  Using the prototype pattern, o1 and o2 should be cloned from the same object rather than o2 being cloned from o1.","The place of birth of a person is easily accessible.  Each person knows where they were born without having to query another class.  The problem is if the Location class changed, this could break the Person class.","A person would not be able to figure out where they were born.  Also, if two locations have you in their collection, which one is correct?  A person can not be born in two separate locations.","This reduces the dependancies between person and location objects.  If the person class is changed, the location class will not be affected and vice versa.  This is the better option out of the three.  Also, this allows for person object to easily figure out where they were born and also location objects to easily figure out who was born in their location.","The constructor for the USMoney class can be set to private and all USMoney objects could be stored in a list of some sort.  If the user would like to get a USMoney object, he could call a class variable called getInstance and pass in the value he/she is looking for.  The getInstance method could then look in the list and if the object has not been created yet, it would create a new one and add it to the list.","1.  The getAmount() method could return a float value allowing the number of decimal places to be irrelevant since floats can represent any number of decimal digits.  The problem with this is rounding errors pose a problem.2.  The getAmount() can also return two long values.  One representing the ""dollars"" and one representing the ""cents"".  This would allow for one to represent as many decimal places as they would like while not having a rounding error.  The problem with this is each money object takes up more memory and there is added overhead in doing arithmetic on them.  If you add 1 cent to 99 cents, the cents has to go to 0 and the dollars has to change from 0 to 1.","yes, we would need the getAmount method to complete arithmetic operations.",It does not make sense to multiply and divide money objects.  The resulting unit would be money squared.  We usually multiply and divide money objects to add on a sales tax or calculate a sale price.  We also sometimes need to divide a price on bulk items to see how much they are individually worth.  All these numbers are of type decimal not USMoney.,"We could create a new class that contains a currency object.  When the object needs to be printed out, the newly created class can print it out the way it wants to while still retaining most of the functionality of the currency class.","The scope of variables are reduced, allowing for better utilization of memory.  Also, if an object is never used, it will never be initialized.  If we did not use lazy instantiation, this would be wasted memory.",there can be overhead associated to figuring out if a variable has been initialized or not.  This overhead adds time and complexity to a program.,You could not tell very easily when another class wanted to use the variable.  Therefore the other class would get some sort of error like a NullPointerException.,"This assumes that all collections can be accessed by an integer value.  This would not work for maps, where the key can be something other than an integer.  Also this allows for duplication of code.  Every time the collection needs to be iterated over, you have to copy the same for loop.",The observer is the person calling (me).  The subject (publisher) is the executive.,"The third one.  The observer becomes a listener by leaving a message on the executives answering machine.  The executive will notify the observer when she is free.  With the observer pattern, the publisher is suppose to notify the observers when an event occurs.  In the second example, the executive does not notify the observer.  In the first example, the executive notifies the observer but the observer is tied up waiting until the executive is free.  The observer should not have to stop what it is doing and wait for an event to occur.","This is a push model because when a button is clicked, all observers are notified and their action performed methods are invoked.  Observers do not have a choice in the matter.","It may not be feasible for an observer to be updated every time there is a change.  For instance, if a webpage is updated while a user is viewing it, the users page should not be updated.  The update should only occur when the user refreshes the screen.  This is an example of the pull model."
,,,94,2,1,2,2,2,2,1,2,2,2,2,0,2,2,2,2,2,2,3,2,2,2,4,3,3,2,3,4,2,2,3,3,3,3,6,2,4,4,2
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,strategy,Adapter,Composite,Interpreter,singleton,Bridge,Obersver,template,The adapter is creating an interface which is implementing all the methods in concrete different classes. The template pattern is creating an abstract class and do the general implementation in it and specify the different subclasses which extends the abstract class.,abstract factory,The prototype doesn't require the subclassing.,Chains of responsibility.,Chains of responsibility do the chains of events sequencially. Each event trigered another event until the right thing is found. The adapter pattern is used to create an interface to adapt incompatible interfaces.,Factory,"For Abstract Factory, when one key is keyed in, we don't know which type of dialog box is. But for the factory pattern, it is built inside the hierarchy, we will know the type of the dialog box.","No. We should make sure the hour and minutes are the right ones for the clock time. Otherwise the Time class will keep two different hour and minutes. And determine the hour is smaller than 24, and the minutes is smaller than 60 and both are greater than 0.",bool satesfiesInvariants(){assert Time.getHour() <= 24 && Time.getHour()>=0;assert Time.getMinutes() <= 60 && Time.getMinutes() >= 0;assert this.hour == hour;assert this.minutes == minutes;},if A and B has the same length. (if A.size() ==  B.size()),It is easy to be confused by which will be copied that A is a copyee or B is a copyee.,check if A's elements are identical with B's elements.,We can make precondition as {1==1}or {true},It should be in the ShoppingCart class since we need to compare the new item with all the _items inside the ShoppingCart. Because we need to make sure information hiding inside the Cart class and use the _items.public bool Equality(ArrayList _items){ for i = 0.._items.size    for j = i.._items.size       if(_items[i].get_productID() == _items[j].get_productID())                DeleteItem(_items[j])       end   end  end},The first one which is an assignment operator is also doing the same thing for cloning. So the first one won't give you an error.,"ad: each person object has one-one correspondence with each place of birth of location type. Easy to find person and their own place of birthdis: their location of birth is public to every one, not information hiding. And there is no need to make Location as a class, just a string would be enough. Also it is not able to use location to find some person.","ad: It is useful for the application which want to find all the persons' object who are in the same location.dis: sometimes, each location could have many people born there. It's confused for the location objects coupled with many person objects. might tight couping if sometime later you want to add something related to the location in Person object.","ad: it's more o-o based for storing person and its corresponding location objects. you can use person to find location, and use location to find person. Easy to organize the data and easy to search, delete and add.dis: space consuming.","When we first create an object for USMoney, we need to check if there is another object with the same amount of money using bool equals(Object o) function or we can compare the return value from getAmount() method in all the other USMoney object. If it has one, then we don't need to create it. We can add an attribute called value inside USMoney class to represent this $1 value.",We can return a pair including an integer for dollars and an integer for cents. ad: it is more organized to represent the moneydis: not accurate as long value.,"Yes, we can have a generalized format to represent money in long values. We can use getAmount method for comparation and converting between different currencies.","Since the application for multiply and divide, the factor and denominator may not necessarily to be USMoney, it could be any value for certain application for example, the number of person.",This can be done by adapter pattern. We can create an interface which list all the forms we could use of. Then in concrete classes for different forms we implemented different class which used the Currency interface. And then we can implement each form of the US money in each class.,"It is more safe to check whether the input is good or not. When it is appropriate, we can initialize an instance with good values or some initializations constructed inside lazy initialization.","Sometimes, we want to redefine the use of construction, for example we want to create an instance with some values or some types, not null. Then we should modify lazy initialization method for construction of an instance. It voilates the open-closed principle.",So outside world can not make changes of instances. They can only read the instance variables from getInstance() method.,This design is not space saving since we need to create each individual data for C objects. But if we use Iterator pattern we can save the space since it will directly iterate on C objects themselves. We could put the Iterator class inside the Collection C's class and directly use the C for iteration of each data.,Observer: Caller.Subject: Executive.,"The third one is closely to the Observer pattern, since it used the Hollywood principle: "" don't call us, we will call you"".",It i s use the push model since the JButton as a subject will notifies all the listeners ( observer) when the mouse click event is occured.,"For push model, if the observer is willing to involve in all the events from the publisher, then the push model is suited. For pull model, if the observer want to choose which event it is interested in. it has the ability to choose to receive the message or not receive the message. then the pull model is suited"
,,,85.5,2,0,2,0,1,2,0,2,2,2,0,2,2,0,2,3,2,2,4,2,2,2,1,2,3,3,2,4,1,1,7,2,2,1.5,6,2,4,4,4
,,,,visitor,Strategy,adapter,decorator,singleton,bridge,prototype,Template,The intent is not to convert the class/interface from form to the other but to form a base class. Hence it is not an adapter.,Abstract factory,Prototype pattern copies an existing object. However in the above example the intent is to create a new object.,Facade,The intent of the above example is to decouple the client implementation from any one subsystem. The client does not expect a change in the interface of one or more classes. All it needs is a simple interface which the facade pattern achieves.,Observer,The intent of the above example is to listen to the key presses and bring up the appropriate windows. Hence the pattern to be used is not abstract factory.,The above class is not well formed as there is no constraint on the values set for hours and minutes. The values of hours need to (0-23 in 24hr format) and minutes should be (0-59). There is no invariant to check these conditions.,"public class Time {  	int hour;  	int minutes;  	  	public Time() {  	}   	public int getHour() { return hour; }  	public void setHour(int hour) { 		checkCorrectness();		this.hour = hour; 		checkCorrectness();		}   	public int getMinutes() { return minutes; }  	public void setMinutes(int minutes) { 		checkCorrectness()		this.minutes = minutes;		checkCorrectness()		 }private void checkCorrectness() {    assert (0 <= hour < 24);    assert (0 <= minutes < 60);   }}",The length of array B should be equal to the length of array A.,"If the built-in length property is not available, then the length of the arrays to be used should be passed as an input.The method does not specify the handling of cases when the arrays are of different lengths.Other than these,there is no ambiguity.",The contents of array B should be the same as the contents of array A,"Instead of passing the array B as an input, a new array can be created inside the method with the same length as equal to Array A. Then the contents of A can be copied to Array B. Array B is returned as the output of the method.","It is more appropriate to have the class shoppingcart handle the responsibility of checking if two items are the same.Giving the responsibility to the Item will require the item to go through the list of other items in the shopping cart. Since the shopping cart has the overall intelligence, it is better to implement the equality check in the shopping cart class. The principle involved is ""Different kinds of responsibilities should be separated among different objects. ""","Cloning is used to build upon the current state of the object. If the current object itself is equated to null, then the purpose of o2 being created as a copy of O1 is defeated.","Implementation is simple. Easy to find the birth place of the person as the person object has the location instance variable.A modification of location, results in the modification of only one person object. However, location initialization has to be done for each person. Also handling of the query to find the persons born in a location is tedious.","Easy to find the solution for a query to find the persons born at a particular place. Since each location object contains references to a list of persons, the memory requirement is relatively low. However , given a person, it is tedious to find the birth place of the person. Also a modification of the location for a given person, results in the modification of two objects (The previous location object and the updated location object)",Provides loose coupling between the person and location objects.This design makes it easier to find the person at a location as well as a location for the person queries. However the overhead will be the creation of a large number of objects.,Singleton approach can be used to create $1 object and the instance of it can be used to make use of the $1 object.,"Since the basic unit of USmoney is cents, it is appropriate to getAmount in cents. If it has to be returned in any other value then a new method can be created which makes use of getAmount to return the money in the required form.",getAmount method is useful when there is conversion from one currency to the other.,The object should be able to multiply or divide itself by a given positive number or negative number. For example the object should be able to return the 5 times its value. 1$ x 5 rather than 1$ X 5$,"Since it is a currency specific difference, the information has to be held in the currency class.The currency class is responsible for knowing all the information related to the display of a currency. The java.util.Currency class has to be enhanced to include data related to format of the country's currency. This can be used by the money class to display the information appropriately.","1) If the value is never is used, there is no overhead of initializing the variable.2) We can delay the initialization until needed data is available.3) Since initialization is not in the beginning, startup might be quicker",1) Need to check whether the variable has to be initialized each time it is used.2) The recovery due to initialization failure will be expensive.3) the maintenance of inputs needed for initialization may be an overhead if they are not needed after initialization,"If the instance variables are available publicly, different sections of the code might change the value directly without calling the initializer.","This design with a linked list object will give very poor performance for each iteration. It will traverse the list from the beginning for every get. However if an iterator is used, the performance is better as it traverses the list from the beginning only once.",Subject : ExecutiveObserver : You,Leave a message asking the executive to call you back when she is free,"Push model of communication is used by the ActionListener interface,. Whenever a button is clicked, the Jbutton class passes an event with useful information to all the listeners registered with it. It is not a pull model, as the listeners do not poll the button frequently.","Requirement1: Massive number of observers and the observer need not process an event immediately.In such a case pull model is preferred as the observer can check for an event and process it whenever the observer wants to. Push model, in this scenario will burden the publisher by notifying each and every observer(Massive number of observers)Ex: POP3 email client uses pull model.Requirement 2: Event to be delivered to the subscriber as soon as it is generatedIn this case a push model would be preferred as the observer would be immediately notified upon event generation.Ex: Instant messenger servers pushes a new conversation as soon as it gets"
,,,87,0,0,0,0,1,2,1,2,2,2,2,2,2,0,1,3,4,2,4,2,2,0,2,3,3,3,3,4,2,3,3,3,3,2,6,2,4,4,3
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy,Template Method,Composite,Adapter,Singleton,Bridge,Prototype,Facade,"The abstract BubbleSorter class doesn't significantly change the class interface and isn't designed to match some other interface.  It still relies on the swap method to swap two adjacent cells.  The abstract base class does, however, hide the details of manipulating integers and arrays.",Abstract Factory,"This is not an example of prototype because a prototypical object is not being cloned each time createLetter or createResume is called.  Instead, when the createLetter or createResume function is called, a new object is created based on the concrete version of the DocumentCreator class.",Chain of Responsibility,An adapter would adapt the interface of a class to match the expected interface of another.  This example is of a request being passed from one handler to another -- through the specified chain of responsibility.  Each one of these objects contains the necessary logic to retrieve or process the object necessary to pass to the next object within the chain of responsibility.,Singleton,"The Abstract Factory design pattern would create objects of a type determined at runtime by the client.  This example only specifies one possible dialog box (class) that can be created for each input sequence.  Also, this example specifies that each type of dialog box can only be opened once, and that if one exists of that type already that the existing one will be used.","The interface for this class is consistent.  The return and parameter types of the getter/setter functions match the types of their instance variables -- as well as each other.  Unfortunately, the problem is that the precondition isn't enforced, which means that the class isn't well-formed.  The comment specifys that the class should always display (and therefore contain) a valid 24hr clock time.  This class will accept any integer value for either the hour or minute and store them in the instance variables -- even negative numbers!If the class specified that a demanding style of enforcement of the precondition was used, then it would be well-formed.  It is ambiguous whether this class or one of its clients is responsible for enforcing the precondition.","both hour and minutes are class invariants.  Although they should be declared private to ensure that no other class can modify them, their value should not be modified between method calls to the Time class.   If the enforcement of the precondition was specified, class invariants would be the range of hour (0 <= hour <= 23) and minutes (0 <= minutes <= 59).",Arrays A and B must be the same length.,"Yes -- it does not specify what happens if A and B are not the same length.  Specifically, the javadoc does not state whether this pre-condition is being enforced using the Tolerant or Demanding style.","1. The length of array B, when the function returns, is equal to the length of A (as it was passed to the function). 2. The contents of array B are equal to the contents of array A.","There are two options:(1) Weaken the precondition such that array B must be AT LEAST as large as array A. This would mean that the postcondition would change from ""the contents of array B are equal to the contents of array A"" to ""The first length(A) contents of array B are equal to the contents of array A""(2) Remove the precondition entirely.  This means that if array B is shorter than array A, only length(A) elements will be copied.  This means that the postcondition, ""The contents of array B are equal tot he contents of array A"" would have to be changed to ""The contents of array B are equal to as many elements of array A would fit into B if B is shorter than A, or The first length(A) contents of array B are equal to the contents of array A if B is at least as long as array A""","The ShoppingCart class should be responsible for doing this, because it contains the _items ArrayList.  This adheres to the Expert principle: the object that contains the data should be the object that manipulates the data.","This depends on the implementation of MyClass!By default, in java, Object.clone() performs a shallow copy, meaning it returns an Object with the same type as the object, and the same memory location. To fix this, MyClass would need to extend the Cloneable interface and implement its own version of the clone() function.","Advantage:This design ensures that each person can only have been born in one place. This design also allows people to easily know where they were born. Disadvantage:if many people are born in the same place, then care must be taken to not create multiple copies of the same Location. Locations need to be comparable, somehow. This design makes it somewhat difficult to create a list of people born in the same place, because each Location doesn't have any Person objects. All Person object have to be iterated over to create a complete list.","Advantage:This design lends itself to easily creating a list of all Persons born in the same Location.  It also makes it easier to avoid creating duplicate Location objects.Disadvantage:This design doesn't allow a person to know where they were born.  The Person has to iterate over all of the Location objects, and find the one that has a reference to that Person.","Advantage:This design easily allows for creation of a list of all Persons born in the same Location.  Disadvantage:This design makes it difficult for any Person object to know where it was born, or any Location object to know which Persons were born there.","If you create a sub-class of USMoney called something like ""oneUSD"", which specifies statically that its worth is $1, and then apply the Singleton design pattern, then only one object representing $1 could ever be created.  By creating a subclass, any other method expecting a USMoney object could still work properly if given an instance of the oneUSD class.  Additionally, it would be possible to create other objects of the USMoney class representing other currencies.  You would also need to use the Decorator pattern to modify the USMoney class to prevent it from instantiating a USMoney object with the value $1.","Yes, depending on the requirements of the application/customer.A real banking application would require fractional cents, probably using fixed-point notation.  This is for compounding interest; if a bank compounds interest very frequently, then either discarding fractional cents or rounding them will have an affect on the growth rate of the account balance. This has the disadvantage of being extraneous information for most uses, and requiring more memory. It would also be useful to have a separate method that returns only the dollar amount.  This cold be used as an optimization for verifying that accounts have sufficient funds before a transaction is conducted. The disadvantage of this is that it allows for more potential for mistakes; instead of there being a single getAmount method, there would be multiple implementations.","Yes -- a getAmount method is required.  In order to adhere to the Expert pattern, only the USMoney class should be allowed to directly access the instance variable storing the amount of money in the class.  If any other class wanted to work with USMoney that isn't an instance of Money, then this function would be needed.","I can't think of a real-world application for multiplication or division of two values of currency.  Bank transactions (withdrawal, depositing) are examples of adding or subtracting USMoney objects.  Things such as interest income, or stock splits are examples of multiplying or dividing a USMoney object by a double value.","Use the Template Method design pattern!The order of steps for displaying currency never changes:Preceding symbol, dollars, decimal separator, cents, following symbol, currency code.The result of these steps (which would be function calls) change based on the type of currency object.  Some of them could return blank strings.  For countries that like to have multiple representations, such as the $3.14 or 3.14 USD example, those would be two different objects of subclasses of the currency type; say DomesticUSDRepresentation and InternationalUSDRepresentation.  For example, DomesticUSDRepresentation would return ""$"" for the preceding symbol, ""."" for the decimal separator, a blank string for the following symbol, and a blank string for the currency code.","If an instance of an object is never used during the execution of a program, then it will save execution time and memory. Additionally, if lazy initialization is used, the programmer doesn't have to specifically ensure that they only create the object once, and that the object is created before it is accessed.","If not used carefully, lazy initialization could lead to mistakes.  Lazy Initialization will return either a new object or a reference to an existing object when called.  If a programmer is not aware that if they create an object of this type that it could be equal to another object, then this could cause an error.  As an example, they could delete the first object (or set it equal to null) and then attempt to access the second one.","One reason is the same as what I mentioned in the problem above: storing a reference to a singleton could lead to errors if the object is destroyed.  The second is that if a variable is initialized using lazy initialization, then it would be better to just call the initialization function again, instead of accessing the variable.  Checking to see if the variable has been initialized, before calling the initialization function (which initializes it) would not adhere to the DRY principle","This design assumes that the Collection can be easily represented or visualized as a flat array!  it would be awkward to implement this in some data structures, such as a binary tree.Iterators in java maintain some state; they essentially store a pointer to the most recently returned element within a collection.  The get() function, as described here, would have to seek through the collection each time it is called, until it reaches the ith element. Another problem with this design is that java's Iterator interface provides other useful functions, such as hasNext() and optionally remove().  hasNext() can return true or false indicating whether the entire collection has been iterated over, whereas the get() method might have to seek to the end and return a null pointer. remove() is useful for removing the previously returned object within a collection without having to get() it again.","The Publisher is the Executive.  The Executive is publishing their availability to their subscribers.  You (the person trying to reach the executive) is interested in their availability, or a timeslot, so you are subscribing to them.","The third option: ""Leave a message asking the executive to call you back when she is free."".  This is made more clear if you consider multiple executives; You can subscribe to multiple executives by leaving all of them a message asking them to call you back when they are free, and then you observe when each one of them is available by them calling you back. In the case of only one executive, you (the subject) are subscribing to the observer (executive) by leaving them a message, and when they call you back they are publishing their availability.","The ActionListener interface uses the Push model of communication.  This method is essentially a callback.  When an observer creates the action listener it is subscribing to the subject.  When the subject's action occurs (a button click, in this example), they execute the actionPerformed method, which is the same as the act of Publishing.  The actionPerformed method has a parameter (actionEvent), which the observer can examine to determine whether they need the information or not.","The best example of this that I can think of is using blocking vs non-blocking sockets. Say, for example, you are writing some sort of server application which must be able to handle multiple simultaneous connections.  If your server requires a low footprint and excellent performance, you might design it to run in a single thread.  This would be done using non-blocking socket methods, which follow the Observer pattern (the send/receive functions return immediately, and some other callback function is executed once data is available).  If, instead, your application required a concentration on user security, and you wanted to attempt to sandbox each client accessing the server using multiple threads, you could use blocking function calls in each thread for each client.  These functions would block the thread from executing until they had a return value, meaning until the data is either sent or received.  This would be more like the pull model; you could call a function in a loop that checks to see if data has been received, before calling the receive function and processing the data."
,,,98,2,1,2,2,1,2,1,0,2,2,2,0,0,2,2,3,4,2,4,2,2,2,4,3,3,3,2,4,2,2,7,3,2,3,6,2,4,4,4
,,,,strategy,decorator,composite,adapter,singleton,facade,memento,Iterator,The adapter pattern is used when you need to use an existing class and its interface is not the one you need.Here there is no such situation.The adapter changes an interface into one that a client expects.,template,The prototype pattern is used when creating an instance of a given class is either expensive or complicated.The situation should be such that copying an object can be more efficient than creating a new one.Here there is no such situation.,template,The adapter pattern is used when you need to use an existing class and its interface is not the one you need.Here there is no such situation.The adapter changes an interface into one that a client expects.,strategy,The abstract factory provides an interface for creating families of related or dependent objects without specifying their concrete classes.The intent of an abstract factory is not satisfied here.,"A good way to specify what makes objects of a class well formed is to list its class invariants.Here this is not present.Public methods should always keep objects in a well formed state.We can create a boolean method say satisfiesInvariants that tests some or all of the class invariants.If true is returned, then nothing happens, and execution of next statement follows.if false is returned, then assertion exception is thrown.",A class invariant must be a statement that tells about the state of the objects between public method calls.public Hour(int h) {                hour = h;    }assert satisfiesInvariants() : <error message>,The length of the array B must be atleast be equal to the array B.If not the array A cannot be copied into B,"It does not specify whether the two arrays have same size.Also if values of B are lost, should the array A be copied in ite entireity or should the method check for copying the missing values alon are needed.",The post condition should be that array B be identical to array after the method execution.,It is possible to weaken the precondition or also remove it to make things easy for the program.The post condition should be strengthened.The check for array elements in both A and B  to be equal should be enforced.,"the class shooping cart should do it.As the expert pattern says, "" the object that contains the data should be the one to manipulate it""","The class Object's clone() method creates and returns a copy of the object, with the same class and with all the fields having the same values. However, Object.clone() throws a CloneNotSupportedException unless the class you are trying to use it on implements the marker interface Cloneable. The default implementation of Object.clone() performs a shallow copy. When a class desires a deep copy or some other custom behavior, they must perform that in their own clone() method after they obtain the copy from the superclass. The syntax for calling clone in Java is (assuming obj is a variable of a class type that has a public clone() method):Object copy = obj.clone();For example Y varY1 = new Z();Y varY2 = (Y) varY1.clone();","When a person object has a instance variable of type locatio to store the persons place of birth, it does seem at first like a good idea.But the following could be encountered:there will be more than one person with the same name and the same location( actually location may not be a good choice for an object name here).If each person object has one instance variable, then this will lead to a lot of unwanted confusion.","Suppose each location keeps a collection of references to person object, the idea here seems a slight improvement from the above one.But, if a large population have there place of birth as the same location, it will only lead to a explosion of the collection table.It will be hard for maintainence.","The idea of a third object keeping track with a table of the person objects and their place of birth does seem as a highly advantageous one compared to the others.This will make the organization of data very simple and efficient.Also when search methods are implemented, it will be easy to traverse the objects to find the references quickly.","A class representing a value shuld be ideally immutable.The US Money class shuld overide the inherited equals method as in the Skrien book, to test whether two USMoney objects have the same amount of dollars.This equality test makes sense in the same way $1 is eual to 100 pennies.We can make all instance variables private.Declare the class or all it methosa fnal Dont provide any setter mutator methods.","The getAmount method will take currency value that will be the total of the dollar and cents.If this method is to be used in the mixed money and simple money classes, they must both call this method.Further, the UsMoney needs only 2 decimals for representing cents unlike some others that need 3.Since the getAmount method returns a amount in cents, it could be negative also.Other getter methods are also possible.The toString method can display the money amount in a standard format.","No the getAmount method is not the only possible one.We can have a other getter methods too.But it is important.For example, The simple money class that extends money needs the getAmount and the mixed money uses getAmount as follows:public long getAmount(Currency currency){ return left.getAmount(currency) + right.getAmount(currency);}","It is mandatory that 2 money objects belong to the same currency when adding.When we add two UsMoney objects are added it should result in a dollar value only.The arithmetic methods are listed as functions that return a value instead of void methods that modify the object.Since USMoney objects are immutable, the arithmetic operations do not change the current object and instead they return a new USMoney object with the new amount of dollars and cents.The times and divideby methods use floating point calculations and as a result have round off issues to deal with. A constructor taking 2 integers - one for dollars and one for cents , makes sense, as does a cnstructor that takes one long integer containing the amount of money in cents.","When the toString method is implemented, in the money class, it would not be a good idea to use a large if else stattement for distinguishing between the different layouts of different currencies.To solve the problem more elegantly, the first thing is to decide which object should be responsible for knowing such information.One way is to use a currency class, each instance of which represents a different currency that knows the necesary information including the ISO code, the number of frction digits , if a comma is needed as asked above.In short any other currency specific information.The getCurrency method , getSymbol method and getDefaultFraction methods are already there. The tenTopower and fill methods present are auxillary methods.The class just needs to be added the information on what the country's specification for the currency is right now.If that is altered there will be a solution.","Suppose the singleton object takes a long time to create and you dont want a delay durng the start up of your application. Or suppose the object uses a lot  of memory  and so you dont want to create it at all unless it is needed, the LAZY initialization becomes useful.We only need to make a minor change to our already exixting version.This approach avoids creating the one instance until the first time instance is called.","The main disadvantage of lazy initialization is the time penalty associated with each access of the variable . Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion. Lazy initialization should only be used if (1a) the initialization of the instance variable would take a long time, or (1b) consume a significant amount of resources and (2) there is a good chance the variable will not be used.",We dont want to make the instance variables that are initialized lazily to be public because:The singleton pattern's purpose is not to make objects globally available.The pattern should be used only in situations where the number of instances of a class must be limited .The scope of those instances should be as narrow as posible for example by restricting access to the singleton to the package in which it resides.,Advantages:An iterator allows access to an aggregates elements without exposing its internal structure.It takes the job of itereating over an aggregate and encapsulating it in another object.It provides a common interface for traversing the items allowing to use polymorphism when writing code.we should strive to assign only one responsibilty to each class.Using iterator relieves the agreggate of the responsibility of supporting operations for traversing its data.The problem with the above is that more than one user cannot traverse the same data at a given time.,The observer is : person calling Subject: Executive called.,The subject telling the list of observers is the best choice.the third choice is better suited.Leave message wait for call back,"The action listener uses push method.From the Skrien book example, the Canvas Editor needs to be notified by the canvas when a click occurs in the canvas.The way the observer pattern is implemented is - have objects that want to know when an event has occured attach themselves to the subject.When the event occurs, the subject tells its list of observers that it has occured.Reference--Class notes.The action listener interface has one method - the event listener superinterface has no methods.A listener/ observer that wants to subscribe  to mouse click events for example, that occur in a button needs to implement this interface and must register through the buttons add ActionListener method.","From the example in Skrien book, The amount of information passed as a parameter in a call to ""update"" can vary significantly in the Observer pattern.At on extreme, the observer already has a refeence to the subject , and that subject is the only object being observed by the observer.In that case, no information need be passes in the update method. and instead the observer can poll the sybject for the information.At the other extreme is the push model, in which all possibly useful information is passed as a parameter to ""update"", whether the observer needs it or not.When a button is selected, the button can let its observers know that it has been selected.This will be useful since the observers need not keep polling it.Also when changes are not going to be significant in a system, there will be a waste of resources if the observers keep polling at regular intervals.Instead pushing can be used.This way when change occurs the observers will know."
,,,87,2,2,2,2,1,0,2,0,2,0,2,0,2,0,2,1,1,2,4,2,2,2,4,2,2,2,3,4,2,3,4,3,3,2,6,2,4,4,4
,,,,Strategy Pattern,Template Pattern,Composite Pattern,Adapter Pattern,Prototype / Singleton pattern,Visitor / Decorator / Bridge / Visitor pattern.,Memento / Bridge pattern,Template pattern,"This is Template pattern because there is a well defined sequence of operation to be performed for sorting which includes outOfOrder and swap methods. The BubbleSorter abstract class must look like this:public abstract class BubbleSorter{public void sort(){public boolean outOfOrder();public  void swap();}abstract public boolean outOfOrder();abstract public void swap();}Here, the class which will extend the BubbleSorter class needs to implement both outOfOrder and swap methods in a particular fashion in which swap succeeds outOfOrder.In case of Adapter Pattern, we need to define an implementation which handles the incompatibility issues between two interfaces which is different from the explanation given above.",,,,Adapter pattern is basically converting an interface to another interface that a client expects. In this case we do not have to do such conversion for compatibility reason,Command pattern,,The class fails to implement the encapsulation principle of object oriented approach. The instance variables should be made privateThe access to getter and setter methods from outside the class should not be permitted.In this case the other classes that are contained in the same package can modify the methods because they have the default access specifier.,"/* Objects of this class always display a valid 24hr clock time */public class Time {  	private int hour;  	private int minutes;  	  	public Time() {  	}   	public int getHour() { return hour; }  	private void setHour(int hour) { this.hour = hour; }   	public int getMinutes() { return minutes; }  	private void setMinutes(int minutes) { this.minutes = minutes; }}",The precondition for this method are as follows:1. The Array A should not be empty2. The length of Array B > = Array A i.e the size of Array B should be greater than or equal to the size of Array A.,"I think there is ambiguity in the name of the procedure. After reading the name of the method it gives an intuition that Array A's contents will be appended to Array B, while the contents of Array B will remain unaltered. However from the comments we can conclude that the contents of Array B will be lost. I feel this is a clear violation of the principle of least astonishment.",The post conditions are stated as follows:1. The new length of the Array B will be the same as the length of Array A. 2. All the elements of Array A will be copied to Array B.,Following are the conditions that needs to be removed so that the method can pass no matter what:1. Check for the size difference between Array B and Array A2. Also check if the Array A is not empty.,"It should be ShoppingCart class which will compare whether two items are same or not. The principle that applies here is High Cohesion. Also, as per Design by Contract principle, it is the responsibility of ShoppingCart class to perform operation on item objects.",,"Advantage: 1. Composition is preferred 2. Person object can reuse the same location if it already existsDisadvantages: 1) In case multiple persons are born at same place, we are duplicating the data for location variable.Instead we can use location collection that stores the person objects born at same location.",,,,,,,,"Lazy initialization is the process of deferring object creation until you actually need it. Advantages:1. Users do not have to pay for the initialization time for features which they do not use. 2. Lazy initialization also speeds up start up. For example, suppose you need your application to initialize everything at start irrespective if you use the components or not. This will take a lot of time in comparison to deferring initialization until you actually need it.","The disadvantage of lazy initialization is that:1. The initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.2. Your code becomes more complex because you need to check to see if the attribute has been defined yet and, if not, obtain its value",In certain applications where you want to store some value when an object is created i.e the default value of an object the lazy initialization approach is not very helpful because it delays initialization thereby providing null records in database tables.,"1. The get method only takes integers as parameters Thus it would not be possible to use the iterator object on other data types thereby introducing inflexibility. 2. The traversal logic is not efficient because it will work perfectly fine for arrays however it will not work for other collections that do not have a numerical index. But for other collections like LinkedList, the collection needs to iterate through all the elements to get i-th element. It will introduce same iteration in each of Collection class. This will violate the DRY principle. 3. Iterator objects can be reused using composition using similar type of collection. Thus if we define an iterator class for a particular type of collection and then allow another class of similar type to use the same by passing the object of  the class over which it should iterate. However using this approach we will have to implement the get method for all such collections / classes",The Subject / Publisher is the executive and the Observer is the other person trying to call the executive.,Leave a message asking the executive to call you back when she is free. The user who is the observer registers to the subject by leaving a message and asking the executive to call the user back whenever the executive becomes available. Thus whenever the executive becomes free the executive will call back all the users who had left her a message.,The ActionListner uses the push model.,"Push Model: This model would be well suited where the subscribers register themselves to the subject and wait for subject to provide them only  updated information. This can happen in case when the call to observers cause a lot of amount like sending over the network. In such case, subject only sends the information if the information is updated. Pull Model: This model is useful when the observers continuously monitor for updated information. A good example can be threads in Operating System. Threads wait for availability of lock on a particular resource and keeps checking it in a loop. Here, resource is subject which lets thread know its availability and thread is observer which continuously monitors if the resource is available for use or not."
,,,83,2,2,2,2,1,2,2,2,2,0,0,0,2,0,0,2,0,2,4,2,2,2,0,3,0,0,3,4,2,2,7,3,3,3,6,2,4,4,4
,,,,Abstract CLass,Template Method with a Abstract class written with conditions for each country and modifications specified.,Composite,Facade,singleton,Bridge for each OS.,Prototype,Facade.,It does not use a different List of arrays to make changes. The original method itself is making changes to the data. A different Interface is not being used to make modifications to a different list but the same list is being modified. There is no delegation of the functionality to a hidden class.,Observer,"Here, we are not cloning an instance of the  DocumentCreator class using the Java?s Cloneable interface. There are no field-by-field copies made of its instances.Prototypical objects of the main class are not created for implementation in the dependent classes.Here we are having a class methods that run in the back end where the user uses them without knowing their actual functionality.",Builder,As adapter is defined a different Interface is not being used to make modifications to a different list but the same list is being modified. There is no delegation of the functionality to a hidden class the original method itself is making changes to the core data.,Observer,An abstract class that specifies which objects are to be made.  It doesnt keep a check on whether the objejcts are already mmade. Observer uses a Action Listener which keeps check of the objects. Abstract class only deals with the running of the object and not monitoring them for further  functions.Factories are to provide an interface for creating families of objects in a particular hierarchy without having to specify their type in advance there is no check for the state of the object.,It is readable and easily understandable.Variable nammes are aptly given neither too short or to long.The names are redundant and reusable.The methods take care of only one functionality each.There is functionality of the time method.,"Invariants express the global properties of instances of a class, properties that must be preserved by all routines. Here, the invariant is that the clock is a 24 hr clock.Another invariant is that the number of minutes is only 60. These values are preserved through out the class.",length.A() == length.B(),"Array B has old values lost which might cause a wrong functionality.Here, The array Bis not intialized to any pre values.Array A and Array B are both passed to the method but there is no return type that means array B value is not returned to the main function.",while(i!=Finalvalue){if(A[i] = B[i]){ successfull }else {unsuccessfull}}or still length.A()== length.B(),Length.A() >0 Can be a precondition to make the method work.Here it only checks if the array has atleast one valu to copy and successfuly run the method.,ShoppingCart should have the responsibility of checking for item repetition.reasons1. Shopping cart has the array thhat stores all the list of shopping ID's2. Its easy to compare a section of the Array that has the ID values.3. Singleton Pattern is observed here where all the items in the mall are predefined once and no changes are made to that data.4. Here adapter pattern is also fetched where a list of its own is created from the main list and changes and modifications are done to that list.5. the shoping cart is the adapter which creates an array of its own and makes changes to it.6. Hence Shopping cart has  to be the class to do the comparission operation.,The objects o2 and o1 donot represnt the same memory locations in the first case.  Each object has a location of its own and when the method is called the same class uses different objects o2 and o1 to call the mmethod. Here clonning creates same objects which represents the same memory locations. The clonning operation results in null pointer exception as o1 and o2 are clones of the same memory location.,Advantage :Here the implementation is simple. No need for complex methods to maintain data.Disadvantages: we have to make several subclasses and call the objects. It will consume more methods and code to perform this functionality..,"Advantage :Again, here the implementation is simple. No need for complex methods to maintain data. The Location can have objects from the person class to keep track of the   persons place of birth.DISADVANTAGESIt has the similar problem as above. But here there is an added issue that each location can have more than one person born at that place and some places can go almost empty i.e. nobody was born there .This will lead to unnecessary object creation. Hence wasting the memory space. Record maintainence is also an added problem.",Advantages :This is the most efficient form of maintianning record of the personsplace of birth. Heare a single functionality (mmethod) has to be written to keep the record of the place and person. This form encourages easy mapping of the person and place at run time. Memory can be saved extensively as only one functionality is used. The person can call the object to map his place of birth. This also helps in keeping a less complex record.Disadvantages:Here only one table consists of all the information. The person and the place classes are unaware of this mapping. So they are isolated from data.,,public long getAmount(Currency currency) { return left.getAmount(currency) +     right.getAmount(currency); }Here some currencies donot use long values at all like japanese currency and some use less datatype values like double and float. Here unnneccessary use of floating points can be avoided with conditional statements. Advantages are that unnecessary data is avoided and memeory can be saved. Disadvantages are that functionality has to be wrritten for each currency.,We need getamount to calculate a common value of the money for different currenncyforms. Else we would have to do it for every currency form seperately in their respective methods.,doubles are used because the values get overridden if objects are used hence causing loss of value. To avoid this we use doubles. Now in addition the point values are not as many as in the multiplicationa and division.,"We should have the currency object as a string.This will make it immutable and easily modifiable.Mutable objects are terrible in concurrent situations. Whenever you access a mutable object from separate threads, you have to deal with locking. This reduces throughput and makes your code dramatically more difficult to maintain.Floating point number : Just one object of floating type should be used to save the money value i.e. '3.14' and another string type should be used to maintain the currency type by this way we can maintain a clear distinction between value and type.Just one data type or one variable to represent money. When making changes to large code, the programmer has to deal with only one variable.Make the variables private and decalare the method FINAL.Some key words can be stored in the hashmap and values can be comparred with the currency field.Here, based on certain key words found in the hash table the currency can be identified if a symbol is not found in the beginning then  the currency is represented at the end. Making typecasting and such methods to extract the value of amount and divide it form currency representation we get to perform operations.",It saves memory location and unnecessary initialization of values to variables. It is dynamic allocation of values and hence usefull variables can be used at the right time.,some values may be null when required. The operations haveto wait untill the value is initiallised to these variables. Lazy intialization leads to wrong values being intialized to some variables attimes leading to wrong operation,"If a variable is available publiicly then any method can put its values or make modifications, this will result in storing junk values in the variable as it is dynamically open for writing.",here the itterator method is absent then the get wil only fetch the value and perform operations in their class itself. Here each class has to have such methods. .Leading to increase in code.Itterator method keeps only one code block that performs the function for many datavalues pasd to it.,obs: callersub: executive,leave a meessage.Keep calling back and check,action listener uses the pull model to take information and then performs action only when required. i.e redirects to the button funtion when button is pressed,in array programs push or pull model are used. For eg if a string array is being used then these models are helpfull. Also in momento pattern the maintianenece of all the states the push and pull models are applicable.
,,,63,0,1,2,0,1,2,1,0,2,0,2,0,2,0,1,1,2,2,3,2,2,0,4,2,1,3,0,3,2,1,3,3,3,2,6,2,0,1,1
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,strategy pattern,template patternfactory method,decorator pattern,adapter,singleton,abstract factory,builder,delegationseparate the construction of a complex object from its representation so that the can be handled by other classes or objects,"Adapter just build a new interface to make different interfaces compatible, which not focused on separate complex tasks to other method or objects","Factory methodFactory method define an interface for creating an object, but let the subclasses decide how to do it. Like it's all to build the letter and resume, but different subclass has it's own way to do it","Prototype first need a prototype object. In this case there seems not to be such a prototype, no one will make their own letter and resume based on an other existed objects","chain of responsibility. it needs a series of processing objects and each object have certain method to handle part of the job, and know how to pass the rest to other class to finish","while adapter focus mainly on translating one interface to another interface to make them compatible, it will create new interface, but some of the objects maybe not do any of the job, they just pass the job via a compatible interface to others","State patternwhile dealing with different input under various situations, even same input will lead to different output under different state","Abstract Factory is a set of factory method, it's more like a director to tell other factory method do something other  than a actual creator. It will delegate the build task to a factory method to create a class, but it will not distinguish different state, you give the same input even under different conditions, the output will be probably the same","No, violate the DRY principle. By representing  time by two integers: hour & minutes, it introduce following problems: 	1, you have to keep track of two separate variables to work on a single concept2, arithmetic with time need to adjust to keep minutes within a range3, compare needs to compare two values4, code duplication","public class Time {    int /*@spec_public@*/ hour;    int /*@spec_public@*/ minutes;    /*@invariant 0<=hour && hour <=24; @*/ //class invariant    /*@invariant 0<=minutes && minutes < 60; @*/ //class invariantpublic Time() {  	}   	public int getHour() { return hour; }    /*@    @requires 0<=h && h <=24;    @ensures day == h;    @*/  	public void setHour(int hour) { this.hour = hour; }   	public int getMinutes() { return minutes; }    /*@    @requires 0<=m && m < 60;    @ensures minutes == m;    @*/  	public void setMinutes(int minutes) { this.minutes = minutes; }","1, array A (@param A)must exist2, the elements in array A (@param A) and array B (@param B) must be integer3, array B (@param B)have the same length as array A (@ param A)","the precondition did not specify the type of the array, but in the code, only the int array situation are considered. If the array type is not integer, the program maybe problematic","1, array B will have all elements in array A, and in the same order in array A. 2, The old values in array B are lost","Assume that array A and array B still the same type, integer. Then we need to consider the different length situation, set length A=LA, length B=LB. If LA>LB, then LA will need to be cut to the length of LB, the elements of the first LB will be copied to array B, and the rest will be dropped.if LA=LB, the same as the method above, no change neededif LA<LB, all elements in LA will be copied to LB, and the rest elements in LB will remain or set to null according to the requirementIf array A and array B are not the same type. the type convert will be needed","ShoppingCart class will be responsible to judge whether two Items are the same. ShoppingCart class should keep track of items added or modified in the cart. It don't need to know any other thing of the item itself, just keep track of the item ID and quantity of each item.Item class should only keep the information about the item itself, item should do this one thing and do it well.","The Prototype Pattern allows you to make new instances by copying existing instances. o1 should be initialize to be cloned, you must have a existed object to use prototype, we don't know whether o1 here has been initialized or not.","Advantages: The location of birthplace is instance variable of Person, then we can get it easily and don't need to invoke methods in other classes.Disadvantages: violates the DRY principle, code duplication in Location class. Besides, the location information should be kept in the Location object but not in the Person object","Advantages: The person object and the location object are connected through a collection of references, we can call person information via invoking the reference methodDisadvantages: Location object should do one thing and do it well, it should only keep the location information. It is not supposed to know about the internal information about other class. Keep collections will result other methods to get person information, which is also not Location objects' job.",Advantages: Now DRY principle has been followed and every objects just focused on its own job. Person objects and Location objects can delegate responsibilities of reference to the third object.Disadvantages: more classes and objects. Add complexity,"there are several ways to make a class's instances immutable1,Make all  instance variables	 private.2,Declare the class, or all its methods final		 .3,Don?t provide any settor/mutator	 methods.","Yes, representing cents with long integer have some problems: If you divide $1 by 3, you will get 33 cents. When you multiply the result by 3, you get 99 cents. In that way you lose 1 cents!To solve this problem, we can represents cents with floating, the advantage is that you can avoid the lost 1 cent problem above. But there are also disadvantages: 1, you will meet fractional cents problems like  $0.3333...   2, you will also need to face the round off errors due to the computer have its own way of representing floating","getAmount is mainly used for calculation with other money object, and getters are well known for data encapsulation. Sure we don't necessarily need a getAmount, but it's not O-O style","because when add and subtract, the operation involves 2 objects which can be different, we need to consider but multiply and divide is to operate on the object itself, it's only one object","the only thing we need to change is the toString() method in currency class. We can certainly use inherit from the currency class and use overriden to add new display methods to the  toString() method. But in order to follow the""use interface, not inherit"" principle, we use interface:public interface Money extends Currency{public String toString();}public class NewMoney implements Money{public String toString() {               display in required format;         }}We can also add parameters to method toString() to specify other different display format like:public String toString( param) {     switch(param)         case(1){ display in required format1;}         case(2){ display in required format2;}             ......                   }Of course these case statements is not very o-o, we can use a third class to keep the display format method, and leave a hook method in toString method. If there is no params, we use default display format. The params can be used to decide which display format to useAlso the PLA principle should be followed. We should also include the display format in the previous toString method","When initialize,  the getInstance() method is called, it checks to see if the object has already been instantiated.	If it has, the method simply returns (a reference to) the object.	If it hasn?t, the method instantiates it and returns a reference to the object.	In this way, you can change the get instance() method without changing other part of the code","1, to get access to the object variables and check procedure take extra time.2, The actual initialization can be in anywhere of code and happens at an unspecified time, which lead to certain confusion","a publicly available instance variables can be called of used by other classes and objects during run time. These calls and invokes are not happen in the same places and the same time every time, that will lead to unspecified initialization both in time and location every time. Which will result in confusion","The collections may be implemented in many ways, with different ways of moving from one item to the next. The problem is the i++, for different type of objects, i++ is different. Like integers in an array may have a distance of  2 bytes in memory, while long int maybe have a distance of 4 bytes. That's why we need to build iterator to encapsulate the internal details of data structure. Besides, we may also need multiple iterators other than one single iterators (think about some sorting algorithm); We sometimes hope to keep the iterators inside the class scope so external method will not be able to invoke. Therefore we need to build a iterator method",The Observer is the one who want to reach the executiveThe Publisher is the executive,"Leave a message asking the executive to call you back when she is free. in Observer pattern, when publisher changes state, all its observers are notified automatically. When the executive's state change to available, people who leave message will be contactedObservers delegate the responsibility for monitoring for an event to a central object, the Subject. The one who want to reach executive delegate the responsibility for monitoring whether the executive is available to the Secretary or Answering machine When the event occurs, the Subject tells the list of Observers that it has occurred. When executive is available, people who leave message will be contacted","Pull modelthe ActionListener decouple the CanvasEditor and the JButton. The buttons don?t care who?s subscribing to them, it's ActionListener's responsibility to pull the useful information once button action performed. Otherwise the button should keep the observer information, it violates O-O principlepublic interface ActionListener 		extends EventListener {	public void actionPerformed(ActionEvent e);	}",push/pull model differ in different sorts of coupling associated with each approach. Push requires that the Subject know the information that Observers may need.A superset of information that includes everything observer might need should be included.Pull need the observer to ask explicitly for the Subject state data that it needs. and pull needs to deal with the synchronization.
,,,87,2,1,0,2,1,0,0,0,2,1,2,0,2,0,1,3,3,2,4,2,2,0,3,3,3,3,3,3,2,2,7,3,3,2,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy Pattern,Decorator Pattern,Composition Pattern,Adapter Pattern,Singleton Pattern,Bridge Pattern,Prototype Pattern,"This pattern is Abstract Factory pattern because the sort method does not know about the array, nor does it care what kind of objects are stored in the array.","Adapter pattern is used when one interface has to be modified in order that it is compatible with the client. In the above example, the existing interface is just being abstracted out so that it can work on any kind of an array.",This pattern is the Decorator Pattern.,"In Prototype pattern, an object is created by cloning another object and in the given example, none of the existing objects are being cloned.",Chain of Responsibility.,"Adapter pattern is used when one interface has to be modified in order that it is compatible with the client. In the above example, the request from the client is passed along a chain until the required object handles it.",Mediator Pattern.,"The Abstract Factory pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes. In the above example, it is known which classes the object belongs to.","The given class is not well formed. Because the class invariants are not listed, to check the state of the objects of the class between public method calls. Also the hour and minutes can be calculated as and when an object is instantiated using the built-in JAVA time methods.","We can have a validator for the time like this:public boolean validate(final String time){ 		  matcher = pattern.matcher(time);		  return matcher.matches(); 	  }If (time.validate){//Time is valid}",The preconditions are:- The values of Array A must be copied into Array B in the same order.- The arguments passed are Integers arrays A and B- Array A is the source array and Array B is destination array,The length of the integer arrays will be initialised,The post conditions are:- The existing values in B must be over written with the values in A.- The length of Array B must be same as that of Array A,"- If the preconditions are removed, then the function copyArray() must be modified to accept arrays of any type including int.- Either of the arrays A or B could be the source/destination ; so the function copyArray() must be changed to accommodate this change too.",The class Item should have the responsibility of deciding whether two items are the same; this is because this is in conformance with the principle that the an object should manipulate it's own methods and it should manipulate it's own variables. This follows the Law of DemeterThe method get_productID in the Items class can be used to check whether 2 items have the same product ID.,"- If a shallow copy of the object o1 is made, the new object is a new copy but will point to the data of the original object. So a change in o1 by either original or cloned object will be reflected in other also. So, after o1 is set to null, o2.anymethod() will not perform any function.- Although o2 is cloned form o1, we do not know if the class MyClass implements the Cloneable interface. If (o1)super.clone would have been used, then it might have been right because the class Object implements the Cloneable interface. But in this case, CloneNotSupportedException might be thrown because it is not explicitly mentioned anywhere the MyClass implements the Cloneable interface.","Disadvantage:One person cannot be born in many locations but many persons can be born in one location. Therefore if we have a Person class with an instance variable of type location, we might need as many objects of the Person class as there are number of people. This would take up a lot of memory.Advantage:On the other hand, there is one - to - one mapping, which makes the design simple.","Advantage:This would take up much less memory since one Location object can hold information about all the persons born in that location. Disadvantage:If you are looking for a person, then one has to go through the entire collection until that person is found.",Advantage:This design has a Person object and many person objects can refer to the same location Object in the table.Disadvantage:It is relatively difficult to find all the persons born in a particular location using this design.,The USMoney class can be made a Singleton class so that only one object is ever created that represents 1$.,"The alternatives are:1) The amount can be returned as a Floating Point NumberAdvantages:- It is easier to make calculations using floating pointDisadvantages- Can create issues while rounding off2) We could use two integers to represent the amount, one for dollars and one for centsAdvantages:- It is easy to make calculations and it is also easy to understandDisadvantages:- Consumes more space to save the data","Yes, we need a getAmount() method. It would be used to get the amount saved in the USMoney class.","Since USMoney objects are immutable, the arithmetic operations do notchange the current object, and instead they return a new USMoney object with thenew amount of dollars and cents.But, the times and dividedBy methods use floating point calculations and, as a result, have round-off issues to deal with. That is why multiply and divide are done by plain doubles.","The Template Method pattern can be used to handle such currency specific differences. - In this example, let us suppose that the amount displayed i.e. 3.14 in this case is always constant and there can be different ways to represent this amount. - The part of the code to represent this amount can be moved to a base class. - The methods used for representations of this amount, like adding a preceding dollar or adding a succeeding symbol can be moved to subclasses.","-If you never use the value, you don't pay for it.- Initialization costs can be more spread out by not initializing everything at once.- In some cases, startup appears to be faster.- Ability to delay until needed information is available.",#NAME?,"If lazily initialized variables are made publicly, they can end up being manipulated by other classes. They could be manipulated even before they are initialized.",#NAME?,Subject: The executive in the companyObserver: The person trying to reach the executive,"The third choice corresponds most closely to the ""Push Model"" of the Observer pattern. In this scenario- the person trying to reach the executive(Observer) leaves a message for the executive(Subject). This is analogous to an Observer registering with the Subject.- The executive calls back when she is free. This is analogous to the Subject sending a message to a registered observer whenever there is a change.",The ActionListener interface uses the push model because the JButton class(Subject) notifies all the callers(Observers) when the button is clicked. The Jbutton class does not wait for the listeners to execute the actionPerformed method and find out whether the button is clicked.,"Where Pull model would be better suited:  Sometimes when there are frequent updates, the push model would cause the Observer to be refreshed too many times. Under such circumstances, it is more appropriate to use the Pull model.Where Push Model would be better suited: Sometimes, an Observer is required to observe more than one subjects. In this case, it would be better if the Observers are notified of the change, rather than Observers themselves trying to find out when the subject has been changed."
,,,93,2,2,2,2,1,2,1,0,2,0,2,0,1,0,2,3,1,2,3,2,2,2,4,3,3,3,3,4,2,3,7,3,3,2,6,2,4,3,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy patternWe maintain a list of alogorithms for the calculation and based on the shapes call the required algorithm.,"Builder pattern.All the tickets need headers and footers , however the type of header and footer depend on the country. ( Same construction process for different representations).",Composite pattern,Adapter.provides a  way to incorporate a thrid party rountine into your function.,FlyweightSingle representation .,Abstract Factory.We can have families of thread implementations and let these subclasses choose at runtime based on the determined OS.,Prototype. We can just clone the steps in which we fixed the brakes on the previous one,Iterator.It allows the programmer to iterate through the container and perform the action without worrying about the underlying structure.,"This is not an adapter pattern , since adapter deals with conversion of format from one type of another. here since the BubbleSorter does not care about the kind of objects returned in the array, it is not required to adapt the sort method according to the array elements.",Abstract Factory.,"Prototype makes a clone of the object required which is an exact replica. Since we want different implementations here , cloning would not help.",This is a Template method pattern. The client needs to perform the described steps in that order specified in the question to gain access to the Database elements.,"Adapter is more like implementing the interface, while using Template Method is about implementing the parts of algorithm differently. So Adapter is used when we need all modules/components to response to the same API. At the same time, we use Template Method when we have some general process, which differs in minor details, which we implement in the derived classes ( e.g.:diff kinds of database).",Command design pattern.,"Abstract Factory is a creational pattern whereas Command is a behavioral design pattern.Keyboard shortcuts are commands sent by the client which is encapsulated and called by the invoker. Since there are no new dialog boxes created , this is not an Abstract factory pattern.",As the class name suggests the class sets or outputs the current time (either hour or minutes). The variable names are all  well-described. Hence it is well-formed. Follows single responsibility too,The invariant must hold to be true after the constructor is finished and at the entry and exit of all public member functions./*@invariant 0<=hour && hour <24; @*/ //class invariant    /*@invariant 0<=minutes && minutes < 60; @*/ //class invariantFor the setHour public method we can have the following class invariants./*@    @requires 0<=hour && hour <24;    @*/    public void setHour(int hour) {        this.hour = hour;    },A precondition is a statement which is assumed true when the method gets called.The preconditions for this are  that the integer array to be copied (A) and the integer array into which the values must be copied(B) must be available.,The post conditions do not ensure that the elements are copied properly. It only checks that the length of the arrays are same and the old value of B are not present. This will be true always even if wrong elements are copied onto array B.,The post conditions are:The old values in B are lost. The array B must have the same length as array A.,"By making pre-condtion set to FALSE, we can ensure that the method will always work.Alternatively we can remove the pre-condition and make the post-condition set to TRUE, which will ensure that the method will always pass.","The Shopping cart class maintains the array list and has information to create , add , delete and Update item. Since the shopping cart has all the information regarding the items, adhering to the EXPERT pattern, it should be the shopping cart which could check for the product ID of the item in the AddItem() method. If the item is already present in the ArrayList, update the item count int the array list.This way ,we can also adhere to the Single Responsibilty principle in which the Shoppingcart class deals with the responsibility of adding items to the cart. Creating a seperate class for maintaing this array and checking for the item would not only make it expensive but would also make it vulnerable to out of sync errors.","clone duplicates the object o1 and assigns it to o2.  Calling o2 = o1.null will duplicate o1 and give it to o2. However when o1 is set to null, only the original object is set to null and not the clone. Hence, we now have in memory 2 o1 objects out of which only one of them is null.","Advantages:a) Easy to maintain since it is only a instance variable.Disadvantage:a) It could lead to wrong results. For e.g.: When the location of 2 person objects are returned as Raleigh doesn't mean both of them are from Raleigh,NC. One could be in North Carolina and the other from IIlinios. Storing countries names would not help too since many people are born in same country.","Advantage:a) Each person can be born in only one place, so there is a one-one mapping between the user and the location. Given a location we can easily find all the people born in that location.Disadvantage:a) In order, to find a birth location for a particular user, we need to iterate through the entire collection to find a particular user. This is not efficient.",Advantage:a) Very good design since it follows seperation of responsibility. Disadvantage:Requires to maintain a seperate object which contains the mapping. This is inefficient and expensive.,"For making the USMoney class that has only one object always, we can make the create a seperate class called USMoneyDollarOne  which is associated with a ""has-a"" relationship with USMoney class. We then make USMoneyDollarOne a Singleton class. So , we can now use delegation whenever a $1 object is required but ensure that only one object is ever created.","getAmount() method returning float could have issues with roundoff.E.g.: 100 cents / 3 = 33 cents * 3 = 99cents and not 100This would not be a problem normally for minor computations but still can be erronous when used for large calculationsAlternative getAmount() can return 2 integers , one representing dollars and the other cents.This also has round off errors. Also we need to keep track of two variables now.getAmount() can also return a single floating point value.This could lead to issues in case of fractional cents and how many values after the decimal do we need to consider. ( Since float can hold upto 15 values after the decimal)",The getAmount method is used to return the money. Yes it is required to have a getAmount method. This provides encapsulation.,To reduce complexity and enchancing performance.Dividing a money object by a money object is time consuming.It also requries overriding the inherited method,Currency class has a getcurrencyCode() method which returns the code of the currency.We can acheive the required functionality by making the Money class and abstract class. We can make the to_string() method abstract and implement these method in the subclasses based on the way they want to display the money.,Users don't have to pay the initialization time for variables they will not use. i.e. Performance optimization.Particularly advantageous when initialization of objects is costly and performance hindering.,"The main disadvantage of lazy initialization is the time penalty associated with each access of the variable i.e. It is always required to check first if the object is nil.(not initialized yet)Not thread safe.The initialization code is spread around the class and occurs at an unspecified time. On some occasions, this can lead to confusion.",By making it private we can ensure that other classes cannot initialize it again.,The iterator patterns allows multiple traversals concurrently which cannot be provided by using get method. get returns only a specific element in the list.Using iterator also gets rid of the for loop syntax making the code more reasonable.,Subject - Executive - He will inform the observer when he is free. Observer - Person who is waiting to reach the executive. The person observers (waits) for any notification from the executive.The person first registers himself by leaving a message to the observer.,"Leave a message asking the executive to call you back when she is free can be closely related to the observer pattern. The first option does not hold good since this means that the person should always be on the phone line waiting for a response.the second option is not good too since, it requires to continuously poll the observer.Leaving a message by the person who wants to reach the executive is analogous to registering with the subject by an observer. Whenever the executive(subject) is available he can notify the person back. (This is analogous to subject sending a notify message to the observers in case of any event).The person can then make appropriate adjustments to his schedule based on the notification from the subject. i.e. (The observer can update his calender.)",Pull model.The ActionListener interface is implemented by the listener and wll register itself with the JButton by the addActionListener method. So observer sends a message to the Subject (JButton),"Push and pull describe the relation between the View and the Controller. According to the push model, user actions should be interpreted by the Controller (subject) which will generate the data and push it on to the View(listener), hence the ?push?. On the other hand, the pull model assumes that the user requires some kind of output (like a list items from the database). The View will access the Controller in order to get the data it needs in order to display the user the kind of output he requested. This is much like the View is ?pulling? data from the Controller.Push model is suited for programs such as web applications where the user sends a command to the web server. It is not required for the update to happen on every observer. Pull model can be used when the webserver provides response the request."
,,,87.5,2,1,2,2,2,0,1,0,2,2,2,0,1,0,2,2,4,2,3,2,1,2,4,3,3,3,2,3,2,1,7,3,3,1.5,6,2,4,1,4
,,,,Strategy pattern,Decorator Pattern,Composite pattern,Adapter Pattern,Singleton Pattern,Bridge Pattern,Prototype Pattern,Template Pattern,BubbleSorter is not a new interface for existing sorting technique. It implements the sorting algorithm itself.,Abstract Factory Pattern,"There are several concrete versions of the DocumentCreator to create different objects such as fancyletter or modernresume. In prototype pattern, every new object is instantiated using a copy of the object with certain properties and then the object's properties are modified later.",Facade Pattern,"The GoF define adapter pattern as Adapter Pattern ""Convert the interface of a class into another interface clients expect. Adpater lets the classes work together that couldn't otherwise because of incompatible interfaces"". However, in this case, we are using different subsystems and creating a higher level interface. We are not converting one interface to another.",Singleton (There is only one instantiation of the dialog boxes and we need to make sure that we check if they are already instantiated before we display them),Abstract factory should have allowed us to create many copies of the concrete products (dialog boxes) instead of checking to make sure only one copy is open.,"No. The hour value cannot be greater than 24 (or less than 0) and the minute value cannot be greater than 60 (or less than 0). However, the class fails to check these conditions thus there is a possibility that users of this class can set the values of minutes and hours to be out of the actual range",0<= hour <= 24  (or 0<=minutes<=60),The array B must have the same length as array A.A and B should be valid integer arrays.,"Yes, in the documentation portion, the phrase ""in the same order"" is ambiguous. What order is it talking about? Furthermore, just by looking at the name of the method it is difficult to know which array is being copied into which another array.","Array B should contain the values in Array A and also contain the values ""in the same order"".",The size of array A should be smaller than the size of array B.,"Shopping Cart should have the responsibility to determine whether there are two items of same type. We can use the expert pattern here. Since shopping cart is the 'owner' of all the items in it, it should be the one performing operations such as comparison, counting etc on the items in the cart. Shopping cart has the information necessary to fulfill the responsibility. The item class does not have the big picture of what is in the shopping cart thus should not be the one to take the responsibility of deciding if two items are the same.","Unless the cloning method is implemented in the type of object you are cloning, it uses the clone method of the object class.Thus depending on whether or not anymethod() is defined in Object class we will get desired/undesired output.","For every instantiation of a person we need to supply the location information. If we need to find where a person is born, we need to access him/ask it from the person class exclusively. Difficult to access for other person objects. If we need to find the people born in a place, need to query every person.Advantage: Every person is responsible to keep track of his birth place so no other class/object necessary to store this info.",Disadvantage: Location needs to keep track of all the person objects born there. It can easily get out of proportion. Too much recordkeeping for Location Object. Advantage: Acts as the server for the information regarding the birthplace of different people. Easier to find info about different person. No need to query everyone separately.,"Disadvantage: Extra space required, Need to create a new tableAdvantage: The person does not need to worry about the details on location object and Location does not need to worry about person object.",We can use a singleton pattern to create USMoney and introduce variables that can be instantiated only once. This way $1 would be a variable that would always represent $1 and can be reused everywhere exactly $1 is needed.,"Yes, there could be variations of the getAmount method such as returning the money in floating point format or by using two integers. With two integers, you will be using two separate variables to represent a single concept. Floating point can represent the money upto several decimal points but increase the complexity of design.",getAmount will be used specially when dealing with mixed money and converting money in to different currencies.,Because Money cannot be multiplied by money. It does not make intuitive sense to divide one money by another. What does it mean to divide one money by another or multiply one money by another? Only addition and subtraction are operation that are defined and needed to be done between two money instances.,"We can use an Adapter pattern here which uses the Currency class but also defines the interface that will allow the money to be displayed in several formats. We can create a new interface myMoneyInterface which uses delegation to utilize the functionality of Currency class. However, it will also provide the interface (option) to display money in different methods not supported by the existing currency class. All this new Interface needs to do is to get the currency symbol or the three letter code using the currency class and display it in the appropriate format.","- If you never use the value, you don't pay for it.- Initialization costs can be more spread out by not initializing everything at once.- Ability to delay until needed information is available.",#NAME?,Specially because we want to make sure that no other object attempts to use it before it is initialized.,"There are two disadvantage of this approach.-  After all our code is written, if we decide to use a different collection, we need to modify every iteration over the collection to use a new loop construct.- Furthermore, a client who only wants to traverse the collection needs to worry about all the details of the implementation of the collection.",Executive = subject/publisheryou = observer,"Leave a message asking the executive to call you back when she is free.In this scenario, the publisher(Executive) notifies the observer (by calling you) once the state (when she becomes available/free) of the observer is changed which is the process that takes place in a observer pattern.",This is the push model of communication. The subject (JButton) passes the information to all its observers through the actionPerformed methods that exist in the observers. Whether an observer acts upon the information depends on how it wants to utilize the information about the button being clicked.,"Push model is better suited when all observers are interested in common state changes. It cannot be used with large amount of data because the observers may simply not be interested in all the data that is being pushed. Furthermore the Subject must know something about the Observer to which it is pushing the data. Therefore, the Observers have to comply with a standard interface required by the Subject and the Subjects reusability is limited to these Observers.Pull model is more flexible and the Observers can pull only the required data. But, more than one method call is required to implement the pull model - for notification from the Subject to all its Observers and (interested Observers) for pulling the data. In very dynamic environments, the state of the Subject can change between these two calls thus causing subject and observers to be out of sync. Above all, the Observers call specific methods to pull the required data and it is up to them to figure out what is changed without getting much help from the Subject."
,,,104,2,2,2,2,1,2,1,2,2,2,2,2,2,2,2,3,4,2,4,2,1,2,2,3,3,3,3,4,2,2,7,3,3,3,6,2,4,4,4
,,,,"Template method.We can define an abstract base class containing abstract area() function and over-ride that function  in derived class trigonometric functions, polynomial functions, and exponential functions.",Builder pattern,composite pattern,adapter pattern,flyweight pattern,bridge pattern,chain of responsibility,facade pattern,because this does not deal with incompatible interfaces. there is an abstract base class and derived classes are interchangeable. this does not require implementation of a new interface to bring in compatibility.,abstract factory pattern,"because a different implementation of createLetter() and createResume() , hence there is no common prototype that can be passed around.",chain of responsibility,"Adapter lets classes work together that couldn't otherwise because of incompatible interfaces, here database model and element does not require a common compatible interface to work....they just need to pass on the responsibility to finish task",builder,because we dont need to create families of related or dependent objects,"Yes, the class is well formed. A well-formed class has a consistent interface . By ""consistent"", i mean that the methods that do similar things should be laid out similarly.  Class has a method that allow the user to set the set time in hour and another that allows the user to set thetime in minutes.  In that case, the two methods should have similar names and similar arguments in the same order.  That is, the method signatures should be something like setHour(int hour) and setMinutes(int minutes).2)a well-designed class will be open through extension by facilitating subclassing. this is also satisfied in time class",A class invariant is a statement about the state of objects of the class between public method calls.  The statement of equality of the value of hour and return value of gethour() in an object of the Time class is an example of a class invariant.  The statement of equality of the value of minutesand return value of getminutes() in an object of the Time class is an example of a class invariant.,The array B must have the same length as array A.,yes there is an ambiguity. following questions are not clear to client:-1)Whose responsibility is it to ensure that the preconditions aresatisfied before calling the method?2)Suppose the preconditions are not satisfied. What can happen whenthe method is called?Hence it is usually better if clients of the routine know what couldhappen in all cases,1)Copies the values of array A into array B in the same order.2)The old values in B are lost,remove precondition and add following to post condition:-3) throws exception/error  if  array B does not have the same length as array A.,A new Iterator class should be used for traversing the items in Arraylist and finding out if the item we are trying to add already exist or not. We can implement Iterator design pattern here. Iterator pattern provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation. Shopping cart class can have a create iterator method that will create a new iterator for the arraylist of items. This iterator  class can have functions like isexist() and next() to check if item with given product id already exist in arraylist or not.,"prototype pattern specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype. It either create a deep copy or shallow copy of object instance that is cloned. clone() method of Object creates a new instance of the same class as the object and copies all the fields to the new instance but it does not give the new instance a new unique ID. So object o2 id linked to o1.",This behavior is called delegation advantage :-  Delegation has the advantage that it can take place at run-time and affect only a subset of entities of some type and can even be removed at run-time. disadvantage:- creation of a new object in order to access just one functionality/method of that object,"Advantage :- iterator can be used to access each person object and extract person information. main advantage is all person information is available at one place and provide easy accessDisadavtange:- highly discouraged programming method. it violates the fundamental encapsulation principle :- One class should be responsible for  knowing and maintaining a set of data, even if that data is used by many other classes.",This is the most effective way of handling with person and location objects.we can have getter and setter methods for accessing location and person information from Location and Person class. There is one -to-one mapping to ensure no duplication is done.disadvantage :- overhead of maintaining the table and access overhead for getters,"in order to make sure, that only one object of USmoney is ever created, we need to use singleton pattern on US money class. Thsi can be done by :-1) making USmoney class constructor private.2) define a private static instance of USmoney class inside class as class variable :- private static instance_usmoney =0;3)perform lazy initialization   public getinstance(){   if  ( instance_usmoney==null){     instance_usmoney=new USMoney()   }  return  instance_usmoney;}",alternative :- 1) mixed money or combination of currencyadv:-- money can be represented in diffrent was as desired my user.disadv:--will require addl conversion and calculation to bring to lowest abstraction level;,"yes we do need getAmount method. This method  will be required while doing money conversion from one currency to another currency. Since getAmount return lowest level /abstraction in any currency, its easy to convert one currency to another currency.",the factor with which we divide are double objects or just a factor for multiplication and division. just in order to multiply or divide...we cannot create a USmoney object. This violates Liskov substitution principle. we dont want to divide or multiply a USMoney object with another object having property (amount and currency ). it just has to be a factor using which multiplication / division can be done.,"1)cases such as using a comma instead of a period or putting the symbol at the end where we are adding addl char or chars after existing 2 forms :-(3.14 USD , $3.14)  - this can be solved by decorator pattern. Decorator pattern attach additional responsibilities to an object dynamically. It provide a flexible alternative to subclassing for extending functionality. So we can have additonal wrapper class derived from Money class that will override getDisplay() method to add addl char outside (3.14 USD. / 3.14 $).","1) users don't have to pay the initialization time for features they will not use. Suppose you were to initialize every component of your application up front. This could create a potentially long start time - users would have to wait dozens of seconds or minutes before your application is ready to use. They're waiting on and paying for initialization of features they may never use or not use right away.2) By using Lazy to declare theobject for lazy initialization, you can avoid wasting system resources when the object is not used.3) lazt intialization is effective when, you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.4) improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.","1)The main disadvantage of lazy initialization is the time penalty associated with each access of the variable caused by the isnull() test in getinstance() function;2)Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.","publicly available instance variables cannot be initialized lazily because instance variables are used by multiple instance methods in a class. Instance methods including constructor, depends of value of instance variable, which needs to be made available as soon as an object of class comes into existence. lazy initialization is effective when there is a good chance the variable will not be used. but we are sure that instance variable will be used always.","Iterator pattern has following advantages :-    * access contents of a collection without exposing its internal structure.    * support multiple simultaneous traversals of a collection.    * provide a uniform interface for traversing different collection. if we use get(i) instead of iterator :-1) internal structure of collection objects will be exposed which violates encapsulation.2) if you wanted to support four data structures (array, binary tree, linked list, and hash table) , it will be difficult to traverse. we will have to use typecasting all the time which is not a good design pattern.3) iterator maintains current state of object hence is allow simultaneous access to collection by multiple objects. get(i) way of traversing will not be able to maintain current state and hence wont support simultaneous access.","Observer - myself -->  i'm trying to reach executive, hence im a subscriber /observer /listener to executive's responseSubject :- executive --> i have have subscribed to executive's update and as a subject, executive will contact be whenever she has to broadcast a message to me.",Leave a message asking the executive to call you back when she is free.,"Push modelAction listener interface has actionperformed methods that is implemented by subject. observer subscribe to subject for information updates by calling addactionlistener method. whenever subject changes its state, it calls notify() method of all observer who subscribed to that subject. update methods of each observer in turn calls a getstate() method of subject in order to update himself about subject's staus change. there is no polling issue here as observer is invoked only when subject has some updates to give. else observer is on sleep.","Push model would be better suited in following conditions:-1) Encapsulate the core (or common or engine) components in a Subject abstraction, and the variable (or optional or user interface) components in an Observer hierarchy.2) The ""View"" part of Model-View-Controller. 3) Observer defines a very decoupled interface that allows for multiple receivers to be configured at run-time.4)used for dynamically registering colleagues and communicating with themPull Model:-1) When resource or update for which observer is waiting is very important that polling is essential. ex: OS resources2) Broadcast information continuously and dyanamically. Broadcasting is essential at every moment."
,,,105,20,1,2,2,2,2,0,0,2,2,2,0,2,0,2,2,1,2,4,2,2,0,4,0,3,3,3,3,2,1,7,3,3,2,6,2,4,4,3
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,"Strategy pattern It defines a family of algorithms like area of trigonometric functions, polynomial functions, exponential functions, etc.,",Template pattern.Template pattern defines probably a generic header and footer and subclasses can override these methods accordingly.,Composite pattern,Adapter pattern,Singleton pattern,Bridge pattern,Memento pattern,Factory pattern. The reason i think is that we have a an abstract bubblesorter class which has an abstract outoforder method which will be implemented by subclasses based on the type of elements.,because there are no two interfaces which are incompatible here. Hence adapter pattern cannot be involved here.,Abstract Factory,"Though both are part of creational pattern prototype does not apply here because in prototype we try to clone an existing object of a class instead of creating a new object which has fresh state. Gven the description, there is no intent on creating a prototype object.",MVC pattern,adapter pattern comes into picture when we have two incompatible interfaces and one requires the functionality of the other. Clearly the description does not mention about anything related to incompatibility.,Singleton pattern(because each key stroke should return the same object),"Abstract factory is not applicable here because, it creates a families of related or dependent objects without specifying their concrete classes. Here each keystroke has been defined a function already.","No. As mentioned in the text book, we need to check if the values passed to setter methods are valid ( fall within the range ) and does not manipulate to whatever required. We should have class invariants to see if the state (time here) does not get modified beyond time range.","The below class invariants can be used in each of setHour and setMinutes method to see if the value is not modified.public class invariants {private void validateHour(int hour){   if(hour >=0 && hour < 24 )     //do nothing   else     throw new IllegalArgumentException(Please specify the hours within the range 0-23)}private void validateMinutes(int minutes){   if(minutes >= 0 && minutes < 60)      // do nothing   else    throw new IllegalArgumentException(""Please specify minutes within the range 0-59"");}}","Preconditions could be,a. The length of the array B is equal to length of A. ( both must be of same size )b. The elements in array B are no longer needed so that they can be replaced after this method.","Yes, there are some ambiguities,a. Its not specified what should happen to array A. Should it be destroyed or deallocated?b. Its not specified if the memory allocation for B has been done before calling copyArray.c. Its not specified if the size of two array will be same and what should happen if they are not.","Postconditions include,a. After the copyArray method has succeeded, the old elements of B are lost. b. The elements in A and B are now equal elements wise and length wise.",a. We should try to allocate the array B inside copyArray depending upon the size of array A and then do copy. b. The type declaration of B should be same as type declaration of that of A.,"The class ShoppingCart is responsible for deciding if two items are same. Law of Demeter principle says that a method M of an object O may only invoke the methods of the following kinds of objects:O itselfM's parametersany objects created/instantiated within MO's direct component objectsa global variable, accessible by O, in the scope of MSo, here the methods of shoppingCart class can be invoked on direct component objects which are list of items.","1. o1 can be null before o2 is being cloned. So a check should be made if o1 is null then a clone should be created only if o1 is not null. 2. We should typecast the o2 object of type MyClass before returning, becasue by default it returns of type object.o2 = (MyClass)o1.clone().Also a deep clone clones the instance variables in the cloning object while a shallow clone shares the instance variables between the clone and the original. Usually, a shallow clone is enough and very simple, but cloning complex prototypes should use deep clones so the clone and the original are independent, a deep clone needing its components to be the clones of the complex object?s components.",Advantage is that the person object can get his location by passing a person object to location  which returns the place of birth. Its pretty straightforward. a one-one mapping of person and location objects. Essentially person class uses Location class.Disadvantage: I think there are no special disadvantages in this approach because this kind of design supports composition which is very much suited here. The only thing is Location objects should not have fields which are related to person object which duplicates the code.,"Advantages : searching through a list of person objects who are born in the same location, is easier. Sometimes we might retrieve the person's location information in shorter amount of time.Disadvantages : Given a person object it has to iterate over all the objects to see if the person objects exist and then return the place of birth which might take longer time to execute. In worst case, we must iterate through all locations to find out the person's birth place.","Advantages : This is very quick to find the location of a person. You have a hashtable which quickly searches ( often in O(1) ) to determine the location. Disadvantages:  Of course if there are multiple same names which hash to same index or key, then in worst case you will have to iterate through entire table to look for a location object which has person's birth place. Often this occurs of bad hashing function.",You can make USMoney has singleton object where the value is initialized the dollars to $1 and cents to zero. You can make dollars an cents as final fields so that they cannot be changed once initialized.,"1. You can return getAmount to return an object of class say X(which has dollars and cents as instance variables  may be of type long). a. advantages - You can represent the money interms of dollars and cents now without requiring to convert the amount which was in cents earlier to fractions.b. disadvantages : arithmetic on these class objects becomes cumbersome ie., requires adjustments while adding/subtracting dollars and cents.2. getAmount method can return a floating type. a. Advantages : Floating point numbers have the advantage that you can represent far larger numbers and you can represent fractional parts of dollars conveniently.b. Disadvantages : - the round-off error caused by fl oating point approximations can raise significant problems.- if you take two almost equal numbers of that magnitude and subtract them to get a number of much smaller magnitude, the number of signifi cant digits of accuracy in the result is reduced.",Strictly speaking its not required if we declare the cents as public field. But if we make cents has a private field ( encapsulating from outside world ) then we need one public method to access this field. In that situation we do require a getAmount method.,"The multiply and dividedBy methods use floating point calculations and, as a result, have round-off issues to deal with unlike the addition and subtraction methods. Some of the values (round off )might be lost during computation if we use USMoney objects.",You can define a new interface which basically as a method toString which converts the currency to third form as mentioned. Then the interface can be implemented by any class wishing to have third form of currency.The Money class can then have a reference to this interface and call toString on that object. This resolves the issue. And also you can have reference to interface only if the third form of currency is needed otherwise you can omit this form Money class. ( something on the lines of strategy pattern ),"Couple of advantages of lazy initialization are, a. Suppose the Singleton object(or others) takes a long time to create and you don?t want a long delay during the start up of your application. b.  Suppose the object uses a lot of memory, and so you don?t want to create it at all unless it is needed.c. There is a good chance the variable will not be used.As you can see, this approach avoids creating the one instance until the first timeinstance is called.","Disadvantages include,For multithreaded applications, this approach proves to have a potentially hazardous side effect. If two threads manage to enter the control block at the same time, two instances of the member variable could be created.  Also the since the getInstance() method is now synchronized, if there are multiple threads accessing the same instance, the performance might take a hit.","the main reason of not making instance variables as public is because, they can be initialized early during initialization by objects of other classes which defeats there purpose. Keeping them private or protected to a class, ensures that they are initialized only when needed.","One thing which can is wrong in this design is,  even though we get the data on type Object, we need to check if its of type collection ( could be list, array, linkedlist, arraylist, etc). This happens when we try to use two or more classes which have data stored in different formats.For example if we have pancakeMenu and DinnerMenu where PancakeMenu has a list of array objects and DinnerMenu has of type arraylist, when we combine these two menu if we use the above get(i) method, then we need to check in if/else condition to see what is object type. Further if we add combine DessertMenu which has linkedlist of objects, then we have to add one conditional statement, This violates the open-closed principle. ( Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.)",Observer :  Person trying to reach the executiveSubject : executive,the 3 option represent the closest choice. Because the person trying to reach the executive leaves a message to executive ( sort of registering himself ) and then executive ( subject ) will call him back when he is free. This is similar to registering and notifying the observer.,"The ActionListener interface use push model of communication. Because the click is an event which is captured by the Jbutton and notified to the observers ( listeners ). In the pull model, each listener would poll to see if the button was clicked continuously which is not happening here.","Pull method may be suited where the applications don't anticipate everything they need. They might not need all the information that is being pushed by the subject. It also allows the subject to add more states and then expose the new state via public method. This helps the observers decide if they require the new state and if not doesn't need any modification in their code. For example, if there is an observer who just wants temperature he can just pull the temperature state from the weathear station instead of getting all data.Push method can be useful if the observers are ready to accept all the information that is being pushed from the subject. For example, traders expect stock market updates to be sent out for every change in the price value. using a pull model can have serious consequences."
,,,100.5,2,1,2,2,1,2,2,0,2,2,2,0,2,2,2,3,4,2,4,2,2,0,4,2,3,3,3,4,3,3,7,3,3,1.5,6,2,4,4,4
,,,,Strategy Pattern,Builder Pattern,Composite Design Pattern,Adapter Design Pattern,Flyweight Design Pattern,Template Method Design Pattern,Prototype Design Pattern.,Template Method Pattern,This is not an adapter because the issue is not to enable BubbleSorter to be able to work with other classes but to handle differences in the type of data type being sorted.,Abstract factory pattern,Prototype is used to clone or copy a fully initialized instance whereas here we are creating instances of several families of classes.,Proxy Design Pattern or Data access object pattern,The problem described here requires the interface to be modeled as per the service required from the database. But Adapter is used to provide an interface that suits the inventory applications requirements.,State Design Pattern,Here the system responds to different inputs in a different way based on the current state of the system. This is a very singular attribute of a state pattern. But Abstract factory is simply used to create objects of families of classes.,No. There is no checks for correctness such as hour being between 0 - 23 or the minutes and seconds being between 0-59. As there is a chance that wrong values can be set to these instances hence losing correctness and accuracy of the clock.,0&lt;=hour &amp;&amp; hour &lt; 240&lt;=minute &amp;&amp; minute &lt; 59,1. The array lengths of A and B should be same.2. Both must be integer arrays.,Yes there is. There is no way for the method to know length of the array. Hence it cannot copy the data from A to B consistently. Also there is no way to check if the memory allocated to array B is enough to store all the elements in A. Finally there is no way to indicate errors to the caller in case the API fails for some reason.,The array B must have all the values from A in the same order they occurred in A.,The function should simply return the input array as the output by adding a return statement and type that returns an array.,"As the items can be distinguished from each other from productID which is present in the Item class, hence it is easier for the Item class to check for this condition. This is GRASP Pattern or principles provide the correct way of assigning responsibilities to different classes in the system.",Cloning is used when you need a true copy of another object. For example in case of a bank transaction we need to clone the account details of a customer to run the transaction and then replace on the original object.In the above example the need is only for creating two instances of MyClass which can be done by a simple new call.,Adv:1. This is the simplest way to do this hence very efficient.2. This method occupies the least memory among the three.3. It is faster to access the location information for each user.Disadv:1. No way to classify the person objects based on locations.,Adv:1. Provides additional feature of classifying people by the location they were born.Disadv:1. No way to retrieve the location of birth given a particular person object as the person object has no reference to the location.2. More memory.,Adv:1. Collective queries can be easily answered.Disadv:1. Deletion of a person or location object needs the table to be updated.2. More memory.,We can use the Flyweight Design pattern could be integrated to add the feature sharing a single instance across all the usages.,"Yes, if the application requires the data in different formats its better to provide different types of getAmount methods.1. public float getAmount():Adv: 1. Its simple and easier to represent fractional values.2. Takes less memory compared to number of cents.3. Easier to disply value to user.Disadv: 1. Round of error2. public int getAmountInteger() , public int getAmountFraction():Adv: Simpler and takes less memory.Disadv: Needs two methods because of fractional part.",Yes. It is needed to retrieve the current amount of currency represented by that object. This can be for anything from displaying to calculations required by the clients using this object.,Support for divide by errors are already present in java. Hence there is no need to test for logical errors by using classes. Also the values are represented in long (number of cents) hence cannot store double values to perform multiplication and division.,We can use the Decorator Pattern to display the currency in different formats based on the type of currency it is. Hence we can keep the Money class intact but provide support for displaying different currencies by extending the display method.,1. In systems where certain times the object might never be used the lazy initialization becomes very advantageous as there is no additional processing.2. Lazy load helps the application initialize faster hence may provide better performance in some cases.,1. There is additional time lost when a particular service is required and the object is not ready. Especially if the object initialization is a heavy process.2. As the initialization code is spread across the code base in order to implement this there are chances of confusion and bugs with respect to programming and bug fixing.,For the simple reason that the instance variable might not be initialized when the client tries to use it. If it is protected the getter method can insure that the instance variable is initialized before use.,There are several losses if this kind of design is used.1.If there comes a collection that does not have an index then this design will fail.2.It will be difficult to upgrade the application to other collections.3. Increases complexity for the client application as it has to maintain the index variable.4. There is also loss in modularity in the code.5. There might be performance losses in some cases as the Iterators can be optimized for better performance than just using an index.,Observer - Person trying to reach executiveSubject - Executive who notifies person trying to reach him.,"""Leave a message asking the executive to call you back when she is free.""The leaving of a message is the registration process and the calling back is the notification process defined in the normal Observer pattern.",It uses the Push model as the JButton notifies the listeners irrespective of whether they need the data right now or not. Here the Observer is not polling the Subject.,Push: 1. If the application needs the information as soon as its available this model is useful.2. If its a state machine that depends on the notifications for input.Pull:1. If the clients or observer is ready to accept data only if they are ready then the pull method is better. 2. Situations where the observers are dynamic such as clients retrieving data from a server its better to wait for the client to initiate the data transfer or notification.
,,,99.5,2,1,2,2,2,0,1,2,2,2,2,1,1,0,1,3,4,2,4,2,1,4,4,3,3,3,3,4,2,2,7,3,3,1.5,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy Pattern is the most suitable as the algorithm for calculating area changes with the kind of curve we are using.,"Decorator pattern is the ideal choice as we can add all the required decorators to the object like header, footers when required.",Composite design pattern would be the ideal choice as we can treat both components and containers alike.,Adapter pattern is the most suitable as we can create an adapter wrapper around the incompatible interface and use it in our program.,Singleton pattern would be ideal choice as it creates only one instance.,Bridge pattern is the ideal choice as we can separate the implementations from abstractions.,Memento pattern would be ideal as we can save the state and use it again later.,"It is a Template pattern which is being discussed above. But we can also use Strategy pattern in this case. Both of them are suitable.Difference is TEMPLATE METHOD pattern allows a generic algorithm to manipulate many possible detailed implementations, but the STRATEGY pattern, by fully conforming to DIP, additionally allows each detailed implementation to be manipulated by many different generic algorithms.","The polymorphic calls (one message, many methods) allow one generic algorithm to manipulate many possible detailed implementations.Polymorphic calls are outOfOrder(index) and swap(index). It cannot be an adapter as the adapter class uses the existing interface and wraps around the adapter to make the interfaces compatible. But in this case, BubbleSorter is the super class which can be inherited by different kinds of subclasses which just try and implement different functionality in the given functions.",This is an example of Abstract Factory pattern.,"The client code would get an appropriate instance of the DocumentCreator and call its factory methods. Each of the resulting objects would be created from the same DocumentCreator implementation and would share a common theme (they would all be fancy or modern objects). The client would need to know how to handle only the abstract Letter or Resume class, not the specific version that it got from the concrete factory. Hence we cannot perform this using Prototype which requires a prototypical class which is specified previously and then it is cloned. But here we are not sure of the class we are going to be instantiating. hence Abstract Factory pattern is suitable and not Prototype pattern.",This is an example of Facade Pattern. Facade provides a higher-level interface that makes the subsystem easier to use. In this case there are too many relations which is difficult for the client to use.,"It is not an adapter because the question says the client is able to open the connection, get the model and then read the data. There is no problem of incompatible interfaces for wrapping it up with an adapter. The problem is of complex subsystem with lot of interfaces, hence we use Facade.",Singleton is the most suitable pattern for this problem.,Abstract factory is used when we are not sure of the class we have to instantiate. Here we know that we need which kind of box to be created. But the requirement is that we should always have a single instance of the box at any point of time. Hence we should use Singleton.,"No, the class is not well formed. The reason for this is that the Set methods do not perform any tests when the user sets a particular value. The minutes field though is an integer cannot have a value greater than 59. Also, it cannot be a negative value. These conditions are not taken care in the class setMethods.Also in the case of hour, the value can depend on the clock format which is not specified. Also, it has a maximum value of 23 which is not taken care of. Negative values are also not handled. Hence we can safely say that it is not well formed class.",The range of values that Hour can hold is a class invariant. It ranges from 0-23.  (hours <24)The range of values that minutes can hold is a class invariant. It ranges from 0-59. (minutes <60),"Check for the following conditions before the copy:1. start_pos, end_pos, index_pos: INTEGER)2. other.lower <= start_pos3. end_pos <= other.upper4. lower <= index_pos5. index_pos + end_pos - start_pos <= upper6. Check if array B has space for length of array A.7. Check if the indexes used in both arrays are consistent for the copy to be in the same indexes of the array.8. Check if the array A has valid data.Start, end,  index are with respect to the source and other.upper and other.lower are with respect to the destination.",1.The ambiguity is the data copied cannot be validated. The question specifies that old values of B are lost. We cannot validate this from the behavior of the method. 2.,The following are the post conditions:1. Check if all the data is array B has data of length equal to array A.2. Check if the firstIndex of Array A + length = firstindex of Array B + length (first index is stored before copy started).3. Check if data in ArrayB is consistent.,We have to make sure the client passes the right arrays with enough space in destination and some valid data in source.The client has to take the repsonsibility of sending correct data input.,"According to the Information Expert GRASP Pattern, we should assign the responsibility of determining equality to Item, because it has the information needed to fulfill the responsibility.In our shopping cart example, we used extensive use of the ArrayList to store the items, hence the traversal and indexing will be done using the ArrayList.IndexOf method which uses the System.Object's equals method to determine if two Items are equal.  Thus, Item is determining equality with respect to other Item instances and the Information Expert GRASP Pattern is being fulfilled. Hence to summarize: all the responsibilities of an object should be handled by the object itself according to Expert pattern.","Clone method produces a shallow copy of the object. Hence even after doing o2= o1.clone(), both o2 and o1 are pointing to the same memory. hence we get a null pointer exception.",Advantages:1. We have a tightly coupled design which is suitable for this problem as they dont change.2. Its simple to work as we can have setters and getters for accessing them.Disadvantages:1. We are creating multiple instances of the same location (for cases where many people are born at same place). This results is memory wastage.2. It is not very abstract design for further extension if the location type changes. It is not closed for modification.,"This is efficient compared to the previous design. Here we have a location object which references multiple persons. Hence we have an advantage of lesser memory wastage. Also it helps forming aggregates. But the problem arises when indexing is performed with respect to the person object. As Location has reference to person objects and person objects find it difficult to access/set the location. Also, it is not very convenient to add and remove person objects.",This is similar to hash map where person and location objects are maintained by a third entity.this is efficient in terms of memory as no wastage of memory happens since the third object can have a set of location objects and map them to person objects.Also adding and deleting persons will be easy and less modifications.,To solve the problem of value 1$ not being changed we can have USMoney class be immutable and avoid any mutator methods.We can also use a factory method where the factory method can be modified to support singleton get_instance function. hence using this technique we can make sure there are no two instances of 1$ objects in the system.We can make an instance -controlled class and hence single instance will be created.,"Returning the values in cents as a long value has some advantages like: it can be used for comparing the money objects, use for complex financial calculations But the disadvantages is that if comparable is implemented, then it is not very useful. Also, it will waste a lot of memory considering the number of objects which maybe instantiated.",We need the getAmount method to get the value of money in the total amount of cents. This will be used to perform operations on the money class. This method is not required as we have implemented comparable for Money class. hence we don't need to have a common means of representation of dollars and cents which would have been useful for comparison. But this is only true if we have assumed to override the compare method.,"it is a bad idea to use floating point to try to represent exact quantities like monetary amounts.But since we are using floating point arithmetic for Multiplication and division, it is not advisable to directly operate on the USMoney classes which may result in precision or round-off issues. Hence we should always deal with them in terms of doubles.","While NumberFormat is abstract and you work with instances of it through various methods like getIntegerInstance(), the DecimalFormat class offers a concrete version of that class. You can explicitly specify the character pattern for how you want positive, negative, fractional, and exponential numbers to appear. If you don't like the predefined formats for the different locales, you can create your own. (Under the covers, DecimalFormat is probably what NumberFormat is using.) The basic DecimalFormat functionality hasn't changed with the 1.4. release of the J2SE platform. What has changed is the addition of the formatToCharacterIterator(), getCurrency(), and setCurrency() methods.ChoiceFormat is another of those concrete subclasses of NumberFormat. Its definition and behavior haven't changed with the 1.4 release. ChoiceFormat doesn't really help you format numbers, but it does allow you to customize the text associated with a value. In the simplest case, imagine displaying an error message. If there is a single reason for failure, you want to use the word ""is."" If there are two or more reasons, you want to use the word ""are."" ChoiceFormat allows you to map a range of values to different text strings.For example: We can have use BigDecimal, int, or long (BigDecimal is the recommended default)the int and long forms represent pennies (or the equivalent, of course)BigDecimal is a little more inconvenient to use, but has built-in rounding modesdouble or float are not recommended, since they always carry small rounding differencesthe Currency class encapsulates standard identifiers for the world's currenciesYou designate a specific currency based on its ISO 4217 currencycode, for example ""USD"" or ""JPY"". Or you can specify a currencybased on a locale, for example ""Locale.JAPAN"".The Currency.getInstance method returns a Currency object that isinstance-controlled. This means that there is only one instance for each currency.The Currency.getSymbol method returns the symbol for a currency, for example ""$"" for the US dollar. If a symbol cannot be determined, then the currency code is returned. The symbol for a specific currency can vary based on the locale specified togetSymbol. For example, in the United States, the US dollar symbol is ""$"", but in Canada, the symbol is ""USD"".We can then create a representation interface which will be responsible for displaying the money appropriately. We can use Strategy pattern to produce multiple concrete strategies which use the above given functions defined by java library to produce the required display representation. Number of digits :<=9 : use int, long , or BigDecimal<=18 : use long or BigDecimal>18 : use BigDecimalRemainders for Big Decimal:BigDecimal objects are immutable - operations always return new objects, and never modify the state of existing objects","Advantages of Lazy initialization1. Say you have an object with a property that uses a relatively large amount of resources and you know the property may never be accessed in impending future. Consider waiting to create the property until it's actually needed, especially if you are creating large numbers of these objects. Lazy initialization helps in saving resources2.  You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.3. improve performance, avoid wasteful computation","1. Major disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.2.  time penalty associated with each access of the variable caused by the #isNil test.","when using lazy accessors one can't ever access the instance variable directly from inside the class. You need to always use the accessor method.Being object oriented code, there's a chance the class could at some later date be subclassed. If so, the programmer doing so might not like the default you've chosen, and not making the publicly available instance variables in the code offers him no chance to override your decision. This is not very desirable.","1. Using this we can get our work done. But we cannot have multiple simultaneous iterations on the same object using this design. 2. Also if we use an external object for the responsibility of iteration, then because they are external, you can share them?you can pass them around to other methods and objects. This cannot be done in this case. 3. Its practically impossible to compare two collections for equality using this design.basically we are not using the powerful tools Abstarction and Delegation which will help in seperating the responsibilities and making it more flexible.","Observer is the Caller and the Subject is the executive in the company, as the caller is trying to see if the executive is free.","The third choice closely resembles the Observer pattern as the Caller (Observer) registers to the Subject (Executive). And when the executive becomes free, she calls him back (which is equivalent to notify() method).","ActionListener interface uses the Push model of communication as the Observer is polling the subject to register itself to the Subject. The ActionListener interface specifies just one void method to handle ""action events"", named actionPerformed. The addActionListener method allows us to add to a JButton any object implementing this interface (in fact, we can add more than one if neccessary, and each in turn will get to handle the event).We can use an ActionListener object to add a special action to another action listener (which is used in the case of controller components that both push and pull values).","There are 2 ways for observers to get information:for example, need new temperature when a weather report changes.pull model: observers invoke methods on Subject requesting information. WeatherReporter.getTemperature()push model: Subject passes information to observers as an argument to update()var infoObject.temperature = newTemperature;...observers[i].update(this, infoObject);both push and pull are valid: which to use depends on program requirementsProgram requirements for Pull model:1. Subject needs to know the needs of the observer.2. Its making observers harder to modify without affecting subject.3. Observers subscribe to a single event type therefore require one single type of event data (if any).4. When we require completely decoupling the Observers from the SubjectProgram requirements for Pull model:1. When we require more method calls on the subject.2. In a very dynamic environment when the state of the subject changes very rapidly."
,,,106,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,3,4,2,4,2,2,5,2,3,3,3,3,3,2,3,7,3,3,2,6,2,4,4,2
,,,,Strategy Pattern,Decorator Pattern,Composite Pattern,Adapter Pattern,Singleton Pattern,Bridge Pattern,Template Pattern,The Strategy Pattern.,This is not an adapter pattern as we are not designing to any particular interface we want to use. We are just using an anstract base class which calls two other abstract methods outOfOrder and swap which can be implemented for any tye of data type we want by just coding them to compare and swap our required datatype. Here we are not making anything that makes two incomaptible interfaces work with each other and hence it is not adapter pattern.,Factory Pattern is used here.,This is not an example of Prototype pattern as we are not using any protoypical instance to create new objects and we are not making a copy of the prototype to create a new object.,Builder Pattern is being used here as the various inputs from clients are used to do a certain thing and more than one step is being done for retrieving the final information.,It is not Adapter pattern because we are not trying to make two incomaptible interfaces work with each other by providing a common interface. All we arw trying to do is take the output and from various methods in various classes and then use that as an input for getting the next output. After multiple such steps we are getting the needed information as the the final output. This is exactly what the Builder Pattern does as the Builder is being called based ont he different inputs from the client.,The command pattern is being used here as the system has been pre programmed to do a certain action when a certain command is given. For every command we have a specified action which is just performed by the word processor.,This is not Abstract Factory as we are not constructing any families of related ot dependent objects without specifying their concrete classes. We are simply performing an action based on an input.,The above class is not well formed as its getters and setters are public and anyone can set the value of instance variables hour and minutes to any random values and it may thus display some invalid time.,An invariant for this class checks that 0<= hour <= 23 and 0<=minutes<=60. This invariant can be checked and must hold true at the entry and exit of the public member functions. The condition about hours should be checked at entry and exit of the getHour() and setHour() functions and the condition for minutes should be checked at the entry and exit of getMinutes() and setMinutes() functions.,The pre conditions for this method are that:1. The lengths of arrays A and B must be greater than zero.2. The lengths of arrays A and B should be the same.3. The datatypes of arrays A and B should be the same.,The ambiguity in the behaviour of this method is that no action has been specified when the length of array A is zero and it does not contain any elements. Another ambiguity is that there is no specification as to what should be done in case the datatypes of the arrays A and B dont match.,The postconditions are:1. The array B will be modified.2. The arrays A and Bmust have elements in the same order. 2. The old values of array B are overwritten and array A remain the same.,"In case we remove the precondition in order for the method to work, then we should resort to ""tolerant"" style of programming. The supplier takes up the responsibility of checking the conditions in the method call and an if statement in the body of routine can be used to handle the error conditions. This adapts to a variety of cases and we can add effective error handling mechanism to the code in the function copyArray()","The class ShoppingCart should have the responsiblity of deciding whether two items are the same. This is not the responsibilty of the class Item because the class Item only maintains information about a product but it is the responsibility of the shopping cart to check whether an item of that type already exists in the shopping cart or not. This makes sure that separation of responsibiltiy is there. We are using the Visitor Pattern here which traverses the arraylist of items and checks if an item of the given productid already exists in the arraylist or not. If it does, then the visitor method just increases the quantity of that particular item else a new item can be added to the arraylist.","This example is wrong because the default clone method of the Object class does shallow copy. In shallow copy an object is copied without its contained objects. In shallow copying o2 will have new object id but it will point to the anymethod() of the original object o1. So in case o1 is pointed to null, then the reference to anymethod() of o1 will be lost and when o2 tries to call anymethod with the old reference that it had, it will be given a NullPointerException, as the reference to that method has been made to null by the statement o1=null.  This problem occurs because o2 is using the same reference to the anymethod() that o1 is using and when o1 points to null even o2 loses the reference.","The advantage of this type of design is that we have in one place the required information about a person.i.e the person object itself knows the location of birth and we do not have to use an additonal method call to retrieve it. The disadvantage of this type of design is that data is not being stored at just one place. There are separate Location objects to store the data as well it is being stored as an instance variable of the Person Object. In case we need a location object also, we have to query the person class which is not a right approach.",The advantage of this type of design is that it is very easy to retrieve all persons belonging to one Location Object. That is the storage and retrival gains are found here.The disadvantage is that if other objects need to access Person Objects then the Location would have to have a getPersons method that returns the list of persons. This is not effective as there is no proper separation of repsonsibility. This means the class which is not responsible for Persons is storing the data about persons and this is a disadvantage.,The advantage if this type of design is that the the data related we can retrieve the Person adn Location with one access.The disadvantage is that we are having an external object maintain our data. The basic principle of encapsulation us being violated here.,We can use the Singleton Pattern to create only one object to represent $1. One way of doing  it is we can use an instance variable to create the object when the class is loaded. In this case a public static final USMoney instance representing $1 is created and it is accessed by using the call USMoney.instance; which returns an already created instance of that class. In this case the constructor is made private so that no more instances can be craeted. Another way of doing it instantiating an USMoney insatnce as a private static final instance and having a public getter method which returns a copy of the existing instance. This has a method call USMoney.getInstance() which is the name of the getter method. In this case also the constructor is made private.,"If there are variations on the getAmount method such that it returns money in some other form other than the number of cents in long value, then there could be possible advantages and disadvantages. Suppose it returns the money in the form of dollars and cents then advantage is that it is easier for the user to understand and there will be more clarity but then disadvantage is that fractional cents will not be allowed. In case we use a long integer with an implied decimal point we need to have a proper function for converting it into the proper format for printing. We also need to store the additional data to locate the decimal point. In case we have a class for USMoney we can return the amount as",getAmount method can be useful when we need to know the amount of USMoney we have and case we later extend the application to use it for conversions among various currencies.,We add and subtract USMoney objects as we know that the resut will surely be in the form of a USMoney Object but in case of multiply and divide we use doubles because we might have to convert a lower type into a higher in case we there are incompatible types and later store the result again as a USMoney Object.,We can probably put the toString() method in a separate interface and depending on the type of currency being returned  call could be delegated to the specific method so that it will print the moeny as per the currency specific representation.,"The advantages of lazy initialization is that it improves the performance. It delays an expensive operation unless it is necessary. If the initialization of an instance variable is an expensive process, then this can be delayed.","Disadvantage of lazy initialization is that code becomes more complex, as we have to perform a check before an instance variable or an object is initialized as to whether it has previously been initially initialized or not. If its not initialized, then we have to initialize its value.",Making variables that are initialized lazily public is not a  good option as it might not be thread safe and multiple threads may tend to initialize that variable multiple times in the system and this situtation could be terrible in a concurrent system and this may lead to errors.,"If every collection has a get method and the responsiblity of iterating through the data is not handled by a separate iterator object, then the collections have to implement the above given  interface. Implementation of the abve interface varies for each collection and this complicates the collection. In order to iterate through the various collections we have to know how the elements of that collection are being represented and have to know the internals of how the collections are being represented which is not a good idea.Using a separate Iterator Object gives us a uniform way of traversing through all the collections and it works with any of the collections.",The person who is trying to reach the executive is the Observer and the Subject is the executive.,The last choice where the executive calls back when she is free corresponds most closely to the Observer pattern. This is because the caller(observer) is notified by the subject(executive) that she is free which is the basic implementation of the Observer Pattern.,Here the Push model of communication is being used. This is because the subject here is JButton and when a click occurs the JButton is notifying all listeners(Observers) that an event has happened.,Push model would be better suited if all the observers would like to know and they use all the events and updates that are generated by the Subject. This will be more efficient as everyone makes use of the information being passed to them.The Pull method would be better suited if observers would like to know some of the events but not the events generated by the Subject. This is better when observers do not need to know every update and this method can reduce the network traffic and increase performance of the application.
,,,102,2,2,2,2,1,2,0,2,2,1,2,0,2,1,2,3,4,2,4,2,2,3,4,3,3,3,3,3,2,2,7,3,3,3,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy pattern,Decorator pattern,Composite Pattern,Adapter pattern,Flyweight pattern,Bridge pattern,prototype,Iterator pattern,Here there is no external interface that we are trying to adapt to (in essence there is no client class that expects a particular interface). A sub class of the abstract BubbleSorter would just provide an implementation for the outOfOrder and swap methods depending on how the array is stored.,Abstract Factory pattern,We do not know the exact class of the object we are creating. Also creating an object is not necessarily very expensive.,"This is an example of ""template method""","Here the algorithm consists of a set of general steps each of which depends on the exact implementation of database, model and element. Also we are not necessarily trying to adapt to third party interface to our client's interface.","This is an example of ""Observer pattern""",Here the key is not how to create the dialog boxes but rather when to bring up the dialog box. This depends on some action or event. Hence this is observer and not abstract factory,"No this class is not well formed. We can make a call to the set hour method and pass in ""25"" as the argument. This would make the time represented by the object invalid. The same can be done for minutes. Hence we may create an object and change its state such that the class invariant is no longer satisfied",Since the time object represents valid time is 24 hour clock we could have an invariant like0 <= hours <240<= minutes < 60,1. length of A should be equal to length of B2. Both A and B should be integer arrays.,Yes there is. It does not really specify what should be the behavior if the length of A and B are different. Also it does not specify what should happen if the list A is empty (though this is a special case of length being 0).,A and B contain the same values. In other words B is a copy of A,we could check the lengths of both arrays A and B and throw an error if lengths are not equal.,The shopping cart should have the responsibility. This is justified by the fact which states that a class which owns the data should also be the one that manipulates the data. Since only the shopping cart contains the list of items it should be the one to decide whether to add a new item to the list or to update an existing item in the list. Item does not know about the other items in the cart.,We cannot simply call o1.clone(). This would revert to object's clone method. In order for this to work MyClass would have to implement the Clonable interface. Other wise this would cause an CloneNotSupportedException.,"AdvantagesIt uses delegation. The person class need not worry about the details of how a location is stored (could be place, country, longitude, latitude,etc). It could simply ask the location object when these details are required.DisadvantagesIf the interface provided of the location object changes we might have to change the functions in the person class which delegate to location.",AdvantagesDepends on the type of application. Suppose we are more interested in getting demographics of a particular area this would be useful. We could simply query the location for list of person's born there and do some processing with the collection returnedDisadvantagesIt is not very OO. The location class really does not need to know about person's born at the location. It violates the expert pattern. Now location  is the one that knows a persons place of birth and not the person himself.,"AdvantagesIt cleanly separates the implementation of person and location. Each can change their implementation independently as long as the interfaces remain the same.DisadvantageThe person class has to as the ""third class"" every time it requires some information about this location. Of course it is possible to cache the location information, but this might lead to concurrency issues. Also If the data in the third class becomes corrupted then we would lose all information.",This can be done using the singleton pattern. We would have to make the constructor private and have a get instance method that returns an instance if such an instance is already present. Other wise a USMoney object representing $1 is created.,"1.return the amount as x.y dollarsAdvantagesEasier to read and understand when compared to number of cents.Useful in calculations which require high precision.DisadvantagesCould lead to errors if we round off the values.2. return amount as 2 integers ""dollars"" and ""cents""AdvantagesAgain easier to read and understand. Would be useful for calculations which ignore the number of cents.(large numbers probably).DisadvantagesWe need to come up with a way to return the two integers from one function.( Probably as another object)",If we had a collection of USMoney objects and we would like to find the total value of money we had we would need to know how much each object is worth. (Example would be our wallet where we had notes with different denominations),"Since multiply and divide operations are not clear for USMoney object (what does it mean for one USMoney object to be multiplied with an other USMoney object, same applies for division). The multiply and divide operations are clearly defined for double data type.",This could be done using the decorator method. We could create a decorator that has uses the currency class to get either the symbol for the currency or the three letter code. It could then format the the output as required. For example SymbolDecorator would print $3.14 and some other decorator class could print 3.14 USD,It avoids wastage of memory if the object being created is large and would never be used again.,It increases the code complexity. Also it can lead to race conditions in a multithreaded environment if two threads call getInstance() at the same time.,There is a possibility of getting a null pointer exception. Suppose we have  a variable has been declared public and has not been initialized (hence its value is null). Now a third class can directly access this variable and use it in its computation. This would cause a null pointer exception,"If the collection refers to elements by strings rather than by by integer indexes (like HashMap does) this method would not work.If the collection were to implement the get method then in addition to storing the set of elements the collection would also have to know how to iterate through the elements which is not really the responsibility of the collection. Also we would have to recast the value returned by the get method before we can perform any operation with the data. Now in order for casting to work each collection should also implement the ""clonable"" interface.","The observer is the ""executive"" and the ""I"" am the publisher","""Leave a message asking the executive to call you back when she is free."" is most closely related to observer pattern. An event is generated which prompts an action from the other person. Choice 1 is like a blocking send. I have to wait until the other person is free. Choice 2 is like polling.","It uses push model for communication. When an event is generated the information is sent by the system to the subscriber. Here the responsibility of informing the subscriber lies with the generator of the event(keyboard, button, mouse etc). In java there is an event queue which catches and processes events. This also notifies listeners",Pull Model - When events are relatively rare and the interval between events is significant. Web page content changes require refresh.Push Model - When events occur very often and the time interval between events is very small. Example stock prices.twitter streams
,,,98,2,2,2,2,2,2,1,0,2,2,2,0,2,0,2,3,4,2,4,2,2,0,4,3,3,3,3,4,2,2,7,3,3,3,6,0,4,4,4
,,,,Template Method,Decorator,Observer,Adapter,FlyWeight,Abstract Factory,Memento,Template Method,"Adapter pattern is used to convert interface of a class into another interface clients expect. If the existing code behaves in a certain way but the clients are providing different parameters and expecting the same result, then adapter pattern can be used.However, here, the sorting method is abstracted out and used on various inputs like varying data structures.",Abstract factory,"Prototype pattern is used when initializing new objects want to be avoided and cloning can be used instead. However, here, client needs to only know about the abstract class without worrying about the concrete classes. Therefore, its abstract factory pattern.",Chain of Responsibility,"Adapter pattern adapts from one interface to another. Here, the required information is fetched by a chain of objects, one helping the other in a series.",Observer pattern,"This is not Abstract Factory because in that pattern, common functionalities are abstracted without having to know about concrete classes.","No, the class is not well formed. There is no check performed to check if the hour is being set in 24 hour format.","The class invariant for this class would be a check to see if the hour is in 24 hour format. We could have a boolean variable ""ampm"" which if set to false implies that it is in 24 hour clock format. We could use assert statement to check if its false.",The preconditions are1. Length of the input arrays A and B are equal.,"The following give rise to some ambiguity1. If the length of array B is greater than that of array A and array B had some old values, what happens to the post conditions2. If the length of array B is smaller than that of array A then what about the post condition.",Post conditions are1. The array B is an exact copy of array A,Changes should be made in the method to check the length of the 2 arrays.1. If length of A &gt; length of B then appropriate message must be displayed.2. If length of B &gt; length of A then the values of B in the positions after length of A must be either set to some default or appropriate message must be displayed.3. A message mentioning the values of B being lost must also be included to have the user prepared.,"The ShoppingCart class should have the responsibility of deciding whether two Items are the same. This is because the data concerning the Shopping List lies in the ShoppingCart class, so it should update the quantity of the item that is added more than once.Example - The updateItem method can be implemented as shown below.public void UpdateItem(Item item){     item.set_quantity(item.get_quantity + 1);}This can be justified using the guideline - Encapsulation - One class should be responsible for knowing and maintaining a set of data, even if that data is used by many other classes.","Prototype pattern is used when a new initialization needs to be avoided. The purpose is not to clone and make one of the objects NULL. It is to create clone and delegate tasks to the right clone.Also, the program is incorrect. The cloned object must be cast, like below - o2 = (MyInt) o1.clone();Without this change, the program won't compile.","The advantage is that each Person is associated with one Location where he is born, which is exactly what is expected.The disadvantage is that if some attribute of a particular Location changes (eg -the name of the location changes), then the changes need to be in all the Person objects who were born in this particular location.","This is not as per the definition of the problem. Each person ""has a"" birth location. Location should be keeping track of all the persons born there.",The disadvantage of this way is that there is a third data structure that needs to be maintained.The advantage can be that it is organized well.,"One of the ways of doing it is by including a static variable in the class definition  that represents one dollar.public class USMoney implements Comparable&amp;lt;Money&amp;gt;{            private static final USMoney oneDollar = new USMoney(1, ""USD"");            public static USMoney getOneDollar(){                      return oneDollar;            }......................}","The getAmount() method is used by the methods that perform arithmetic actions on Money like the ""plus"", ""minus"", ""times"", ""dividedBy"" etc. If the getAmount method does not return money in the form of cents represented as long value, then the value returned by the method needs to be converted to cents before these operations can be performed. This would involve all arithmetic operations to first convert before operating. Instead, the getAmount can return cents represented as long as it can be directly used to manipulate. Therefore, it is not necessary to have additional methods. Even if we had additional methods, conversion to cents would still be necessary.",The getAmount method will be used by the other methods in the USMoney class which perform operations like converting to string for display and arithmetic operations.,"There is no real meaning behind multiplying or dividing two USMoney objects. Money can be added or subtracted just like taking money from someone or returning money to someone. Multiplying two money objects holds no meaning in the real world, it's like mutliplying cents, for eg, if there 3 quarters, then the total amount is 25 cents * 3 = 75 cents.If the USMoney objects are multiplied, it would result in 25 cents * 25 cents = 125 cents, 125 cents * 25 cents = 625 cents which is incorrect.The same holds good for division too.","The approach that we saw in class was public String toString() {String sign = (amount &lt; 0 ? ""-"" : """");Long absAmount = (amount &lt; 0 ? -amount : amount);String code = currency.getCurrencyCode();int fractDigits = currency.getDefaultFractionalDigits();int unit = tenToPower(fractDigits);if (fractDigits &gt; 0)return sign + absAmount/unit + "".""+ fill(fractDigits, absAmount % unit) + code;elsereturn sign + absAmount + code;}Using the code above it is possible to display in the format ""$3.14"".To change this to handle currency specific differences, we can also use a ""pattern"" which defines the pattern in which the currency is displayed, E.g. for Indian currency it will be ""sign + amount + code"" where amount will be of the form ""thousands, hundreds, tens"" (Rs. 1,000.54).In the above code where the display is handled in the lines that return, we can make use of the pattern of the currency display and display it accordingly. So we will need to include,String pattern = currency.getPattern()Then parse the ""pattern"" variable and display according to that.","The advantages are1. You often find you don't need to do the creation at all, and because you might save doing some work when the computer is already busy until a time when it is less busy2. If you never use the value, you don't pay for it.3. Ability to delay until needed information is available.",1. Code needed to check to see if it is time to initialize the value each time it is used.2. Time spent in the above code each time the value is used.3. Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.4. More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.,"Lazy initialization is often used design patterns like singleton. In this case, you want to prevent multiple instances. And that is the reason it is not made public.","This means that all the collections implementing this interface need to define the ""get"" method which is not a good design.This requires that the collection object being used be exposed, but while using Iterator, the underlying collection is not exposed.",Publisher is executive in the companyObserver(subscriber) is the caller,"Option 2 - ""Keep calling back every few minutes until the executive is free."" corresponds most closely to Observer pattern.This implements the Observer Pull model: When the Observer polls the Subject for the information.The caller(observer) keeps calling until the executive(subject) is free.",Push model.The JButton(publisher) notifies all the listeners(observer) when ever there is a click. That is the reason it is a push model.,"Scheduler - Consider a scheduling application. In this case, a push model is better. If a pull model is used, then a thread needs to be running constantly to check if there is a scheduled task at that time. Instead if a push model is used, then at the time the task needs to be done, the task can be assigned to the specific thread. Though all of then receive the information, only the concerned thread will act on it."
,,,84.5,0,2,0,2,2,0,2,2,2,2,2,0,1,0,1,3,1,2,4,2,2,2,4,3,1,2,3,4,2,2,5,3,3,1.5,6,2,1,4,4
,,,,Strategy.,Chain of Responsibility.,Composite.,Adapter.,Singleton.,Bridge.,Interpreter.,Template Pattern.,"The intent of Adapter Patterns is:1. Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn?t otherwise because of incompatible interfaces.2. Wrap an existing class with a new interface.3. Impedance match an old component to a new system.The above is not Adapter because here there is no existing interface we are trying to adhere to. Here, we have an algorithm and 2 slight variations of it.",Abstract Factory pattern,Each of the resulting objects would be created from the same DocumentCreator implementation and would share a common theme. This is not prototype because we are not co-opt one instance of a class for use as a breeder of all future instances.,Chain of Responsibilty,"The intent of Adapter Patterns is:1. Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn?t otherwise because of incompatible interfaces.2. Wrap an existing class with a new interface.3. Impedance match an old component to a new system.The above is not Adapter because here there is no existing interface we are trying to adhere to. Here, we have a series of actions to be performed in the given order.",State Pattern.,"Provide an interface for creating families of related or dependent objects without specifying their concrete classes. But, here we want to go from one state to another depending on the input.","The class invariant here is that 'The displayed time should always be a valid 24hr clock time'. We have no checks to avoid a program from setting minutes or hour variables beyond the valid 24hr clock time.This class violates the guideline - 'Methods should always keep objects in a well-formed state'. Our modifiers may not do their jobs well. Thus, this is not a well formed class.",The displayed time should always be a valid 24hr clock time.,The array B must have the same length as array A.,"A postcondition tells what the method guarantees will happen when it is executed. If the caller (client) can guarantee the preconditions are satisfied, the callee (server) guarantees that the postconditions will be satisfied after the call. That is, the method promises that it will do what the postconditions say if the client is careful to ensure that the preconditions are satisfied.Although unspecified behavior is acceptable in the case where a precondition fails, it is usually better for the clients of the method to know what will happen in all cases.  Therefore, a well-designed method will usually do some well-defined, appropriate action such as throw an exception if the preconditions are not satisfied and that behavior will stated as part of the contract.This method does not state what will happen if the precondition is not met. Thus, this is the ambiguity.",Array B will have values in the same order as those of array A.,"We could add the following to the post condition:if array B does not have the same length as array A.an IllegalArgumentException is thrown ** (some error has to be thrown, documentation does not mention anything specific)","According to the expert pattern - 'The object that contains the necessary data ti perform a task should be the object that manipulates the data'. Thus, Shopping Cart has the data of items added, thus it should be able to manipulate the data.",Since we did not override clone in MyClass.,"Advantages:1. The location of a person can be found very easily.2. Place of Birth is data that belongs to person, thus it is logical to have it in Person class.Disadvantages:1. Person can be extended or can have an association with many classes (viz. Student, Employee, etc.). These classes do not care about the person's place of birth.",Advantages: Disadvantages: this would become an unmanageable list to store with every location. there could be many persons born at the same location.,"Advantages: Classes which subclass Person, viz. Student/Employee may not be interested in Person's place of birth and thus, it is better maintained by a third objectDisadvantages: Information about location belongs to Person. This violates the expert pattern.","Whenever we want to create just one object of a particular class, we can use Singleton Design Pattern. To give an analogy, we can design USMoney class similar to the currency class where only one object of each type of currency is created. The difference being that here only one object of USMoney should be crated for each value.","The getAmount method could return the amount in number of 'dollars and cents'. Advantages:1. This is the more natural form of how we are used to dealing with money.2. This is how we display money in USD.Disadvantage:1. Would require little extra computation to get the desired form of 'dollars and cents'. Though, the computation is not large it would be considerable for number crunching applications.2. The toString method anyways displays the returned amount in the desired format.","getAmount method is used to know the amount of USMoney. But, this approach violates expert pattern because it will allow other classes to extract the data from a Money object and then manipulate it. The USMoney object should do the manipulations for us.","In real life, we usually never multiply or divide money with money. When we multiply we usually multiply with a number (or count), same goes for divide. Thus, we add and subtract USMoney objects, but we multiply and divide by plain doubles.","Like we used a third class, to help in conversion from one currency to another, here also we could use a third class. We can class this class MoneyFormatter. Like the MonceyConverter class, this class this class will have just 2 methods, viz. setFormat and getFormat. We will have to add a function or modify the existing toString function on Money to be called toStringUsingFormat to use this format.Currency Class has following method:getDefaultFractionDigitspublic int getDefaultFractionDigits()Gets the default number of fraction digits used with this currency. For example, the default number of fraction digits for the Euro is 2, while for the Japanese Yen it's 0. In the case of pseudo-currencies, such as IMF Special Drawing Rights, -1 is returned.Returns:the default number of fraction digits used with this currencySimilarly we could have a getFormat method..","1. If you never use the value, you don't pay for it.2. Initialization costs can be more spread out by not initializing everything at once.3. In some cases, startup appears to be faster.4. Ability to delay until needed information is available.",1. Code needed to check to see if it is time to initialize the value each time it is used.2. Time spent in the above code each time the value is used.3. Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.4. More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.,"Lazy initialization is typically accomplished by maintaining a flag indicating whether the object has been initialized or not. Each time the desired object is summoned, the flag is tested. If it is ready, it is returned. If not, it is initialized on the spot. Thus, we need to hide this implementation from the client, which we can only do if the instance variable in private and needs a method to get it.","Drawbacks:1. Thus, now our collection C is storing the collection also and doing the work of iterating over the collection also.2. The method size() is usually a slow function and would give the client information about how many elements are present in the collection.3. Iterators are an abstraction that decouples the concept of position in a collection from the collection itself. Now, we do not have that abstraction.4. The iterator is a separate object storing the necessary state to locate an item in the collection and move to the next item in the collection.5. Among other thing it enables you to have multiple iterators iterating the same collection.",Observer - Me.Subject - Executive.,Leave a message asking the executive to call you back when she is free.,"ActionListener interface uses the push model for communication. Explanation:The publisher (eg: CanvasEditor) subscribes to the subscribers (JButtons) via  ActionListener interface. Neither of the classes need to be aware of the existence of each other. The class which wants to keep track of changes does not need to keep polling for it. Instead, when a Jbutton is clicked, it notifies the Observer.","The push model of observer design pattern would be suitable for distributed push-based notifications, because it supports a clean separation between two different components or application layers, such as a data source (controller) layer and a user interface (view) layer. The pattern can be implemented whenever a provider uses callbacks to supply its clients with current information."
,,,91.5,2,0,2,2,1,2,0,2,2,2,2,0,2,0,2,3,1,2,4,2,2,2,2,3,2,3,3,4,3,3,5,3,3,2.5,6,2,4,4,2
,,,,Strategy Pattern,Decorator Pattern,Composite,Adapter Pattern,Flyweight Pattern,Bridge Pattern,Prototype pattern.,Template Method Pattern.,"There is no 'adapting' being done. And in adapter, code is not changed, just the interface handles are changed to our needs.",It is Abstract Factory pattern.,"In a prototype pattern, one would observe a clone object being returned. Or in other words, a cloning taking place so that the prototype can be returned. But, in the above we observe that an interface to create an object is returned. That is not the characteristic of prototype pattern.",Its a facade pattern.,"Its not an adapter because, it doesnt provide an alternate 'adapted' interface to the existing interface. Rather, it bunches together a set of different operations, to provide a single operation to the user. That is characteristic of a facade pattern.","Its a singleton pattern.Although, i see traces of observer pattern( click events )","In this implementation, if a dailog box is already open, it returns the same. else, it creates and returns a new one. But in abstract factory, pre-existence of objects for that class is not checked.","No, its not a well formed class. Since, it does not check the validity of the value held by hour and minutes. For example, the following is possible to be represented by the class.*50:54 *     But clearly that is not in 24-hr format. So due to the lack of class invariants, the class is not well-formed.",0<=hour; hour<=230<=minutes; minutes<=59,1. A != null2. A.length == B.length,1. A may be empty2. A may be null( but is checked in the pre-condition )3. They might not have same length( but is checked in the pre-condition )4. B may be shorter than A.,1. Equality of the contents of the arrays i.e A == B,A.length == B.length should be removed. Keeping A.length==0 is enough. Other sanity checks will be done in the post condition checking.,"_items is best put inside Item as a static arraylist. This way its only one copy.And moreover, it also makes sure there is high cohesion( All item related checks inside Item)","This is wrong because that code snippet will not raise a Null pointer Exception.when o2 = o1 is called, the refernce is copied into o1. Now o1 and o2 are pointing to the same object.After o1 = null is executed, o2 still retains the reference.So, the command will run smooth.Had the order been,o1 = null;o2 = o1;A null pointer exception would be thrown since o1 is set to null *before* its reference is copied to o2.","Advantages:1. Its a simple design2. Since delegation is done, implementation can be easily changed.Disadvantages:1. Same location object is stored duplicately.2. Reverse querying is not possible. i.e given a location, querying the list of all persons.","Advantages:1. only one copy of unique location is created. This saves space.2. Easy in handling grouping queries.Disadvantages:1. Given a person, it is not possible to retrieve his Location. And that kind of beats the purpose.",Advantages:1. Two-way querying is possible i.e Person=>Location or Location=>List of Persons.Disadvantages:1. The same location object is being stored in multiple places. This unncessarily consumes more memory.,"We could maintain a hashmap <int,USMoney> where it represents <dollars, USMoney>1. check if a hash entry exists for this mapping.2. If no, create one and continue as normal3. If yes, return that USMoney Object.public USMoney(int dollars, int cents){USMoney existingObject = dollarMapping.get(dollars);if(existingObject == null){//Reuse code dollarMapping.add(dollars, usmoneyReturned);}else{return existingObject;}}}","Yes, there can be more formats.1. number of dollars as Float Advantages:* Easier for conversion as most of other currencies are based on the dollar and not the cent.Disadvantages:If a new USMoney is to be created by combining the amount of two different USMOney and convferting back, it would be a slightly more intensive calculation because of the almost sure occurance of dollar with a floating point.2.","Yes, a getAmount method wil be used to convert USMoney to a concrete type ( long ) so that it may be used to perform conversions. Or in another rare situation when its decided that say, 105 cents make a dollar or something like that.","Its because* If we consider multiplication to be a repeated addition, to multiply something to X, we basically *add* X different somethings together. So in the equation of a*b atleast one of them has got to be a number.Also, considering in terms of scientific units, USMoney X USMoney will return USMoney^2 which is not of the type USMoney. It defies logic to do it that way.* In the case of division, it is also because of the disparity in the Units mentioned above.USMoney / USMoney shoudl return a plain number. But we need an output of USMoney.Again, logically the denominator has to be a plain number.","We could have a decorator pattern and numerous decorators.We could pass the amount object into the decorator, so that its display method is changed according to the needs.",1. You dont eat up the space for that particular object until it is need. This is particularly useful if that object is put to use in a low probability.2. Initialisation cost is more spread out.,1. Need a algorithm to check if its the time to lazy initialization.2. ALgorithm need to be run everytime to check if its time.,"They are publicly available. They can be referred to at any time. If lazy init is done, there is a chance, ther variable is not initialized yet. UNnecessary exceptions.","Not all implementations offer the prievilage of getting the 'ith' element. For ex. Stack. You are not allowed to look at the Ith element in a stack. This has not fully achieved decoupling of iterators, since every one of them is to return and element upon passing of the position 'i'.",Subject = ExecutiveObserver = Me,Choice 3,"ActionListener uses a push model. This is revealed in the fact that, after addActionListener is executed, the subject( Jbutton ) adds to its list the observer that added. And we see any action taking place only after any event occurs.","Push : 1. Instant messaging. Assume that two people are chatting. So, once any of these users enters any value, it triggers an event which ultimately sends the new chat data to the respective user's chat windows.Pull:Bus tracking system would be an example. We see that, in some cases, bus tracking is updated rather slowly. This would be because, the observer( the browser program ) queries the current position of the bus rather intermittently and updates, it."
,,,102,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,3,4,2,4,2,2,0,4,3,3,2,3,3,1,2,7,2,3,3,6,2,4,4,4
,,,,Strategy Pattern,Template Pattern,Template Pattern,Adapter Pattern,Singleton Pattern,Bridge Pattern,Adapter Pattern,This is an Iterator pattern.,As it doesnt have any incompactible interfaces.,This is an Abstract Factory pattern.,Here DocumentCreator is abstract factory.It is not  prototype because we are not creating new objects by copying the prototypical instance of DocumentCreator.,Abstract Factory pattern,As it uses Abstract factory interface  instead of colelction of interfaces.,This is a State pattern.,"Here it depends on the current state and on next input.It is not abstract factory as we dont use abstract interface for creating a family of related objects, without explicitly specifying their classes.","No, as it doesnt specify any TimeFormat and it doesnt show the method for total time.",It should be concurrent.,a) the length of array B should be equal to length of array AA.length = B.lengthb),"yes, the array B old values are lost after copying the array A values into it. As we are copying the elements into the array B in same order it do replaces the old values of B and keeps the new values into it.",a) The order of values in B and A should be same.for (int i = 0; i < A.length; i++) {        A[i] = B[i]},The arrays equal condition has to modified as (array A length is lessthan or equal to array B length)A.length <= B.length.,This can be done using Flyweight design pattern which is used to check whether the item exists or not do the corresponding action.,As we are accessing the prototypic object without speficying the kind of object.,The advantages of this design is that it has one to one relationship and it can be disadvantageous as it has to create a Location object for each and every person.,This type of design can be implemented using Singleton pattern. where the location object keeps the collections of references of Person Objects.Advantage is that we dont have to create too many instances.In general we need multiple instance objects.,,This can be implemented using Singleton Pattern.,"Depending on the number of digits (<=9, <=18, >18), the corresponding types int, long, BigDecimal respectively are recommended for representation. This requires the user to be aware of what values the representation needs to take up.",The getAmount method is needed as it returns the amount by adding the right and left side part of the currency and gives the total value.,We multiply and divide with a given positive or negative number using plain doubles as it reduces unnecessary object creation of USMoney class just to perform ordinary multipliaction/division,This can be done by creating Money objects as Factory method and writing a method in it to get the desired requirement.,"a) Lazy Initialization is a performance optimization where you defer (potentially expensive) object creation until just before you actually need it.Ex: One good example is to not create a database connection up front, but only just before you need to get data from the database.The initialization of these data stores can be postponed until they are used for the first time.b)users don't have to pay the initialization time for features they will not use.c)Reduce the risk of long start times.","a)However it is not safe for multithreaded environments. If separate threads of execution enter the Instance property method at the same time, more that one instance of the Singleton object may be created. Each thread could execute the assertion statement and decide that a new instance has to be created:. b)Another disadvantage is that the initialization code is spread around the class and occurs at an unspecified time. On occasion, this can lead to confusion.",We dont want to make the publicly available instance variables initialized lazily because it is required globally.,This design is wrong as we are traversing through the collection Collections C by writing the for loop which takes more time when we have large collection C.It can be modified by using Adpater to get the elements by accessing the Iterator object.,"Observer - User, who is trying to reach an executive.Publisher - Executive","The third option  is most closely to observer pattern:"" Call and be put on hold until the executive is free.""Here the Observer (user who is trying to reach an executive) who is interested in a piece of this information subscribes by calling the executive.The Publisher(executive) attends/publish the information when he is free.",It uses the Push method as it gives the required result based on addActionListener.,This can be implemented using the observer pattern by  using the Java lsiteners as stated.
,,,68.5,2,1,0,2,1,2,0,0,2,2,2,0,0,0,2,3,0,2,4,2,2,0,1,2,1,0,3,3,2,2,2,3,3,1.5,6,2,4,4,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,strategy pattern.,template method pattern,composite pattern,adapter pattern,Singleton Pattern,Interpreter Pattern,Builder Pattern,it is the Builder Pattern,Because it is not wrapping a class to fit the interface of another. It is dividing the function of the class into different parts and repeat them to get things done step by step,Facade Pattern,Because it is not about creating same objects based on some pre-created prototypical object. Prototype could be implemented when creating each different type of letters or resumes but it is not the emphasis of this paragraph.,Chain of Responsibility.,"Because it is not about compatibility at all. It is not about we can't make users get the information directly, and user must go through such a interface to get the data. It is a about how to manage the access and handling process to avoid coupling.",Strategy Pattern,It is not handling creating new objects.It is about providing different strategies based on different key situations to handle the dialogs.,"No, the hour and minutes variables should be declared as private,  Time() method is not implemented, there should be a method that returning or displaying the whole time. And there is no constraints to the value of hour and minutes.",invariant() {    assert(0 <= hour && hour < 24);    assert(0 <= minute && minutes < 60); },"A and B must be array of integers, they must have the same length. The elements of A must can be accessed. The array B should be re-writeable","There is no comparison of the length before passing A and B into the method, this is a precondition and should not be implemented inside the method. and How to deal with Array A after the copy? What do we return as the result of this method? Where should this method be implemented, and what is the specific purpose of doing this?",The content of Array B must be the same as content of Array A.,"public void copyArray(object A, object B)change the int[] to object.","ShoppingCart is responsible to do the checking. This is the expert Pattern, The object that contains the necessary data to perform a task should be the object that manipulates the data. The ShoppingCart has the list of Items handy, so it should be in charge of comparison.",".clone() only performs a shallow copy, which only copies the memory address of A to B, then when A is modified, B is also modified. You need to perform a deep copy to solve this problem","Adv: Easy to get the birth location information when you have the person object.Dis: The places have no idea who born on them, unless you go through each person and ask them where do they born, and match the place you are looking for.","Adv: Now places have good idea of who was born on them.Dis: When you ask a person where did he/she born, he/she need to go through each location and check the reference, otherwise he/she has no idea.","Adv: The table serves as Mediator, when ever some person or some location needs to find the other, they just need to turn to the table, and look up their names on it. when the data set is large, this is really efficient.Dis: Now neither the person nor the location has immediate idea of the other. When the data set is not that large, this design could be a waste.","make the methods final and declare the instance variables to be private, and don't provide any setter/mutator methods.","Having two integers one for dollars and one for cents: Adv: no rounding problem, easier to manipulate and display.Dis: Needs two different spaces for a single value, and even the cents only have 99 maximum, waste of memory.Having a long integer and a implied decimal point.Adv: No rounding problem, and long integer is more efficient to manipulate than long floating-number. And a implied decimal point is more space efficient than another value in ""Two integer"" approach. Dis: Needs extra methods to deal with the number when displaying it.","We need. We need to check how much money do we have in the pocket. And when a somebody is doing property checking to you, you need to present your money in numbers for him to manipulate. But it is not that necessary compare to real life, because when all the prices are tagged as USMoney objects, you don't need to take out the money, count, and compare, you just need to do compareTo(USMoney o) to see if you can afford it.","Because when we subtract and add, we are dealing with two specific money amounts. But in multiply and divide, we are dealing with a money object and a factor, we are not doing amount/amount, that makes no sense.","We could implement the Money class to be configurable, when initialize the money object, we can have the user pass in parameters like: Money m = new Money("","" , 4, code, behind) to configure the delimeter , digits between delimeters, whether use symbol or code, put it behind or front.Or we can also provide configuration methods to the class and have the user specify the format later after the creation of the money object.",1. Performance increases due to avoiding unnecessary calculations and avoiding error conditions in the evaluation of compound expressions.2. The capability of constructing potentially infinite data structures3. The capability of defining control structures as abstractions instead of as primitives---From Wikipedia http://en.wikipedia.org/wiki/Lazy_evaluation,"1. it is difficult to combine with imperative features such as exception handling and input/output, because the order of operations becomes indeterminate. 2. Lazy evaluation can introduce space leaks.3. debugging is difficult---From Wikipediahttp://en.wikipedia.org/wiki/Lazy_evaluation","Because the variables are created as null when the object is created, then when other objects get access to it without going through the object itself, the initialization process will not be triggered and exception could happen.",Then the object which is accessing the data will get the underlying representation of the collection.,"Observer is the one calling the executive, and the executive is the publisher","The third one. The observer pattern says several observer subscribed to the publisher and once the state of the publisher is changed, all the observers are notified. Leaving a message is like a subscription, several caller can do this at the same time, and when the executive is free, all of them will get notified.","push model, because the listeners doesn't check the press or the button, they just subscribe to the action, when action happens, they will automatically be notified.","1. Pull Model: When the actionListener listens to only one kind of information, there are a lots of this kind of listener and they do nothing else but listen to this particular order and do the reactions. For example, If all I can do is reading magazine and I read only one kind of magazine, I read no others, then there is no need to subscribe to it and waiting for it to be delivered, I will be wandering around the book store all the time checking if the new issue has published.2. Push model: When the action listener is very busy, which can not hold waiting for the information to be available, then push model is the best, it solves problem more efficiently."
,,,92,2,1,2,2,1,0,0,0,2,1,2,0,2,0,1,3,4,2,4,2,2,2,4,3,3,3,3,4,2,2,5,3,2,3,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy,Strategy,Composition,Adapter,Singleton,Bridge,Factory Method,Builder,"There is no conflict interface problem, only the implementation doesn't connect each other in two methods.",Decorator,"If this is Prototype, each class that is going to create an object must have a prototypical object.  The parent class implements the Cloneable interface. However, this is not rototypical object.",Chain of resposibility,"This is calling from a chain of class, it dose not requre any interfaces.",Template Method,The objects are not the same. They only follow same steps.,"No. The code cannot garantee valid 24hr clock at any time. Conditions like 0<=hour <=23; 0<=minutes<=59; need to be specified, but there is no such methods in the class.A class invariant applies to every class instance, as a whole. We should use it to make sure valid time.",public boolean satisfiesInvariants() {if (0<=hour <=23 && 0<=minutes<=59)return trueelse return false}And add the following statement to class:assert satisfiesInvariants() : <Error message>,The array B must have the same length as array A.,Yes. The name of method copyArray doesn't specify the array should be integer. Other types of data cannot use. This may be misused by other types.,the values of array A will be copied into array B in the same order,"When call the function copyArray(), first check whether length of B is the same as length of A, if yes, copy; if no, give a new length to B as the same of length of A, then copy.","ShoppingCart. According to Expert Pattern, one class should do one thing and do it well.Item class is only some attributes of a certain item, the number of items is not an attribute of item. ShoppingCart class has a method AddItem(), which should judge in advance whether the item is the same as that in the arraylist. If yes, only add one the the number of this item, if no, add this item to shoppingCart.","Each class that is going to create an object must have a prototypical object.  A creation-initiating object is invoked, and it creates objects by asking one of the prototypical objects to make a copy of itself.In this example, MyClass class doesn't have a prototypical object, so the clone method can not be implemented because the parent class cannot implements the Cloneable interface.","Pros: 1. Easy to understand, because one person will have one and only one place of birth. This is an attribute of a person.2. Easy to find a certain person's place of birth.Cons: 1. Difficult to find a set of persons that are born in the same place.2. A lot of person who are born at the same place will have to store the same location information, code can be reused, and waste of space.","Pros: 1. Easy to find a set of persons that are born in the same place.2. No vialation of DRY principle because one person's information can't be in two locations.Cons: 1. Difficult to find a certain person's place of birth, need to tranverse at worst all locations.","Pros: 1. Easy to find a certain person's birth place, and easy to find persons that are born at the same place.Cons: 1. Need a third class, requires a lot more code and space.2. Increase the complexity of code.",Singleton.public class USMoney {  public static final USMoney oneDollar = new USMoney();  private USMoney() { }  oneDollar = '$1';  //...any other methods...},"1. Return a floating point, which has two digits of cents.Adv: Real world is using this format.Dis: Less digits to represent the number of dollars.2. Return two long integer one for dollars, the other for cents.Adv: Can represent large number of dollars.Dis: Waste space, and cents don't need that many of digits.","No. The value of an instance is the amount, getAmount only return this value.getAmount can be used for converting between different formats, and return the format of amount that user requrires.","Objects need to be converted to a plain values to multiply of divide another object. If use plain doubles, this step will not be needed.","1. Other country's currency class (which needs different display format) can inherit from java.util.Currency class, but override Display method to its own format.2. Other country's currency can delegates to java.util.Currency class, using methods except Display, and use their own Display methods.","1. Put any desired functions into the existing method.2. Initialization costs can be more spread out by not initializing everything at once.3. In some cases, startup appears to be faster.4. Ability to delay until needed information is available.",1. Code needed to check to see if it is time to initialize the value each time it is used.2. Time spent in the above code each time the value is used.3. Overhead for maintaining the inputs for the initialization that may not be needed after the initialization.4. More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.,Prevent the instantiation of multiple objects of this class.,"Need to know the implementation of Object so that to get this type of data. In this example, int is specified.Iterator pattern can avoid this by providing a standard interface for starting an iteration, moving to the next element, and determining whether the end of the collection has been reached. Implement each of the above methods for each type of collection; then callers can simply call them to iterate over the collection.","Observer: ""me""Subject: The executive.",Choice 3.Observer pattern has push model which will notify the Observer whenever there is changes made by Subject. Observer is waiting for Subject's information. So it is Choice 3.,"Push model. Whenever subject(click) occurs, the observer(ActionListener interface) will be notified, no matter the observer needs it or not.","Better suited for Push model: Observer is interested in all information that the subject send. This needs the Observer implements the Subject interface. Then register objects in Observer that want to know information from Subject.Better suited for Pull model: Observer only need subject's information sometimes, it can require the need when necessary.This requires the subject call its methods that will notify Observer its changes."
,,,88.5,2,0,2,2,1,2,0,0,2,0,2,0,0,0,2,3,4,2,4,2,2,2,4,3,3,3,3,4,2,2,5,3,3,1.5,6,2,4,4,2
,,,,"Transcendental functions might need special consideration when integrating them, especially when limits are nearing infinity. As such, the Strategy pattern would be most useful in order to determine the best way to numerically integrate a function.","I believe the Builder pattern would be the most useful. This would allow the controller/director to specify which methods to call, and inside those methods each concrete builder would be able to specify how each of those sections should be called.","This is a perfect example of the Composite pattern, as it allows the program to create individual objects and collections in the same manner.","This sounds like an application of the Adapter pattern, which allows two disparate interfaces to interact.",I believe the Singleton pattern is most applicable here for the String class. This is because the string itself is the only data of interest (unlike potential metadata concerns in the buffered string). Possibly related would be the Flyweight pattern.,"With such a complex interaction between disparate systems that vary independently, this sounds like an application of the Bridge pattern.","Since you are ""cloning"" the other side, I think this would be an application of the Prototype pattern.",This sounds like an implementation of the Iterator pattern because it is going through a collection that does not care about the objects being stored.,This is not an Adapter because it does not (necessarily) involve the wrapping of objects to contain a particular interface.,I think this is an example of the Abstract Factory pattern because there is a known interface implemented by the involved abstractions.,"This is not an example of Prototype because there is no ""cloning"" going on in preservation of resources. In fact, the build of the different styles could be very different, so prototype does not apply.","This sounds like the Chain of Responsibility pattern, where each subsequent object is responsible for its dependent (composite-wise) classes.",This is not an Adapter because there are no (known) incompatibile interfaces involved.,This seems like an implementation of the Observer pattern because of its event handling capacities.,"This is not an Abstract Factory mainly because there is no construction of new objects involved, as the Observer pattern is a behavioral pattern while Abstract Factory is a creational pattern.","No, because it does not keep the class in a well-formed state. This is because it allows the hours and minutes be set outside their expected values (0-23 and 0-59, respectively).","A class invariant would be the bounds for the hours and minutes, 0-23 and 0-59, respectively.","The implied preconditions are that A is not null, B is not null, and A.length == B.length. The compiler-enforced precondition is that the arguments are integer arrays.","Yes.If B is larger than A, what happens to B's extra values? Are they truncated? Set to zero?What if one or more of the preconditions are not satisifed? Is an error raised, or does it just do nothing?",The postconditions are that A[i] == B[i] for all i = 0 to A.length. Implied conditions could be that nothing is null.,The compiler-enforced precondition of using integer arrays could be removed by changing the argument types to Object arrays and performing appropriate deep clones on each element.,"Items are not related to shopping carts, but shopping carts need to hold items to be useful. Therefore, Items should know nothing about the shopping cart (Law of Demeter). As such, the shopping cart class should be the one responsible for determining whether two items are the same, even if it is a call to the Item's equals()/hashCode() method which performs a check on the ProductID. Also, this puts each Item in the context of a shopping cart.","This example is wrong because it is dependent on the specific implementation of clone() (deep versus shallow), and how the garbage collector determines which objects to recycle.","Advantages:Easy to understand composition, each person ""knows"" their birth place.Disadvantages:Tightly coupled to the Location class, and is dependent on a concrete class rather than abstraction. Also, makes it difficult to group people by birthplace since each Person object would have to be inspected.",Advantages:Allows locations to exist without a person associated. Also allows for easy grouping of Person objects with the same birth place.Disadvantages:Does not allow a Person object to inherently know its birth place since it would have to poll all existing Location objects (which might make the Person object dependent on the Location class).,"Advantages:""Mediator"" allows object interfaces to vary independently.Disadvantages:Neither object inherently knows their relationship to the other without help from the mediator.",One could use lazy instantiation in a USMoney constructor whereby a oneDollar object is created that is private and static. This would be a derivative of the singleton pattern. The USMoney class could expose a static public member method like getDollarInstance() which is able to access the private oneDollar object.,"The getAmount method could definitely be overloaded, where it could be parameterized with something like a FormatProvider Interface. This way, someone could pass in an object that implements the format provider, and the getAmount method could visit it in order to return a format that the user prefers. This provides the advantage of an extensible and robust solution at the expense of more ""boiler plate"" code.Other alternatives would be parameterizing with a type, but this would need something like a case statement in the method, which would violate the open-closed principle.","The getAmount method is not necessarily required since it depends on the particular use/contract in the system. getAmount as-implemented is useful if there is a ""common denominator"" class that can take cents as an argument. Otherwise, implicit casts could be built in so that it can interact intuitively with other money classes and Java APIs.","This is because the native value returned by getAmount is a long, which by its very nature truncates any remainders when one is divided by another. Providing it as a double forces an explicit cast. These remainders are important for determining if the rounding of fractions of a cent should go up or down.","I believe something like this could be implemented with the Template Method pattern, where a concrete class like java.util.Currency could be provided to a YenPrinter/USDPrinter/CADPrinter class, all with the same ""printCultureSensitive"" method. This way, the interface remains consistent and the printing definitions are extensible.",An advantage of lazy instantiation is that objects that require a lot of resources do not have to be created until they are needed -- if at all.,"A disadvantage of lazy instantiation is that the instantiation required just-in-time might be disruptive, and special care needs to be taken when null values might be referenced.",Lazily instantiated fields should not be made public so that the object can properly handle any requests for invalid objects.,"This design ""smells"" because it is not fully implementing the intent of the Iterator pattern. In particular, it forces the algorithm to be able to access the collections objects with an index, where that might not be applicable (or arbitrary) depending on the collection, as would be the case in a Dictionary or Hash Table. Furthermore, the onus of casting the Object as its proper type is not ""baked in"" to the functionality of the iterator alternative.","The Observer (subscriber) would be me as the caller, while the executive('s assistant) would be the Subject (publisher). That is, I would want to receive notice when the executive broadcasts he or she is available.","I think the third choice, ""Leave a message asking the executive to call you back when she is free"" is most applicable to the Observer pattern, because it allows for the possibility of a significant delay in response, and allows me to carry on with other duties.The first two choices are like synchronous I/O, with the first one being blocking, and the second one being non-blocking/polling.","The ActionListener interface uses the Push model, since no active polling is taking place. Active polling, especially by more than one thread as would be the case for each individual button object on a UI, would be impractical and a waste of resources.","A Push model is useful for when a particular condition will take an indefinite amount of time to occur and system responsiveness is expected, as would be the case in most applications with a graphical user interface.A Pull model is useful for applications that require knowledge of an event occuring, but real-time/immediate response is not an expectation of the end user. This might be implemented in something like an event scheduler or screen saver trigger, which might check a clock every minute for a new task to complete/condition to check for activity."
,,,95.5,2,0,2,2,2,2,1,0,2,2,2,0,2,0,2,3,4,2,4,2,1,3,0,3,3,3,3,4,2,3,7,2,3,2.5,6,2,4,4,4
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,Strategy,Decorator,Composite,Adapter,Flyweight,Bridge,Memento,Template Method,"Adapter just handles wrapping the functionality of one class to fit the interface of another.  Here, there is not a previous interface to conform to.  Thus, because the BubbleSorter class is an abstract class that is designed to run a particular set of functions, namely outOfOrder() and swap(); these are always called, regardless of the type of elements that are being sorted, thus this is a Template pattern.",Abstract Factory,"Prototype pattern generates objects based off of an already initialized object, via clone().   In this case, the user knows that the implementation is based on an abstract class like Letter or Resume but does not know what type.  Since the types can be easily grouped into the common themes of Letter and Resume, each with variations, we should use Abstract Factory.",Chain of Responsibility,"Because each class does and handles a specific portion of the inventory application.  An adapter is not suited for this, nor does it make sense given there is no existing interface to provide.",Flyweight,"A Flyweight design pattern would be used since an existing dialog that is open should be reused.  An Abstract Factory wouldn't make sense because a different dialog would be created each time one is needed, regardless if it is already open.","When the object is initialized, the values of hour and minutes are not set to anything, resulting in an initial invalid value. Thus, the class is not well formed.",The instance variables hour and minutes are class invariant since they will not change between public method calls.,The array B must have the same length as array A,There is no clarification as to what would happen if the sizes of array A and array B are not the same.,The values of array A will be copied into array B in the same order and old values of B are lost.,"The postcondition should be modified to explain the outcome in the event that the lengths of A and B are not the same. For instance, maybe the smaller of the two sizes will be the number of objects copied in this case.",Item should be responsible for determining the equality of two Item objects in keeping with the Expert pattern.  This separates the ShoppingCart class from the implementation details of Item.,The result of a clone() is of type Object.  The result must be cast into the correct type to work.  For example:o2 = (MyClass) o1.clone();,Advantages:  - Easy to get a list of all People.Disadvantages:  - Not very flexible since a change if the Location object would likely result in a change of the Person object. (High Coupling)  - More complexity when a list of all Locations is required.  - There is the possibility of duplicate Location objects resulting in more memory overhead.,Advantages:  - Easy to get a list of all people born at a Location.  - Less memory overhead than the method mentioned above since Locations are not duplicated.Disadvantages:  - Not very flexible since a change if the Location object would likely result in a change of the Person object. (High Coupling)  - More complexity when a list of all Persons is required.,"Advantages:  - A list of either people or locations is easily obtained.  - If the third object adequately abstracts the Person and Location objects, the objects can be changed with no effect on the third object.Disadvantages:  - More memory overhead due to the space required to save the table.","A Flyweight pattern could be designed that allowed reuse of individual sums of money.  Any time an existing monetary object is needed, the Flyweight object provides it.","getAmount() could return a value in a float, or as two longs representing dollars and cents.  In the case of a float, it would be easy to do any type of mathematical operations to it, but due to the floating point implementation there could be rounding errors to deal with.  Not to mention that more than two decimal places is extraneous for the purposes of this class.  As far as having two longs to represent dollars and cents, this avoids the issues of having to deal with rounding issues as mentioned above but involves extra complexity when doing mathematical operations due to carrying over cents to dollars during addition and subtraction.  This is further complicated when multiplication and division are involved.","The getAmount() method prevents the user from having direct access to the private instance variable, thus providing it's immutability.  Hence, we do need the getAmount() method.","Because adding and subtracting of USMoney objects makes sense in terms of what USMoney represents.  However, dividing by a monetary amount does not make sense in terms of money (ie, sales tax percentage isn't specified in dollars, etc...).  Instead, the money is divided by doubles since this makes sense for money and can help to prevent inadvertent division by an improper object.",A decorator pattern could be applied to the Money object in the cases that specialized currency formats would need to be printed.,"Upon creation of an object, the initialization can be delayed for performance and memory conservation for large or complex objects (this is especially the case if the object is never used).",There is additional overhead when checking to see if the object needs to be initialized each time the object is accessed.  There is also the overhead of storing the initialization parameters for when the object is actually initialized.,"If the variable were publicly available, the user could potentially try and use the instance variable before it was actually initialized.",This method assumes that the iteration sequence is in strictly numerical order and is not extensible across objects that might store the elements in a different order.  It also does not abstract this information away from the user.,Observer is the caller and the Subject is the Executive.,"The last one corresponds most closely to the Observer pattern.  This is because the Observer is relying on the Subject to inform it when an event occurs (specifically, the executive is free).","Push model.  This is because when a button is pressed, it provides data to the observer by calling the observer's actionPerformed() method rather than having the observer poll the button.","A pull model is better suited for a large number of observers which may not all need the data immediately.  This means that the data will be retrieved when the observer needs it, thus potentially reducing the overhead of data being pushed to many observers at once.A push model is better suited for a smaller number of observers which may need low latency access to the data provided by the subscriber."
,,,102,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,3,0,2,4,2,2,5,3,3,3,3,3,4,2,2,7,3,3,2,6,2,4,4,4
,,,,Strategy pattern,Template template.,Composite pattern,Adapter.,Singleton pattern.,Bridge pattern.,Prototype pattern,This is facade pattern.,"It is not an adapter pattern because we are not trying to design to an existing interface. Instead the sort function calls a subset of the functions i.e., outOfOrder and swap (there could be more functions in the BubbleSorter) and defines a new interface for the clients to use.",This is the Factory Pattern.,In prototype there is a single instance of a class that is used to create other instances generally using the 'clone' method. The pattern above doesn't use cloning and allows each class to implement its own individual constructor (or a method to construct an object of the specific class),Chain of Responsibility,"An adapter pattern is used when there is an existing interface that we need to design to and that doesn't match the interface of the class we have designed. In this case there is no mention of mismatching interfaces between the client, the database, the model and the element classes.",Singleton pattern,This is because there is only one instance of each dialog box that is allowed. The Abstract factory allows you to create several instances of a class.,No it is not a well formed class. Skrien defines a well formed class that conform to class invariants between public method calls that can mutate the state of the object. In this case the setter methods don't do any validation checks and hence can change the state of the object that doesn't meet the class invariants.The setter methods here don't do any validation checks and hence can leave the object in a state that doesn't meet the class invariants.,A class invariants for this class would be:1. the hour value should always be less than 242. the hour value should always be a positive value.3. the minutes value should always be less than 60 and be a positive value.,1. The array B must have the length as array A.,"Yes.  The post-conditions are not complete. For e.g. it is assumed that the values of the array elements will match once the copy is done, the post-condition doesn't however mention this. This might be assumed, however in a multi-threaded case this is not a safe assumption.",1. Old values of B will be lost2. Contents of B will match that of A (B[i] == A[i])3. Ordering of values. should be identical,"We can eliminate the pre-condition by making the post-condition stronger, if the size of array B is smaller than the size of array A then we can throw a size-mismatch exception which will tell the client that the sizes of the two arrays dont match","It can be implemented as a conditional singleton pattern inside the Item class. The _items array-list can be maintained as a list sorted by the product-id. When the constructor for item is called, it will check if the reference to the item object at the corresponding index location in the array-list is null, if it is null then it will create a new item otherwise it will just increment the count of items for the existing item object.","By default Java does shallow copying, so when o1 is nulled out it is entirely possible that the objects contained with o1 will be recycled by the garbage collector. This will then result in o2 eventually accessing junk memory locations when it executes the anymethod() function resulting in exceptions. Also the example above doesn't do the necessary type casting .","Advantages:1. Easy to determine where a person was born by merely looking up the location object.Disadvantages1. It increases coupling between the two classes 2. If we wanted to list all the people born in a particular location, there is no easy way to do this. We would need to have a collection of people and iterate through that collection with a comparison.",Advantages: 1. Given a location object it becomes easy to list all the people born there.Disadvantage:1. Given a person object there is no easy way to tell where he/she was born. This would need us to have a collection of location objects and iterate through them with a comparison check for the person whose birth location we are trying to determine. 2. This also increases the coupling between the two classes.,Advantages:1. This is probably the best approach since the coupling between the clases is broken. We instead use the principle of delegation where a third class is responsible to maintain the relationship between the person and the location classes.2. It is easy to find out where a person was born by a lookup3. Similarly it is easy to iterate through this data structure to find out everybody born in a certain location since we are already maintaining this as a collection.,We should use the singleton pattern for this. The constructor should check if there is a money object with value equal to $1 and should not create any new objects if it already exists.,"Yes. There are a few  alternatives:1. One could return another USMoney object that  returns the value in terms of dollares and cents.2. One could return a string value which represents the value in standard currency format including the $ symbol and the three letter code.3. One could have rounded getter methods that round up/down the value of the money object.The advantages of all of these primarily are the  ease of use. The client program doesn't have to deal with the converting the value back to dollars or to a string format. In addition if the client is asked to do this conversion from cents to dollars or a string format, this would violate the 'expert' pattern as well.","The USMoney object has two integer fields, for dollars and cents. We can use the getamount() method to pass it in to a sort function that can then sort an array of these objects. Without this function it would be difficult to get a single value for the money object that can be used for comparisons and sort functions.","This use more reflective of real life use of money. For e.g. banks calculate will the interest amount which will need the deposit in the customer's bank account, represented by a money object, to be multiplied by the interest rate. The interest rate is often a floating point number and hence the multiply and divide functions use doubles . It doesn't make much sense to multiply two money objects since that is not what we do in real life. However, an additional deposit in the bank account equates to adding two money objects and similarly a withdrawal equates to subtracting two money objects. Hence the class supports addition and subtraction of money objects while it supports multiplication and division by doubles.","One could either extend the java.util.Currency class  that outputs the format in addition to the 3 letter code  itself. For e.g. it could tell you the position of the code to be at the start or the beginning. Extending the java.util.Currency class makes sense because all the required state of which country we are dealing with is already present here. We would only have to define special 'toString' functions for the countries that require special treatment, however they would already have all the necessary state such as the three-letter code and the currency symbol.","1. If you never use the value, you don't pay the initialization cost. Some of the instance variables can be references to other objects and not creating them can save memory and computation during initialization.2. Initialization costs can be more spread out by not initializing everything at once.3. Ability to delay until needed information is available.","1. The code needed to check to see if it is time to initialize the value is used every time.2. This code is executed even after the value has been initializied. 3. More complicated error recovery for dealing with failed initialization far from the point where the inputs were supplied.4. We would also need to be careful in multi-threaded programs where lazy initialization will required the 'synchronized' keyword, i.e., some kind of locking to do this safely.",This breaks the OO principle of limiting the object's scope to as narrow as possible. This can also be troublesome in multi-threaded code if appropriate synchronization wasn't used.,"1. This pattern doesn't separate the iteration responsibility from the collection in a manner the iterator pattern does. The get() function is is now implemented by the collection while its primary responsibility should only be storing and retrieving data.2. It violates the expert pattern since we use the get() accessor to get contents of the collection and operate on it outside the collection. 3. There is also a subtle implementation issue of the size() function. For data structures such as linked-list and trees this often will imply a separate walk of the data structure which is highly inefficient since we are already going to be iterating over the data structure. One can keep a separate 'count' field in the data structure to count the number of elements, but this approach is fraught with bugs and is not very suitable for multi-threaded code.",The observer is myself and the publisher in this case is the executive. Leaving a message is equivalent to registering myself with the publisher,The last or the 3rd pattern:Leave a message asking the executive to call you back when she is free is the closest to the Observer pattern. This is because leaving a message is equal to registering yourself as a listener while the executive  calling back is the same as the publisher letting the observer know that the event happened which in this case is the executive returning.,"This is the push model because the publisher or the subject, in this case the JButton, notifies all listeners by calling their actionPerformed methods. Here the publisher is sending the information to the listeners whether they need it or not.","A pull model is more useful when there are frequent state changes in the subject's state that is being monitored. It allows the client to selectively pull information from the subject reducing inefficiencies. This is also useful when the observer is observing a single subject and has a reference to it. This allows the observer to poll the subject directly and no information needs to be passed via the update method.A push method is useful when there are an arbitrary number of observers that can change at any time. Also, the publishers and the subscribers are not tightly coupled. This is also useful whne the  subject doesn't  know the actual class of the subscribers as long as it knows that they are observers."
,,,98.5,2,1,2,2,1,2,1,0,2,1,2,0,2,2,2,3,4,2,4,2,2,2,4,3,3,3,3,4,2,3,5,3,3,2.5,6,2,4,4,3
